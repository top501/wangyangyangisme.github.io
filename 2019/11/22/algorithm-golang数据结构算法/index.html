<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>golang数据结构算法 | WangYangYang</title><meta name="description" content="golang数据结构算法"><meta name="author" content="Wang YangYang"><meta name="copyright" content="Wang YangYang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="golang数据结构算法"><meta name="twitter:description" content="golang数据结构算法"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/algorithm/38b729ad735ef910dc048dd9c1a11743.jpg"><meta property="og:type" content="article"><meta property="og:title" content="golang数据结构算法"><meta property="og:url" content="http://wangyangyangisme.github.io/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="WangYangYang"><meta property="og:description" content="golang数据结构算法"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/algorithm/38b729ad735ef910dc048dd9c1a11743.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wangyangyangisme.github.io/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><link rel="prev" title="前端常用库收集" href="http://wangyangyangisme.github.io/2019/11/26/frontend-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%BA%93%E6%94%B6%E9%9B%86/"><link rel="next" title="go知识图谱" href="http://wangyangyangisme.github.io/2019/11/22/golang-go%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C4QN4OTLJM","apiKey":"c2c026ba64eeb77abd2164975fa41f34","indexName":"wyy","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://wangyangyangisme.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">187</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">36</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-排序"><span class="toc-text">1.排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-冒泡排序"><span class="toc-text">1.1 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-冒泡排序优化版"><span class="toc-text">1.1.1 冒泡排序优化版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-双向冒泡排序-鸡尾酒排序"><span class="toc-text">1.1.2 双向冒泡排序(鸡尾酒排序)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-选择排序"><span class="toc-text">1.2 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-插入排序"><span class="toc-text">1.3 插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-希尔排序"><span class="toc-text">1.4 希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-快速排序"><span class="toc-text">1.5 快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-归并排序"><span class="toc-text">1.6 归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-堆排序"><span class="toc-text">1.7 堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-计数排序"><span class="toc-text">1.8 计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-基数排序"><span class="toc-text">1.9 基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-桶排序"><span class="toc-text">1.10 桶排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-查找"><span class="toc-text">2.查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-顺序查找"><span class="toc-text">2.1 顺序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-插值查找"><span class="toc-text">2.2 插值查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-二分查找"><span class="toc-text">2.3 二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-链表"><span class="toc-text">3.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-单链表"><span class="toc-text">3.1 单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-双链表"><span class="toc-text">3.2 双链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-队列"><span class="toc-text">4.队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-链式队列"><span class="toc-text">4.1 链式队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-数组队列"><span class="toc-text">4.2 数组队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-优先队列"><span class="toc-text">4.3 优先队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-栈"><span class="toc-text">5.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-数组栈"><span class="toc-text">5.1 数组栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-链式栈"><span class="toc-text">5.2 链式栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-堆"><span class="toc-text">6.堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-二叉堆"><span class="toc-text">6.1 二叉堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-集合"><span class="toc-text">7.集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-列表"><span class="toc-text">8.列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-哈希表"><span class="toc-text">9.哈希表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-树"><span class="toc-text">9.树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-二叉树"><span class="toc-text">9.1 二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-二分搜索树"><span class="toc-text">9.2 二分搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-红黑树"><span class="toc-text">9.3 红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Trie字典树"><span class="toc-text">9.4 Trie字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-线段树"><span class="toc-text">9.5 线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-平衡二叉树"><span class="toc-text">9.6 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-B树-2-3-4树"><span class="toc-text">9.7 B树(2-3-4树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-B-树"><span class="toc-text">9.8 B+树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-图"><span class="toc-text">10.图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-网"><span class="toc-text">10.1 网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-图的存储结构"><span class="toc-text">10.2 图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-邻接矩阵-顺序存储"><span class="toc-text">10.2.1 邻接矩阵(顺序存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-邻接表-链式存储"><span class="toc-text">10.2.2 邻接表(链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-十字链表-链式存储"><span class="toc-text">10.2.3 十字链表(链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-4-邻接多重表-链式存储"><span class="toc-text">10.2.4 邻接多重表(链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-5-总结"><span class="toc-text">10.2.5 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-有向无向图"><span class="toc-text">10.3 有向无向图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-最短路径"><span class="toc-text">11.最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-Dijkstra"><span class="toc-text">11.1 Dijkstra</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-Prim"><span class="toc-text">11.2 Prim</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-Kruskal"><span class="toc-text">11.3 Kruskal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-LRU"><span class="toc-text">12.LRU</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/algorithm/38b729ad735ef910dc048dd9c1a11743.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangYangYang</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">golang数据结构算法</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-22<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-26</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">29.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 164 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p><a href="https://github.com/skyhee/Algorithms-Learning-With-Go" target="_blank" rel="noopener">https://github.com/skyhee/Algorithms-Learning-With-Go</a></p>
</blockquote>
<h1 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h1><h2 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h2><h3 id="1-1-1-冒泡排序优化版"><a href="#1-1-1-冒泡排序优化版" class="headerlink" title="1.1.1 冒泡排序优化版"></a>1.1.1 冒泡排序优化版</h3><p><strong>检测是否已提前有序</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 遍历所有元素</span></span><br><span class="line">	<span class="keyword">var</span> isSorted <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		isSorted = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="comment">// 左元素 &gt; 右元素</span></span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">				<span class="comment">// 发生交换则还未排序完毕</span></span><br><span class="line">				isSorted = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">"[DEBUG]:\t"</span>, arr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有发生交换则说明排序完成</span></span><br><span class="line">		<span class="keyword">if</span> isSorted &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = BubbleSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缩短扫描距离</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	end := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> end &gt; <span class="number">0</span> &#123;</span><br><span class="line">		cur := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; end; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 记录每趟最后发生交换的位置，此位置之后均已有序，下一趟只需遍历到此位置即可</span></span><br><span class="line">			cur = j</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG]:\t"</span>, arr)</span><br><span class="line">		end = cur</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = BubbleSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-1-2-双向冒泡排序-鸡尾酒排序"><a href="#1-1-2-双向冒泡排序-鸡尾酒排序" class="headerlink" title="1.1.2 双向冒泡排序(鸡尾酒排序)"></a>1.1.2 双向冒泡排序(鸡尾酒排序)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">	right := n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// left  以左已有序</span></span><br><span class="line">	<span class="comment">// right 以右已有序</span></span><br><span class="line">	<span class="comment">// 两个区间游标相遇则集合有序</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		<span class="comment">// 从左到右，选出最大值</span></span><br><span class="line">		<span class="keyword">for</span> i := left; i &lt; right; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[i] &gt; arr[i+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[i], arr[i+<span class="number">1</span>] = arr[i+<span class="number">1</span>], arr[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		right--</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG right]:\t"</span>, arr)</span><br><span class="line">		<span class="comment">// 从右到左，选出最小值</span></span><br><span class="line">		<span class="keyword">for</span> i := right; i &gt; left; i-- &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[i<span class="number">-1</span>] &gt; arr[i] &#123;</span><br><span class="line">				arr[i<span class="number">-1</span>], arr[i] = arr[i], arr[i<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		left++</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG left]:\t"</span>, arr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = BubbleSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectSort</span> <span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 假设无序区间第一个值为最小值</span></span><br><span class="line">		min := i</span><br><span class="line">		<span class="keyword">for</span> next := min + <span class="number">1</span>; next &lt; n; next++ &#123;</span><br><span class="line">			<span class="comment">// 找到更小值，记录其位置</span></span><br><span class="line">			<span class="keyword">if</span> arr[min] &gt; arr[next] &#123;</span><br><span class="line">				min = next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将无序区间的最小值追加到有序区间</span></span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG min]:\t"</span>, arr[min])</span><br><span class="line">		arr[i], arr[min] = arr[min], arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = SelectSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h2><p>平均时间复杂度 O(n2)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span> <span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"[ALREADY SORTED]:\t"</span>, arr)</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历所有元素</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 向前找位置</span></span><br><span class="line">		<span class="keyword">for</span> j := i; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="comment">// 合适位置插入</span></span><br><span class="line">			<span class="keyword">if</span> arr[j<span class="number">-1</span>] &gt; arr[j] &#123;</span><br><span class="line">				arr[j<span class="number">-1</span>], arr[j] = arr[j], arr[j<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG]:\t"</span>, arr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = InsertSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>一般来说时间复杂度为：O(Nlog2N)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span> <span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"[ALREADY SORTED]:\t"</span>, arr)</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	step := n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步长减少到 0 则排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> step &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG step]:\t"</span>, step)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历第一个步长区间之后的所有元素</span></span><br><span class="line">		<span class="keyword">for</span> i := step; i &lt; n; i++ &#123;</span><br><span class="line">			j := i</span><br><span class="line">			<span class="comment">// 前一个元素更大则交换值</span></span><br><span class="line">			<span class="comment">// j &gt;= step	// 避免向下越界</span></span><br><span class="line">			<span class="keyword">for</span> j &gt;= step &amp;&amp; arr[j-step] &gt; arr[j] &#123;</span><br><span class="line">				arr[j-step], arr[j] = arr[j], arr[j-step]</span><br><span class="line">				j -= step</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">"[DEBUG]:\t"</span>, arr)</span><br><span class="line">		&#125;</span><br><span class="line">		step /= <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = ShellSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。快速排序是冒泡排序的优化版，同属于交换类排序。它使用了 “分治法” 的思想，将集合分割为相似子集，再对子集进行递归排序，最后将子集的排序结果组合即可。</p>
<p>分治法</p>
<ul>
<li>先从数列中取出一个数作为key值；</li>
<li>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；</li>
<li>对左右两个小数列重复第二步，直至各区间只有1个数。</li>
</ul>
<p>平均时间复杂度：O(N*logN)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span> <span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">		<span class="built_in">copy</span>(temp, arr)</span><br><span class="line">		<span class="keyword">return</span> temp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用第一个元素作为基准值</span></span><br><span class="line">	pivot := arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 小元素 和 大元素各成一个数组</span></span><br><span class="line">	low := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n)</span><br><span class="line">	high := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更小的元素放 low[]</span></span><br><span class="line">	<span class="comment">// 更大的元素放 high[]</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; pivot &#123;</span><br><span class="line">			low = <span class="built_in">append</span>(low, arr[i])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			high = <span class="built_in">append</span>(high, arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子区间递归快排，分治排序</span></span><br><span class="line">	low, high = QuickSort(low), QuickSort(high)</span><br><span class="line">	fmt.Println(<span class="string">"[DEBUG low]:\t"</span>, low)</span><br><span class="line">	fmt.Println(<span class="string">"[DEBUG high]:\t"</span>, high)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(low, arr[<span class="number">0</span>]), high...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = QuickSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-归并排序"><a href="#1-6-归并排序" class="headerlink" title="1.6 归并排序"></a>1.6 归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。归并排序与快速排序类似，也采用了“分治法”的思想。</p>
<p>快速排序：选取基准后，将集合分割为左右子集合再进行递归分组，最后合并排序好的各子集合.</p>
<p>归并排序：将集合均分为左右子集合，各自在内部进行递归排序，最后合并排序好的各子集合</p>
<p>平均时间复杂度：O(NlogN)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 遍历比较后合并两个数组</span></span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(left) &gt; <span class="number">0</span> || <span class="built_in">len</span>(right) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 数组提前排序完毕</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(left) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">append</span>(res, right...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(right) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">append</span>(res, left...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 比较更小的值追加到 res[] 中</span></span><br><span class="line">		<span class="keyword">if</span> left[<span class="number">0</span>] &lt; right[<span class="number">0</span>] &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, left[<span class="number">0</span>])</span><br><span class="line">			left = left[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, right[<span class="number">0</span>])</span><br><span class="line">			right = right[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span> <span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">	left := MergeSort(arr[:mid])</span><br><span class="line">	right := MergeSort(arr[mid:])</span><br><span class="line">	arr = merge(left, right)</span><br><span class="line">	fmt.Println(<span class="string">"[DEBUG merged]:\t"</span>, arr)</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = MergeSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法（一般升序采用大顶堆，降序采用小顶堆)：</p>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arrLen := <span class="built_in">len</span>(arr)</span><br><span class="line">	buildMaxHeap(arr, arrLen)</span><br><span class="line">	<span class="keyword">for</span> i := arrLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		swap(arr, <span class="number">0</span>, i)</span><br><span class="line">		arrLen -= <span class="number">1</span></span><br><span class="line">		heapify(arr, <span class="number">0</span>, arrLen)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(arr []<span class="keyword">int</span>, arrLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := arrLen / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(arr, i, arrLen)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="keyword">int</span>, i, arrLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">	right := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">	largest := i</span><br><span class="line">	<span class="keyword">if</span> left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">		largest = left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">		largest = right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">		swap(arr, i, largest)</span><br><span class="line">		heapify(arr, largest, arrLen)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(arr []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = HeapSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-8-计数排序"><a href="#1-8-计数排序" class="headerlink" title="1.8 计数排序"></a>1.8 计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>时间复杂度为 ：O(N + max + 1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	max = arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> max &lt; v &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	max := getMax(arr)</span><br><span class="line">	sortedArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">	countsArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, max+<span class="number">1</span>) <span class="comment">// max+1 是为了防止 countsArr[] 计数时溢出</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 元素计数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		countsArr[v]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计独特数字个数并累加</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= max; i++ &#123;</span><br><span class="line">		countsArr[i] += countsArr[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"[DEBUG countsArr]:\t"</span>, countsArr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 让 arr 中每个元素找到其位置</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		sortedArr[countsArr[v]<span class="number">-1</span>] = v</span><br><span class="line">		<span class="comment">//fmt.Print(countsArr[v]-1, " ")</span></span><br><span class="line">		<span class="comment">// 保证稳定性</span></span><br><span class="line">		countsArr[v]--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sortedArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = CountSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-基数排序"><a href="#1-9-基数排序" class="headerlink" title="1.9 基数排序"></a>1.9 基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RadixSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	max := getMax(arr)</span><br><span class="line">	<span class="comment">// 数组中最大值决定了循环次数，101 循环三次</span></span><br><span class="line">	<span class="keyword">for</span> bit := <span class="number">1</span>; max/bit &gt; <span class="number">0</span>; bit *= <span class="number">10</span> &#123;</span><br><span class="line">		arr = bitSort(arr, bit)</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG bit]\t"</span>, bit)</span><br><span class="line">		fmt.Println(<span class="string">"[DEBUG arr]\t"</span>, arr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 对指定的位进行排序</span></span><br><span class="line"><span class="comment">// bit 可取 1，10，100 等值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bitSort</span><span class="params">(arr []<span class="keyword">int</span>, bit <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">// 各个位的相同的数统计到 bitCounts[] 中</span></span><br><span class="line">	bitCounts := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		num := (arr[i] / bit) % <span class="number">10</span></span><br><span class="line">		bitCounts[num]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		bitCounts[i] += bitCounts[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		num := (arr[i] / bit) % <span class="number">10</span></span><br><span class="line">		tmp[bitCounts[num]<span class="number">-1</span>] = arr[i]</span><br><span class="line">		bitCounts[num]--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = tmp[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中最大的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="params">(max <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	max = arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> max &lt; v &#123;</span><br><span class="line">			max = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = RadixSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-桶排序"><a href="#1-10-桶排序" class="headerlink" title="1.10 桶排序"></a>1.10 桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 n 个 [0, max] 元素组成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArr</span><span class="params">(n, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		arr[i] = rand.Intn(max + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortInBucket</span><span class="params">(bucket []<span class="keyword">int</span>)</span></span> &#123;<span class="comment">//此处实现插入排序方式，其实可以用任意其他排序方式</span></span><br><span class="line">	length := <span class="built_in">len</span>(bucket)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">1</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length; i++ &#123;</span><br><span class="line">		backup := bucket[i]</span><br><span class="line">		j := i <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//将选出的被排数比较后插入左边有序区</span></span><br><span class="line">		<span class="keyword">for</span>  j &gt;= <span class="number">0</span> &amp;&amp; backup &lt; bucket[j] &#123;<span class="comment">//注意j &gt;= 0必须在前边，否则会数组越界</span></span><br><span class="line">			bucket[j+<span class="number">1</span>] = bucket[j]<span class="comment">//移动有序数组</span></span><br><span class="line">			j -- <span class="comment">//反向移动下标</span></span><br><span class="line">		&#125;</span><br><span class="line">		bucket[j + <span class="number">1</span>] = backup <span class="comment">//插队插入移动后的空位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取数组最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxInArr</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	max := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; max&#123; max = arr[i]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">桶排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BucketSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//桶数</span></span><br><span class="line">	num := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="comment">//k（数组最大值）</span></span><br><span class="line">	max := getMaxInArr(arr)</span><br><span class="line">	<span class="comment">//二维切片</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配入桶</span></span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		index = arr[i] * (num<span class="number">-1</span>) /max<span class="comment">//分配桶index = value * (n-1) /k</span></span><br><span class="line"></span><br><span class="line">		buckets[index] = <span class="built_in">append</span>(buckets[index], arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//桶内排序</span></span><br><span class="line">	tmpPos := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		bucketLen := <span class="built_in">len</span>(buckets[i])</span><br><span class="line">		<span class="keyword">if</span> bucketLen &gt; <span class="number">0</span>&#123;</span><br><span class="line">			sortInBucket(buckets[i])</span><br><span class="line"></span><br><span class="line">			<span class="built_in">copy</span>(arr[tmpPos:], buckets[i])</span><br><span class="line"></span><br><span class="line">			tmpPos += bucketLen</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := GetArr(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[UNSORTED]:\t"</span>, arr)</span><br><span class="line">	arr = BucketSort(arr)</span><br><span class="line">	fmt.Println(<span class="string">"[SORTED]:\t"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h1><h2 id="2-1-顺序查找"><a href="#2-1-顺序查找" class="headerlink" title="2.1 顺序查找"></a>2.1 顺序查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	items := []<span class="keyword">int</span>&#123;<span class="number">95</span>, <span class="number">78</span>, <span class="number">46</span>, <span class="number">58</span>, <span class="number">45</span>, <span class="number">86</span>, <span class="number">99</span>, <span class="number">251</span>, <span class="number">320</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> index := linearSearch(items, <span class="number">45</span>); index == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not exist"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"exist, index is %d\n"</span>, *index)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">linearSearch</span><span class="params">(a []<span class="keyword">int</span>, key <span class="keyword">int</span>)</span> <span class="params">(index *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, item := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> item == key &#123;</span><br><span class="line">			index = &amp;i</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-插值查找"><a href="#2-2-插值查找" class="headerlink" title="2.2 插值查找"></a>2.2 插值查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	items := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">	sort.Ints(items)</span><br><span class="line"></span><br><span class="line">	fmt.Println(interpolationSearch(<span class="number">5</span>, items))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">interpolationSearch</span><span class="params">(key <span class="keyword">int</span>, a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		<span class="keyword">var</span> guess <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">if</span> high == low &#123;</span><br><span class="line">			guess = high</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			size := high - low</span><br><span class="line">			offset := size * (key - a[low]) / (a[high] - a[low])</span><br><span class="line">			guess = low + offset</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> a[guess] &lt; key &#123;</span><br><span class="line">			low = guess + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[guess] &gt; key &#123;</span><br><span class="line">			high = guess - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-二分查找"><a href="#2-3-二分查找" class="headerlink" title="2.3 二分查找"></a>2.3 二分查找</h2><p>二分查找前提是有序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	items := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort</span></span><br><span class="line">	sort.Ints(items) <span class="comment">// &#123;1, 2, 3, 5, 6, 7, 8, 9&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非递归</span></span><br><span class="line">	fmt.Println(BinarySearch(<span class="number">8</span>, items))  		<span class="comment">// -1: 查找不到你</span></span><br><span class="line">	<span class="comment">// 递归</span></span><br><span class="line">	fmt.Println(BinarySearchRecursive(<span class="number">8</span>, items)) <span class="comment">// -1: 查找不到你</span></span><br><span class="line">	<span class="comment">// 查找第一个等于给定值的元素</span></span><br><span class="line">	fmt.Println(BinarySearchFirst(<span class="number">8</span>, items)) <span class="comment">// -1: 查找不到你</span></span><br><span class="line">	<span class="comment">// 查找最后一个值等于给定值的元素</span></span><br><span class="line">	fmt.Println(BinarySearchLast(<span class="number">8</span>, items)) <span class="comment">// -1: 查找不到你</span></span><br><span class="line">	<span class="comment">// 查找第一个大于等于给定值的元素</span></span><br><span class="line">	fmt.Println(BinarySearchFirstGT(<span class="number">8</span>, items)) <span class="comment">// -1: 查找不到你</span></span><br><span class="line">	<span class="comment">// 查找最后一个小于等于给定值的元素</span></span><br><span class="line">	fmt.Println(BinarySearchLastLT(<span class="number">8</span>, items)) <span class="comment">// -1: 查找不到你</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(key <span class="keyword">int</span>, a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := low + (high-low)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> a[mid] &lt; key &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[mid] &gt; key &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchRecursive</span><span class="params">(v <span class="keyword">int</span>,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bs(a, v, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bs</span><span class="params">(a []<span class="keyword">int</span>, v <span class="keyword">int</span>, low, high <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> low &gt; high &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mid := (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> a[mid] == v &#123;</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[mid] &gt; v &#123;</span><br><span class="line">		<span class="keyword">return</span> bs(a, v, low, mid<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bs(a, v, mid+<span class="number">1</span>, high)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找第一个等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchFirst</span><span class="params">(v <span class="keyword">int</span>,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[mid] &gt; v &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[mid] &lt; v &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> mid == <span class="number">0</span> || a[mid<span class="number">-1</span>] != v &#123;</span><br><span class="line">				<span class="keyword">return</span> mid</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				high = mid - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchLast</span><span class="params">(v <span class="keyword">int</span>,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[mid] &gt; v &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[mid] &lt; v &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> mid == n<span class="number">-1</span> || a[mid+<span class="number">1</span>] != v &#123;</span><br><span class="line">				<span class="keyword">return</span> mid</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				low = mid + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchFirstGT</span><span class="params">(v <span class="keyword">int</span>,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		<span class="comment">//避免溢出</span></span><br><span class="line">		mid := low + (high-low)&gt;&gt;<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[mid] &gt;= v &#123;</span><br><span class="line">			<span class="keyword">if</span> mid == <span class="number">0</span> || a[mid<span class="number">-1</span>] &lt; v &#123;</span><br><span class="line">				<span class="keyword">return</span> mid</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				high = mid - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchLastLT</span><span class="params">( v <span class="keyword">int</span>,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := low + (high-low)&gt;&gt;<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[mid] &gt; v &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> mid == n<span class="number">-1</span> || a[mid+<span class="number">1</span>] &gt; v &#123;</span><br><span class="line">				<span class="keyword">return</span> mid</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				low = mid + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h1><h2 id="3-1-单链表"><a href="#3-1-单链表" class="headerlink" title="3.1 单链表"></a>3.1 单链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item the type of the linked list</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node a single node that composes the list</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	data Item</span><br><span class="line">	next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemLinkedList the linked list of Items</span></span><br><span class="line"><span class="keyword">type</span> ItemLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">	head *Node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append adds an Item to the end of the linked list</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">Append</span><span class="params">(t Item)</span></span> &#123;</span><br><span class="line">	ll.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.Unlock()</span><br><span class="line">	node := Node&#123;t, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> ll.head == <span class="literal">nil</span> &#123;</span><br><span class="line">		ll.head = &amp;node</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		last := ll.head</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> last.next == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			last = last.next</span><br><span class="line">		&#125;</span><br><span class="line">		last.next = &amp;node</span><br><span class="line">	&#125;</span><br><span class="line">	ll.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert adds an Item at position i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">Insert</span><span class="params">(i <span class="keyword">int</span>, t Item)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ll.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; ll.size &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Index out of bounds"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	addNode := Node&#123;t, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">		addNode.next = ll.head</span><br><span class="line">		ll.head = &amp;addNode</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	node := ll.head</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i<span class="number">-2</span>; j++ &#123;</span><br><span class="line">		node = node.next</span><br><span class="line">	&#125;</span><br><span class="line">	addNode.next = node.next</span><br><span class="line">	node.next = &amp;addNode</span><br><span class="line">	ll.size++</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAt removes a node at position i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">RemoveAt</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(*Item, error)</span></span> &#123;</span><br><span class="line">	ll.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; ll.size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Index out of bounds"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	node := ll.head</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j &lt; i<span class="number">-1</span> &#123;</span><br><span class="line">		j++</span><br><span class="line">		node = node.next</span><br><span class="line">	&#125;</span><br><span class="line">	remove := node.next</span><br><span class="line">	node.next = remove.next</span><br><span class="line">	ll.size--</span><br><span class="line">	<span class="keyword">return</span> &amp;remove.data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IndexOf returns the position of the Item t</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">IndexOf</span><span class="params">(t Item)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ll.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.RUnlock()</span><br><span class="line">	node := ll.head</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node.data == t &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		node = node.next</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsEmpty returns true if the list is empty</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	ll.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> ll.head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size returns the linked list size</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ll.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.RUnlock()</span><br><span class="line">	last := ll.head</span><br><span class="line">	<span class="keyword">if</span> last == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> last.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		last = last.next</span><br><span class="line">		size++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert adds an Item at position i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">String</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ll.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.RUnlock()</span><br><span class="line">	node := ll.head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; node != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">		fmt.Print(node.data)</span><br><span class="line">		fmt.Print(<span class="string">" "</span>)</span><br><span class="line">		node = node.next</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Head returns a pointer to the first node of the list</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ll *ItemLinkedList)</span> <span class="title">Head</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	ll.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ll.lock.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> ll.head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	list := ItemLinkedList&#123;&#125;</span><br><span class="line">	list.Append(<span class="string">"1"</span>)</span><br><span class="line">	list.Append(<span class="string">"2"</span>)</span><br><span class="line">	list.Append(<span class="string">"3"</span>)</span><br><span class="line">	list.Append(<span class="string">"4"</span>)</span><br><span class="line">	list.Append(<span class="string">"a"</span>)</span><br><span class="line">	list.Append(<span class="string">"b"</span>)</span><br><span class="line">	list.Append(<span class="string">"c"</span>)</span><br><span class="line">	list.Append(<span class="string">"d"</span>)</span><br><span class="line">	list.String() <span class="comment">// 1 2 3 4 a b c d</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">"list length: %v"</span>,list.Size()))</span><br><span class="line"></span><br><span class="line">	_ = list.Insert(<span class="number">1</span>,<span class="string">"x"</span>)</span><br><span class="line">	list.String() <span class="comment">// 1 x 2 3 4 a b c d</span></span><br><span class="line"></span><br><span class="line">	index := list.IndexOf(<span class="string">"a"</span>)</span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">"index: %d"</span>,index))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-双链表"><a href="#3-2-双链表" class="headerlink" title="3.2 双链表"></a>3.2 双链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  LinkList <span class="keyword">interface</span> &#123;</span><br><span class="line">	Clear() <span class="comment">//清空</span></span><br><span class="line">	Len()<span class="comment">//求长度</span></span><br><span class="line">	Front()*Element <span class="comment">//第一个</span></span><br><span class="line">	Back()*Element <span class="comment">//最后一个</span></span><br><span class="line">	Remove(e *Element) * Element</span><br><span class="line">	Setdata(old,<span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Insert(e,mark *Element)*Element</span><br><span class="line">	InsertValue(v <span class="keyword">interface</span>&#123;&#125;,mark *Element)*Element</span><br><span class="line">	PushFront(data  <span class="keyword">interface</span>&#123;&#125;)*Element</span><br><span class="line">	PushBack(data  <span class="keyword">interface</span>&#123;&#125;)*Element</span><br><span class="line">	InsertBefore(data  <span class="keyword">interface</span>&#123;&#125;,mark *Element)*Element</span><br><span class="line">	InsertAfter(data  <span class="keyword">interface</span>&#123;&#125;,mark *Element)*Element</span><br><span class="line">	MoveBrfore(e,mark *Element)</span><br><span class="line">	MoveAfter(e,mark *Element)</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span>&#123;</span><br><span class="line">	prev,next *Element <span class="comment">//前一个指针，后一个指针</span></span><br><span class="line">	value  <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//数据</span></span><br><span class="line">	list * List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span>&#123;</span><br><span class="line">	root Element  <span class="comment">//根元素，长度</span></span><br><span class="line">	<span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">New</span><span class="params">()</span> *<span class="title">List</span></span>&#123;</span><br><span class="line">	list:=<span class="built_in">new</span>(List)</span><br><span class="line">	list.Clear() <span class="comment">//清空</span></span><br><span class="line">	<span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> firstelem:=list.root.next;firstelem!=<span class="literal">nil</span> &amp;&amp; firstelem.list==list&#123;</span><br><span class="line">		firstelem.prev=<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lastelem:=list.root.prev;lastelem!=<span class="literal">nil</span> &amp;&amp; lastelem.list==list&#123;</span><br><span class="line">		lastelem.prev=<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	list.root.next=&amp;list.root</span><br><span class="line">	list.root.prev=&amp;list.root</span><br><span class="line">	list.<span class="built_in">len</span>=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Len</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> list.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  list.<span class="built_in">len</span>==<span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.root.next<span class="comment">//第一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Back</span><span class="params">()</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>  list.<span class="built_in">len</span>==<span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.root.prev<span class="comment">//最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Insert</span><span class="params">(e,mark *Element)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	nbak :=mark.next  <span class="comment">//备份</span></span><br><span class="line">	mark.next =e</span><br><span class="line">	e.prev=mark</span><br><span class="line">	e.next=nbak</span><br><span class="line">	nbak.prev=e</span><br><span class="line">	e.list=list <span class="comment">//保存链表的都指针</span></span><br><span class="line">	list.<span class="built_in">len</span>++ <span class="comment">//长度+1</span></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">InsertValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;,mark *Element)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> list.Insert(&amp;Element&#123;value:v&#125;,mark) <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">PushFront</span><span class="params">(data  <span class="keyword">interface</span>&#123;&#125;)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> list.InsertValue(data,&amp;list.root) <span class="comment">//前面插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">PushBack</span><span class="params">(data  <span class="keyword">interface</span>&#123;&#125;)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> list.InsertValue(data,list.root.prev) <span class="comment">//后面插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">Remove</span><span class="params">(e* Element)</span>* <span class="title">Element</span></span>&#123;</span><br><span class="line">	e.prev.next=e.next</span><br><span class="line">	e.next.prev=e.prev</span><br><span class="line">	e.next=<span class="literal">nil</span></span><br><span class="line">	e.prev=<span class="literal">nil</span></span><br><span class="line">	e.list=<span class="literal">nil</span></span><br><span class="line">	list.<span class="built_in">len</span>--</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除指定数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">Removedata</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line">	<span class="keyword">for</span> phead:=list.root.next;phead!=&amp;list.root;phead=phead.next&#123;</span><br><span class="line">		<span class="keyword">if</span> phead.value==data&#123;</span><br><span class="line">			list.Remove(phead)  <span class="comment">//查找并删除</span></span><br><span class="line">			<span class="keyword">return</span> phead.value</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"链表开始"</span>)</span><br><span class="line">	<span class="keyword">for</span> phead:=list.root.next;phead!=&amp;list.root;phead=phead.next&#123;</span><br><span class="line">		fmt.Println(phead.value)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"链表结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">InsertBefore</span><span class="params">(data  <span class="keyword">interface</span>&#123;&#125;,mark *Element)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> mark.list!=list&#123;  <span class="comment">//没有前置</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.InsertValue(data,mark.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">InsertAfter</span><span class="params">(data  <span class="keyword">interface</span>&#123;&#125;,mark *Element)</span>*<span class="title">Element</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> mark.list!=list&#123;  <span class="comment">//没有前置</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.InsertValue(data,mark)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">MoveBrfore</span><span class="params">(e,mark *Element)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> e.list!=list || list.root.next==e&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.Insert(list.Remove(e),mark.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span><span class="title">ReMoveAfter</span><span class="params">(e,mark *Element)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> e.list!=list || list.root.prev==e&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	list.Insert(list.Remove(e),&amp;list.root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span> <span class="title">Setdata</span><span class="params">(old,<span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> phead:=list.root.next;phead!=&amp;list.root;phead=phead.next&#123;</span><br><span class="line">		<span class="keyword">if</span> phead.value==old&#123;</span><br><span class="line">			phead.value=<span class="built_in">new</span>  <span class="comment">//更新</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//fmt.Println(phead.value)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mylist:=New()</span><br><span class="line">	mylist.PushFront(<span class="number">1</span>)</span><br><span class="line">	mylist.PushFront(<span class="number">2</span>)</span><br><span class="line">	mylist.PushFront(<span class="number">3</span>)</span><br><span class="line">	mylist.PushFront(<span class="number">4</span>)</span><br><span class="line">	mylist.PushBack(<span class="number">5</span>)</span><br><span class="line">	mylist.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h1><h2 id="4-1-链式队列"><a href="#4-1-链式队列" class="headerlink" title="4.1 链式队列"></a>4.1 链式队列</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表单节点</span></span><br><span class="line"><span class="keyword">type</span>  QNode <span class="keyword">struct</span>&#123;</span><br><span class="line">	data  <span class="keyword">interface</span>&#123;&#125; <span class="comment">//数据</span></span><br><span class="line">	next * QNode <span class="comment">//地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueLink <span class="keyword">struct</span>&#123;  <span class="comment">//队列的头部，尾部</span></span><br><span class="line">	rear *QNode</span><br><span class="line">	front *QNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  SQueue <span class="keyword">interface</span> &#123;</span><br><span class="line">	length() <span class="keyword">int</span></span><br><span class="line">	Enqueue(value  <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Dequeue()(  <span class="keyword">interface</span>&#123;&#125;,error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinkQueue</span><span class="params">()</span> * <span class="title">QueueLink</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;QueueLink&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qlk *QueueLink)</span><span class="title">length</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	length := <span class="number">0</span></span><br><span class="line">	pnode := qlk.front <span class="comment">//备份</span></span><br><span class="line">	<span class="keyword">for</span> pnode != qlk.rear&#123; <span class="comment">//一直到循环到重合为zhi</span></span><br><span class="line">		pnode = pnode.next  <span class="comment">//循环链表尾部</span></span><br><span class="line">		length++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">( qlk *QueueLink)</span> <span class="title">Enqueue</span><span class="params">(value  <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	newnode :=&amp;QNode&#123;data:value&#125; <span class="comment">//构造一个节点，返回地址</span></span><br><span class="line">	<span class="keyword">if</span> qlk.front == <span class="literal">nil</span>&#123;  <span class="comment">//只有一个节点</span></span><br><span class="line">		qlk.front = newnode</span><br><span class="line">		qlk.rear = newnode</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		qlk.rear.next = newnode</span><br><span class="line">		qlk.rear = qlk.rear.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qlk *QueueLink )</span> <span class="title">Dequeue</span><span class="params">()</span><span class="params">( value <span class="keyword">interface</span>&#123;&#125;,err error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> qlk.front == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	newnode := qlk.front</span><br><span class="line">	<span class="keyword">if</span> qlk.front == qlk.rear&#123;</span><br><span class="line">		qlk.front = <span class="literal">nil</span></span><br><span class="line">		qlk.rear = <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		qlk.front = qlk.front.next <span class="comment">//删除一个元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newnode.data,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myq := NewLinkQueue()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		myq.Enqueue(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"length"</span>,myq.length())</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		fmt.Println(myq.Dequeue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-数组队列"><a href="#4-2-数组队列" class="headerlink" title="4.2 数组队列"></a>4.2 数组队列</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QueueInter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Size()<span class="keyword">int</span>   		<span class="comment">//大小</span></span><br><span class="line">	Front()<span class="keyword">interface</span>&#123;&#125; 	<span class="comment">//第一个元素</span></span><br><span class="line">	End()<span class="keyword">interface</span>&#123;&#125; 	<span class="comment">//最后一个元素</span></span><br><span class="line">	IsEmpty() <span class="keyword">bool</span> 		<span class="comment">//是否为空</span></span><br><span class="line">	Enqueue(data <span class="keyword">interface</span>&#123;&#125;) 	<span class="comment">//入队</span></span><br><span class="line">	Dequeue() <span class="keyword">interface</span>&#123;&#125; 		<span class="comment">//出对</span></span><br><span class="line">	Clear()				<span class="comment">//清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  Queue <span class="keyword">struct</span>&#123;</span><br><span class="line">	datastore []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	theSize <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	myqueue.datastore = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>)  <span class="comment">//开辟内存</span></span><br><span class="line">	myqueue.theSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span> *<span class="title">Queue</span></span>&#123;</span><br><span class="line">	myqueue := <span class="built_in">new</span>(Queue)</span><br><span class="line">	myqueue.Clear()</span><br><span class="line">	<span class="keyword">return</span> myqueue</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">Size</span><span class="params">()</span><span class="title">int</span></span>   &#123;</span><br><span class="line">	<span class="keyword">return</span>  myqueue.theSize <span class="comment">//大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">Front</span><span class="params">()</span><span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> myqueue.Size() == <span class="number">0</span>&#123; <span class="comment">//判断是否为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> myqueue.datastore[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">End</span><span class="params">()</span><span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> myqueue.Size() == <span class="number">0</span>&#123; <span class="comment">//判断是否为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> myqueue.datastore[myqueue.theSize<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  myqueue.theSize == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">Enqueue</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	myqueue.datastore = <span class="built_in">append</span>( myqueue.datastore,data) <span class="comment">//入队</span></span><br><span class="line">	myqueue.theSize++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(myqueue *Queue)</span> <span class="title">Dequeue</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> myqueue.Size() == <span class="number">0</span>&#123; <span class="comment">//判断是否为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	data := myqueue.datastore[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span>  myqueue.Size()&gt;<span class="number">1</span> &#123;</span><br><span class="line">		myqueue.datastore = myqueue.datastore[<span class="number">1</span>:myqueue.theSize] <span class="comment">//截取</span></span><br><span class="line">	&#125;</span><br><span class="line">	myqueue.theSize--</span><br><span class="line">	<span class="keyword">return</span>  data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	myq := NewQueue()</span><br><span class="line">	myq.Enqueue(<span class="number">1</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">2</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">3</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(myq.Size())</span><br><span class="line">	fmt.Println(myq.Dequeue())</span><br><span class="line">	fmt.Println(myq.Dequeue())</span><br><span class="line">	fmt.Println(myq.Dequeue())</span><br><span class="line">	fmt.Println(myq.Dequeue())</span><br><span class="line">	fmt.Println(myq.Size())</span><br><span class="line">	myq.Enqueue(<span class="number">1</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">2</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">3</span>)</span><br><span class="line">	myq.Enqueue(<span class="number">4</span>)</span><br><span class="line">	myq.Clear()</span><br><span class="line">	fmt.Println(myq.Size())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-优先队列"><a href="#4-3-优先队列" class="headerlink" title="4.3 优先队列"></a>4.3 优先队列</h2><p>基于二叉堆</p>
<h1 id="5-栈"><a href="#5-栈" class="headerlink" title="5.栈"></a>5.栈</h1><h2 id="5-1-数组栈"><a href="#5-1-数组栈" class="headerlink" title="5.1 数组栈"></a>5.1 数组栈</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StackArray <span class="keyword">interface</span>&#123;</span><br><span class="line">	Clear()</span><br><span class="line">	Size()<span class="keyword">int</span></span><br><span class="line">	Pop() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Push(data <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	isEmpty() <span class="keyword">bool</span></span><br><span class="line">	isFull() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ArrayList <span class="keyword">struct</span>&#123;</span><br><span class="line">	dataStore [] <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	theSize <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">ArrayList</span></span>&#123;</span><br><span class="line">	list := <span class="built_in">new</span>(ArrayList)</span><br><span class="line">	list.dataStore = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>,<span class="number">10</span>) <span class="comment">//分配内存10个数组元素</span></span><br><span class="line"></span><br><span class="line">	list.theSize = <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line">	<span class="comment">//fmt.Println("new",list.theSize,cap(list.dataStore))</span></span><br><span class="line">	<span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(list *ArrayList)</span> <span class="title">Append</span> <span class="params">(newval  <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="comment">//list.checkmemisfull()</span></span><br><span class="line">	list.dataStore=<span class="built_in">append</span>(list.dataStore,newval) <span class="comment">//数据叠加</span></span><br><span class="line">	<span class="comment">//fmt.Println(list.theSize,cap(list.dataStore))</span></span><br><span class="line">	<span class="comment">//list.dataStore[list.theSize]=newval  //赋值</span></span><br><span class="line">	list.theSize++ <span class="comment">//索引移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span><span class="title">Remove</span><span class="params">(index <span class="keyword">int</span>)</span><span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= list.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"索引越界"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.dataStore = <span class="built_in">append</span>(list.dataStore[:index],list.dataStore[index+<span class="number">1</span>:]...) <span class="comment">//删除</span></span><br><span class="line">	list.theSize--</span><br><span class="line">	<span class="keyword">return</span>  <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span><span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list.dataStore = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>,<span class="number">10</span>) <span class="comment">//清空</span></span><br><span class="line">	list.theSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  Stack <span class="keyword">struct</span>&#123;</span><br><span class="line">	myarray *ArrayList</span><br><span class="line">	capsize <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span>*<span class="title">Stack</span></span>&#123;</span><br><span class="line">	mystack := <span class="built_in">new</span>(Stack)</span><br><span class="line">	mystack.myarray = New()</span><br><span class="line">	mystack.capsize = <span class="number">10</span>  <span class="comment">//0</span></span><br><span class="line">	<span class="keyword">return</span> mystack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mystack.myarray.Clear()</span><br><span class="line">	mystack.myarray.theSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">Size</span><span class="params">()</span><span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mystack.myarray.theSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> mystack.myarray.theSize == <span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">isFull</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> mystack.capsize == mystack.myarray.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line">	<span class="keyword">if</span> !mystack.isEmpty()&#123;</span><br><span class="line">		last := mystack.myarray.dataStore[mystack.myarray.theSize<span class="number">-1</span>]</span><br><span class="line">		mystack.myarray.Remove(mystack.myarray.theSize<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> last</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mystack *Stack)</span> <span class="title">Push</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> !mystack.isFull()&#123;</span><br><span class="line">		mystack.myarray.Append(data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mystack :=NewStack()</span><br><span class="line">	mystack.Push(<span class="number">1</span>)</span><br><span class="line">	mystack.Push(<span class="number">2</span>)</span><br><span class="line">	mystack.Push(<span class="number">3</span>)</span><br><span class="line">	mystack.Push(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(mystack.Pop())</span><br><span class="line">	fmt.Println(mystack.Pop())</span><br><span class="line">	fmt.Println(mystack.Pop())</span><br><span class="line">	fmt.Println(mystack.Pop())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-链式栈"><a href="#5-2-链式栈" class="headerlink" title="5.2 链式栈"></a>5.2 链式栈</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span>&#123;</span><br><span class="line">	data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkStack <span class="keyword">interface</span> &#123;</span><br><span class="line">	IsEmpty() <span class="keyword">bool</span></span><br><span class="line">	Push(value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Pop()(<span class="keyword">interface</span>&#123;&#125;,error)</span><br><span class="line">	Length() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span><span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;  <span class="comment">//判断是否为空</span></span><br><span class="line">	<span class="keyword">return</span> n.next == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span><span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	newnode := &amp;Node&#123;data:value&#125; <span class="comment">//初始化</span></span><br><span class="line">	newnode.next = n.next</span><br><span class="line">	n.next = newnode</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span><span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.IsEmpty() == <span class="literal">true</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="literal">nil</span>,errors.New(<span class="string">"bug"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	value := n.next.data</span><br><span class="line">	n.next = n.next.next</span><br><span class="line">	<span class="keyword">return</span> value,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span><span class="title">Length</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	pnext := n</span><br><span class="line">	length := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> pnext.next != <span class="literal">nil</span>&#123;<span class="comment">//返回长度</span></span><br><span class="line">		pnext = pnext.next</span><br><span class="line">		length++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mystack := NewStack()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span>;i++&#123;</span><br><span class="line">		mystack.Push(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> data,err := mystack.Pop();err == <span class="literal">nil</span>;data,err = mystack.Pop()&#123;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-堆"><a href="#6-堆" class="headerlink" title="6.堆"></a>6.堆</h1><h2 id="6-1-二叉堆"><a href="#6-1-二叉堆" class="headerlink" title="6.1 二叉堆"></a>6.1 二叉堆</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IBinaryHeap <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(data <span class="keyword">int</span>)</span><br><span class="line">	AddSlice(data []<span class="keyword">int</span>)</span><br><span class="line">	Length() <span class="keyword">int</span></span><br><span class="line">	BuildMax(dataLen <span class="keyword">int</span>)</span><br><span class="line">	BuildMin(dataLen <span class="keyword">int</span>)</span><br><span class="line">	SortAsc()</span><br><span class="line">	SortDesc()</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">Add</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.Length() == <span class="number">0</span> &#123;</span><br><span class="line">		b.data = <span class="built_in">append</span>(b.data, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	b.data = <span class="built_in">append</span>(b.data, data)</span><br><span class="line">	b.data[<span class="number">0</span>]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">AddSlice</span><span class="params">(data []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> data &#123;</span><br><span class="line">		b.Add(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">Length</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(b.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BuildMax : 构建大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">BuildMax</span><span class="params">(dataLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 循环所有的父节点(从后向前循环)</span></span><br><span class="line">	<span class="keyword">for</span> i := (dataLen - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 找出最大的儿子节点</span></span><br><span class="line">		<span class="keyword">var</span> maxIndex = i * <span class="number">2</span> <span class="comment">// 假设最大的就是左儿子(因为是父节点,必定存在左儿子)</span></span><br><span class="line">		<span class="comment">// 如果有右儿子, 并且右儿子更大,则记录</span></span><br><span class="line">		<span class="keyword">if</span> (maxIndex+<span class="number">1</span>) &lt; dataLen &amp;&amp; b.data[maxIndex+<span class="number">1</span>] &gt; b.data[maxIndex] &#123;</span><br><span class="line">			maxIndex = i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 与父节点比较, 如果更大就交换</span></span><br><span class="line">		<span class="keyword">for</span> b.data[maxIndex] &gt; b.data[i] &#123;</span><br><span class="line">			b.data[maxIndex], b.data[i] = b.data[i], b.data[maxIndex]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BuildMin : 构建小根堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">BuildMin</span><span class="params">(dataLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 循环所有的父节点(从后向前循环)</span></span><br><span class="line">	<span class="keyword">for</span> i := (dataLen - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 找出最大的儿子节点</span></span><br><span class="line">		<span class="keyword">var</span> minIndex = i * <span class="number">2</span> <span class="comment">// 假设最大的就是左儿子(因为是父节点,必定存在左儿子)</span></span><br><span class="line">		<span class="comment">// 如果有右儿子, 并且右儿子更大,则记录</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex+<span class="number">1</span>) &lt; dataLen &amp;&amp; b.data[minIndex+<span class="number">1</span>] &lt; b.data[minIndex] &#123;</span><br><span class="line">			minIndex++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 与父节点比较, 如果更小就交换</span></span><br><span class="line">		<span class="keyword">for</span> b.data[minIndex] &lt; b.data[i] &#123;</span><br><span class="line">			b.data[minIndex], b.data[i] = b.data[i], b.data[minIndex]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortRise : 对堆做升序排列</span></span><br><span class="line"><span class="comment">// 1. 组合大顶堆</span></span><br><span class="line"><span class="comment">// 2. 根节点与最后一个叶子节点互换</span></span><br><span class="line"><span class="comment">// 3. 在除最后一个叶子节点的堆中继续执行1和2步骤, 到堆中剩余1个节点为止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">SortAsc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dataLen = <span class="built_in">len</span>(b.data)</span><br><span class="line">	<span class="keyword">for</span> dataLen &gt; <span class="number">2</span> &#123;</span><br><span class="line">		b.BuildMax(dataLen)</span><br><span class="line"></span><br><span class="line">		b.data[<span class="number">1</span>], b.data[dataLen<span class="number">-1</span>] = b.data[dataLen<span class="number">-1</span>], b.data[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">		dataLen--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortRise : 对堆做降序排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">SortDesc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dataLen = <span class="built_in">len</span>(b.data)</span><br><span class="line">	<span class="keyword">for</span> dataLen &gt; <span class="number">2</span> &#123;</span><br><span class="line">		b.BuildMin(dataLen)</span><br><span class="line"></span><br><span class="line">		b.data[<span class="number">1</span>], b.data[dataLen<span class="number">-1</span>] = b.data[dataLen<span class="number">-1</span>], b.data[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">		dataLen--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BinaryHeap)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, item := <span class="keyword">range</span> b.data &#123;</span><br><span class="line">		<span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%v,"</span>, item)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data = &amp;BinaryHeap&#123;data: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">8</span>, <span class="number">12</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	data.Show()</span><br><span class="line">	data.Add(<span class="number">88</span>)</span><br><span class="line">	data.AddSlice([]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">28</span>&#125;)</span><br><span class="line">	data.Show()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n----------max"</span>)</span><br><span class="line">	data.BuildMax(data.Length())</span><br><span class="line">	data.Show()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n----------min"</span>)</span><br><span class="line">	data.BuildMin(data.Length())</span><br><span class="line">	data.Show()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n----------asc"</span>)</span><br><span class="line">	data.SortAsc()</span><br><span class="line">	data.Show()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n----------desc"</span>)</span><br><span class="line">	data.SortDesc()</span><br><span class="line">	data.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-集合"><a href="#7-集合" class="headerlink" title="7.集合"></a>7.集合</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHashSet</span><span class="params">()</span> *<span class="title">HashSet</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HashSet&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Add</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> self.m[e] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	self.m[e] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Remove</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(self.m, e)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Clear</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	self.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Contains</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> self.m[e]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(self.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Same</span><span class="params">(other *HashSet)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> other == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> self.Len() != other.Len() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> other.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !self.Contains(k) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Elements</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// for k := range self.m&#123;</span></span><br><span class="line">	<span class="comment">//    snapshot = snapshot(snapshot, k)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	initialLen := self.Len()</span><br><span class="line">	actualLen := <span class="number">0</span></span><br><span class="line">	snapshot := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, initialLen)</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> self.m &#123;</span><br><span class="line">		<span class="keyword">if</span> actualLen &lt; initialLen &#123;</span><br><span class="line">			snapshot[actualLen] = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			snapshot = <span class="built_in">append</span>(snapshot, k)</span><br><span class="line">		&#125;</span><br><span class="line">		actualLen++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> actualLen &lt; initialLen &#123;</span><br><span class="line">		snapshot = snapshot[:actualLen]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> snapshot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteString(<span class="string">"Set&#123;"</span>)</span><br><span class="line">	flag := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> self.m &#123;</span><br><span class="line">		<span class="keyword">if</span> flag &#123;</span><br><span class="line">			flag = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">" "</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		buf.WriteString(fmt.Sprintf(<span class="string">"%v"</span>, k))</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteString(<span class="string">"&#125;"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">IsSuperSet</span><span class="params">(other *HashSet)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> other == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	selfLen := self.Len()</span><br><span class="line">	otherLen := other.Len()</span><br><span class="line">	<span class="keyword">if</span> otherLen == <span class="number">0</span> || selfLen == otherLen &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> selfLen &gt; <span class="number">0</span> &amp;&amp; otherLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> other.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !self.Contains(v) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于A或属于B的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Union</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</span><br><span class="line">	<span class="comment">// if other == nil || other.Len() == 0&#123;</span></span><br><span class="line">	<span class="comment">//    return self</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// for v := range other.m&#123;</span></span><br><span class="line">	<span class="comment">//    self.Add(v)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// return self</span></span><br><span class="line">	<span class="comment">//不能改变集合A的范围</span></span><br><span class="line">	union := NewHashSet()</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> self.m &#123;</span><br><span class="line">		union.Add(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> other.m &#123;</span><br><span class="line">		union.Add(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> union</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于A且属于B的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Intersect</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> other == <span class="literal">nil</span> || other.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> NewHashSet()</span><br><span class="line">	&#125;</span><br><span class="line">	intsSet := NewHashSet()</span><br><span class="line">	<span class="keyword">for</span> v, _ := <span class="keyword">range</span> other.m &#123;</span><br><span class="line">		<span class="keyword">if</span> self.Contains(v) &#123;</span><br><span class="line">			intsSet.Add(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intsSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属于A且不属于B的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">Difference</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</span><br><span class="line">	diffSet := NewHashSet()</span><br><span class="line">	<span class="keyword">if</span> other == <span class="literal">nil</span> || other.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		diffSet.Union(self)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> self.m &#123;</span><br><span class="line">			<span class="keyword">if</span> !other.Contains(v) &#123;</span><br><span class="line">				diffSet.Add(v)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> diffSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合A与集合B中所有不属于A∩B的元素的集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *HashSet)</span> <span class="title">SymmetricDifference</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</span><br><span class="line">	<span class="comment">//此时A∩B=∅，A中所有元素均不属于空集</span></span><br><span class="line">	<span class="comment">// if other == nil || other.Len() == 0&#123;</span></span><br><span class="line">	<span class="comment">//    return self</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// ints := self.Intersect(other)</span></span><br><span class="line">	<span class="comment">// //此时A∩B=∅，A为空或B为空,B为空前面已经判断，此时B不能为空，即A为空</span></span><br><span class="line">	<span class="comment">// if ints == nil || ints.Len() == 0 &#123;</span></span><br><span class="line">	<span class="comment">//    return other</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// unionSet := self.Union(other)</span></span><br><span class="line">	<span class="comment">// result := NewHashSet()</span></span><br><span class="line">	<span class="comment">// for v := range unionSet.m&#123;</span></span><br><span class="line">	<span class="comment">//    if !ints.Contains(v)&#123;</span></span><br><span class="line">	<span class="comment">//       result.Add(v)</span></span><br><span class="line">	<span class="comment">//    &#125;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	ints := self.Difference(other)</span><br><span class="line">	union := self.Union(other)</span><br><span class="line">	<span class="keyword">return</span> union.Difference(ints)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	set1 := NewHashSet()</span><br><span class="line">	set1.Add(<span class="number">1</span>)</span><br><span class="line">	set1.Add(<span class="string">"e2"</span>)</span><br><span class="line">	set1.Add(<span class="number">3</span>)</span><br><span class="line">	set1.Add(<span class="string">"e4"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"set1:"</span>, set1)</span><br><span class="line">	fmt.Printf(<span class="string">"set1 Elements:%v\n"</span>, set1.Elements())</span><br><span class="line"></span><br><span class="line">	set2 := NewHashSet()</span><br><span class="line">	set2.Add(<span class="number">3</span>)</span><br><span class="line">	set2.Add(<span class="string">"e2"</span>)</span><br><span class="line">	set2.Add(<span class="number">5</span>)</span><br><span class="line">	set2.Add(<span class="string">"e6"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"set2:"</span>, set1)</span><br><span class="line">	fmt.Printf(<span class="string">"set1 union set2:%v\n"</span>, set1.Union(set2))</span><br><span class="line">	fmt.Printf(<span class="string">"set1 intersect set2:%v\n"</span>, set1.Intersect(set2))</span><br><span class="line">	fmt.Println(set1, set2)</span><br><span class="line">	fmt.Printf(<span class="string">"set1 difference set2:%v\n"</span>, set1.Difference(set2))</span><br><span class="line">	fmt.Printf(<span class="string">"set1 SymmetricDifference set2:%v\n"</span>, set1.SymmetricDifference(set2))</span><br><span class="line">	set1.Clear()</span><br><span class="line">	fmt.Println(set1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ListLength  =<span class="number">10</span>  <span class="comment">//定义列表全局长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface  实例化int，int., string ,string</span></span><br><span class="line"><span class="keyword">type</span>  List <span class="keyword">interface</span> &#123;</span><br><span class="line">	Size() <span class="keyword">int</span>  <span class="comment">//函数大小，返回大小</span></span><br><span class="line">	Get(index <span class="keyword">int</span>)(<span class="keyword">interface</span>&#123;&#125;,error) <span class="comment">//根据索引抓取数据</span></span><br><span class="line">	Set(index <span class="keyword">int</span>,newval <span class="keyword">interface</span>&#123;&#125;)error <span class="comment">//设置</span></span><br><span class="line">	Insert(index <span class="keyword">int</span>,newval <span class="keyword">interface</span>&#123;&#125;)error <span class="comment">//插入</span></span><br><span class="line">	Append(newval <span class="keyword">interface</span>&#123;&#125;) error<span class="comment">//追加</span></span><br><span class="line">	Remove(index <span class="keyword">int</span>)error   <span class="comment">//删除</span></span><br><span class="line">	Clear() <span class="comment">//清空</span></span><br><span class="line">	String() <span class="keyword">string</span> <span class="comment">//返回字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> ArrayList <span class="keyword">struct</span>&#123;</span><br><span class="line">	dataStore []  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	theSize  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建新的链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">New</span><span class="params">()</span> *<span class="title">ArrayList</span></span>&#123;</span><br><span class="line">	list:=<span class="built_in">new</span>(ArrayList)</span><br><span class="line">	list.dataStore = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>,ListLength) <span class="comment">//分配内存10个数组元素</span></span><br><span class="line"></span><br><span class="line">	list.theSize=<span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line">	<span class="comment">//fmt.Println("new",list.theSize,cap(list.dataStore))</span></span><br><span class="line">	<span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> list.theSize  <span class="comment">//返回大小</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(list *ArrayList)</span>  <span class="title">Append</span> <span class="params">(newval  <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	list.dataStore=<span class="built_in">append</span>(list.dataStore,newval) <span class="comment">//数据叠加</span></span><br><span class="line">	list.theSize++ <span class="comment">//索引移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取索引所在数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span>  <span class="title">Get</span><span class="params">(index <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt;<span class="number">0</span> || index &gt;=list.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"索引越界"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.dataStore[index],<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引更改数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList)</span>  <span class="title">Set</span><span class="params">(index <span class="keyword">int</span>,newval <span class="keyword">interface</span>&#123;&#125;)</span><span class="params">(error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt;<span class="number">0</span> || index &gt;=list.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"索引越界"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	list.dataStore[index]=newval <span class="comment">//赋值新的值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查切片是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span> <span class="title">checkmemisfull</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> list.Size()==<span class="built_in">cap</span>(list.dataStore)&#123;</span><br><span class="line">		newDataStore:=<span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>,<span class="number">2</span>*list.Size())<span class="comment">//开辟更大内存</span></span><br><span class="line">		<span class="built_in">copy</span>(newDataStore,list.dataStore) <span class="comment">//拷贝</span></span><br><span class="line">		list.dataStore=newDataStore <span class="comment">//赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span><span class="title">Insert</span><span class="params">(index <span class="keyword">int</span>,newval <span class="keyword">interface</span>&#123;&#125;)</span><span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt;<span class="number">0</span> || index &gt;=list.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"索引越界"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	list.checkmemisfull()</span><br><span class="line">	list.dataStore=list.dataStore[:list.Size()+<span class="number">1</span>]<span class="comment">//开辟内存,延展使用的内存</span></span><br><span class="line">	<span class="keyword">for</span> i:=list.Size();i&gt;index;i--&#123;</span><br><span class="line">		list.dataStore[i]=list.dataStore[i<span class="number">-1</span>] <span class="comment">//从后往前赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	list.dataStore[index]=newval  <span class="comment">//插入数据</span></span><br><span class="line">	list.theSize++ <span class="comment">//索引加1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据索引移出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span><span class="title">Remove</span><span class="params">(index <span class="keyword">int</span>)</span><span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> index &lt;<span class="number">0</span> || index &gt;=list.theSize&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"索引越界"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.dataStore=<span class="built_in">append</span>(list.dataStore[:index],list.dataStore[index+<span class="number">1</span>:]...) <span class="comment">//删除</span></span><br><span class="line">	list.theSize--</span><br><span class="line">	<span class="keyword">return</span>  <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span><span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list.dataStore=<span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,<span class="number">0</span>,<span class="number">10</span>) <span class="comment">//清空</span></span><br><span class="line">	list.theSize=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *ArrayList )</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span>  fmt.Sprint(list.dataStore)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	list :=New()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">		list.Append(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"列表长度：%d\n输出列表\n%d\n"</span>,list.theSize,list.dataStore)</span><br><span class="line"></span><br><span class="line">	list.Remove(<span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="string">"输出列表"</span>)</span><br><span class="line">	fmt.Println(list.dataStore)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	list.Insert(<span class="number">3</span>,<span class="number">100</span>)</span><br><span class="line">	fmt.Println(<span class="string">"输出列表"</span>)</span><br><span class="line">	fmt.Println(list.dataStore)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"输出列表"</span>)</span><br><span class="line">	fmt.Println(list.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	HasNext() <span class="keyword">bool</span><span class="comment">//判断是否有下一个</span></span><br><span class="line">	Next()(<span class="keyword">interface</span>&#123;&#125;,error) <span class="comment">//获取下一个</span></span><br><span class="line">	Remove()<span class="comment">//删除</span></span><br><span class="line">	getindex()<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Iterable <span class="keyword">interface</span> &#123;</span><br><span class="line">	Iterator () Iterator <span class="comment">//构造迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ArrayListIterator <span class="keyword">struct</span>&#123;</span><br><span class="line">	list * ArrayList  <span class="comment">//数组指针</span></span><br><span class="line">	currentindex  <span class="keyword">int</span> <span class="comment">//当前的索引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list * ArrayList )</span> <span class="title">Iterator</span><span class="params">()</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">	iterator:=<span class="built_in">new</span>(ArrayListIterator) <span class="comment">//创造迭代器</span></span><br><span class="line">	iterator.currentindex=<span class="number">0</span></span><br><span class="line">	iterator.list=list <span class="comment">//指针传递</span></span><br><span class="line">	<span class="keyword">return</span> iterator  <span class="comment">//返回迭代器，驾驭数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(it *ArrayListIterator)</span><span class="title">getindex</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> it.currentindex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(it *ArrayListIterator)</span><span class="title">HasNext</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> it.currentindex &lt;it.list.Size()  <span class="comment">//存在下一个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(it *ArrayListIterator)</span><span class="title">Next</span><span class="params">()</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> !it.HasNext()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"没有数据"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	value,err:=it.list.Get(it.currentindex)<span class="comment">//提取上一个</span></span><br><span class="line">	it.currentindex++</span><br><span class="line">	<span class="keyword">return</span> value,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(it *ArrayListIterator)</span>	<span class="title">Remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">	it.currentindex--</span><br><span class="line">	it.list.Remove(it.currentindex) <span class="comment">//删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list :=New()</span><br><span class="line">	list.Append(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">	list.Append(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">	list.Append(<span class="number">3</span>)</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">	list.Append(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">	<span class="keyword">for</span> it:=list.Iterator();it.HasNext();&#123;</span><br><span class="line">		item,_:=it.Next()</span><br><span class="line">		<span class="keyword">if</span> item==<span class="number">3</span>&#123;</span><br><span class="line">			it.Remove()</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(item)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-哈希表"><a href="#9-哈希表" class="headerlink" title="9.哈希表"></a>9.哈希表</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表, key, v 组成</span></span><br><span class="line"><span class="keyword">type</span> Key <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个hash表</span></span><br><span class="line"><span class="keyword">type</span> HashTable <span class="keyword">struct</span> &#123;</span><br><span class="line">	Items <span class="keyword">map</span>[<span class="keyword">int</span>] Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给hash表中添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTable)</span> <span class="title">Put</span><span class="params">(key Key, value Value)</span></span>  &#123;</span><br><span class="line">	index := customeHash(key)</span><br><span class="line">	<span class="keyword">if</span> ht.Items == <span class="literal">nil</span>&#123;</span><br><span class="line">		ht.Items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]Value)</span><br><span class="line">	&#125;</span><br><span class="line">	ht.Items[index] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customeHash</span><span class="params">(k Key)</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 自定义hash算法</span></span><br><span class="line">	key := fmt.Sprintf(<span class="string">"%s"</span>, k)</span><br><span class="line">	h := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(key); i++&#123;</span><br><span class="line">		h = <span class="number">31</span> * h + <span class="keyword">int</span>(key[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTable)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="title">Value</span></span>  &#123;</span><br><span class="line">	index := customeHash(key)</span><br><span class="line">	<span class="keyword">return</span> ht.Items[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTable)</span> <span class="title">Remove</span><span class="params">(key Key)</span></span>  &#123;</span><br><span class="line">	index := customeHash(key)</span><br><span class="line">	<span class="built_in">delete</span>(ht.Items, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTable)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ht.Items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *HashTable)</span><span class="title">String</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// map遍历无序</span></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> ht.Items &#123;</span><br><span class="line">		fmt.Println(fmt.Sprintf(<span class="string">"k: %v\tv: %v"</span>,k,v))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">populateHashTable</span><span class="params">(count <span class="keyword">int</span>, start <span class="keyword">int</span>)</span> *<span class="title">HashTable</span></span> &#123;</span><br><span class="line">	dict := HashTable&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := start; i &lt; (start + count); i++ &#123;</span><br><span class="line">		dict.Put(fmt.Sprintf(<span class="string">"key%d"</span>, i), fmt.Sprintf(<span class="string">"value%d"</span>, i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;dict</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dict := populateHashTable(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">	size := dict.Size()</span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">"Test failed, expected 3 and got %d"</span>, size))</span><br><span class="line">	dict.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-树"><a href="#9-树" class="headerlink" title="9.树"></a>9.树</h1><h2 id="9-1-二叉树"><a href="#9-1-二叉树" class="headerlink" title="9.1 二叉树"></a>9.1 二叉树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data  <span class="keyword">interface</span>&#123;&#125;     <span class="comment">//数据</span></span><br><span class="line">	Left  *BinaryTreeNode <span class="comment">//左子树</span></span><br><span class="line">	Right *BinaryTreeNode <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTree</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">BinaryTreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BinaryTreeNode&#123;</span><br><span class="line">		Data: data,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">BinaryTreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BinaryTreeNode&#123;</span><br><span class="line">		Data: data,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">" %v"</span>, tree.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历:以当前节点为根节点，根——&gt;左——&gt;右</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">PreTraverseRecursion</span><span class="params">(<span class="built_in">print</span> <span class="keyword">bool</span>)</span> <span class="params">(treeString <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	treeString += tree.String()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Left.PreTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Right.PreTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">print</span> &#123;</span><br><span class="line">		fmt.Println(fmt.Sprintf(<span class="string">"前序遍历:[%v]"</span>, treeString))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历:以当前节点为根节点，左——&gt;根——&gt;右</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">MidTraverseRecursion</span><span class="params">(<span class="built_in">print</span> <span class="keyword">bool</span>)</span> <span class="params">(treeString <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Left.MidTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	treeString += tree.String()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Right.MidTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">print</span> &#123;</span><br><span class="line">		fmt.Println(fmt.Sprintf(<span class="string">"中序遍历:[%v]"</span>, treeString))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历：以当前节点为根节点，左——&gt;右——&gt;根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">PostTraverseRecursion</span><span class="params">(<span class="built_in">print</span> <span class="keyword">bool</span>)</span> <span class="params">(treeString <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Left.PostTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		treeString += tree.Right.PostTraverseRecursion(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	treeString += tree.String()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">print</span> &#123;</span><br><span class="line">		fmt.Println(fmt.Sprintf(<span class="string">"后序遍历:[%v]"</span>, treeString))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历(广度优先遍历)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">BreadthFirstSearch</span><span class="params">(<span class="built_in">print</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	nodes := []*BinaryTreeNode&#123;tree&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		curNode := nodes[<span class="number">0</span>]</span><br><span class="line">		nodes = nodes[<span class="number">1</span>:]</span><br><span class="line">		result = <span class="built_in">append</span>(result, curNode.Data)</span><br><span class="line">		<span class="keyword">if</span> curNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, curNode.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> curNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, curNode.Right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">print</span> &#123;</span><br><span class="line">		fmt.Print(fmt.Sprintf(<span class="string">"层次遍历:["</span>))</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> result &#123;</span><br><span class="line">			fmt.Print(<span class="string">" "</span>)</span><br><span class="line">			fmt.Print(v)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"]"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层数(递归实现)</span></span><br><span class="line"><span class="comment">//对任意一个子树的根节点来说，它的深度=左右子树深度的最大值+1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">Layers</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	leftLayers := tree.Left.Layers()</span><br><span class="line">	rightLayers := tree.Right.Layers()</span><br><span class="line">	<span class="keyword">if</span> leftLayers &gt; rightLayers &#123;</span><br><span class="line">		<span class="keyword">return</span> leftLayers + <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> rightLayers + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层数(非递归实现)</span></span><br><span class="line"><span class="comment">//借助队列，在进行按层遍历时，记录遍历的层数即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *BinaryTreeNode)</span> <span class="title">LayersByQueue</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	layers := <span class="number">0</span></span><br><span class="line">	nodes := []*BinaryTreeNode&#123;tree&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		layers++</span><br><span class="line">		size := <span class="built_in">len</span>(nodes) <span class="comment">//每层的节点数</span></span><br><span class="line">		count := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> count &lt; size &#123;</span><br><span class="line">			count++</span><br><span class="line">			curNode := nodes[<span class="number">0</span>]</span><br><span class="line">			nodes = nodes[<span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> curNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				nodes = <span class="built_in">append</span>(nodes, curNode.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> curNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				nodes = <span class="built_in">append</span>(nodes, curNode.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> layers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := NewTree(<span class="number">3</span>)</span><br><span class="line">	tree.Left = CreateNode(<span class="number">0</span>)</span><br><span class="line">	tree.Left.Right = CreateNode(<span class="number">2</span>)</span><br><span class="line">	tree.Right = CreateNode(<span class="number">5</span>)</span><br><span class="line">	tree.Right.Left = CreateNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前序</span></span><br><span class="line">	tree.PreTraverseRecursion(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 中序</span></span><br><span class="line">	tree.MidTraverseRecursion(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 后续</span></span><br><span class="line">	tree.PostTraverseRecursion(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	tree.BreadthFirstSearch(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"层数: "</span>, tree.Layers())</span><br><span class="line">	fmt.Println(<span class="string">"层数: "</span>, tree.LayersByQueue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-2-二分搜索树"><a href="#9-2-二分搜索树" class="headerlink" title="9.2 二分搜索树"></a>9.2 二分搜索树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	E <span class="keyword">int</span></span><br><span class="line">	Left *Node</span><br><span class="line">	Right *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约定在此样例代码中我们的二分搜索树中没有重复元素</span></span><br><span class="line"><span class="comment">// 如果想包涵重复元素的话，只需要以下定义：</span></span><br><span class="line"><span class="comment">// 左子树小于等于此节点，或右子树大于等于节点</span></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *Node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Tree)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Tree)</span> <span class="title">Root</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.root</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断二叉树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitNode</span><span class="params">(E <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Node&#123;</span><br><span class="line">		E:E,</span><br><span class="line">		Left:<span class="literal">nil</span>,</span><br><span class="line">		Right:<span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">AddE</span><span class="params">(e <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	this.root = this.add(this.root,e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以node为根的二分搜索树中插入元素E，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">add</span><span class="params">(node *Node,e <span class="keyword">int</span>)</span> *<span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="comment">// 不管是递归还是回溯，首先我们都应该先写出递归的结束条件是什么</span></span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		this.size++</span><br><span class="line">		<span class="keyword">return</span> InitNode(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e &gt; node.E &#123;</span><br><span class="line">		node.Right = this.add(node.Right, e)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e &lt; node.E &#123;</span><br><span class="line">		node.Left = this.add(node.Left, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找二分搜索中是否含有元素E</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span><span class="title">Contains</span><span class="params">(e <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.contains(this.root, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归的方式查找元素是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span><span class="title">contains</span> <span class="params">(node *Node, e <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e == node.E &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e &gt; node.E &#123;</span><br><span class="line">		<span class="keyword">return</span> this.contains(node.Right,e)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> this.contains(node.Left, e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历算法</span></span><br><span class="line"><span class="comment">// 1.前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Tree)</span><span class="title">PreOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PreOrder(this.root)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOrder</span><span class="params">(node *Node)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%d "</span>,node.E)</span><br><span class="line">	PreOrder(node.Left)</span><br><span class="line">	PreOrder(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">PreOrderNR</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stack := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">	stack = <span class="built_in">append</span>(stack, this.root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		curNode := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>,curNode.E)</span><br><span class="line">		<span class="keyword">if</span> curNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, curNode.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> curNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, curNode.Left)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Tree)</span><span class="title">MidOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MidOrder(this.root)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidOrder</span><span class="params">(node *Node)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	MidOrder(node.Left)</span><br><span class="line">	fmt.Printf(<span class="string">"%d "</span>,node.E)</span><br><span class="line">	MidOrder(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">BackOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	BackOrder(this.root)</span><br><span class="line">	<span class="built_in">println</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BackOrder</span><span class="params">(node *Node)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	BackOrder(node.Left)</span><br><span class="line">	BackOrder(node.Right)</span><br><span class="line">	fmt.Printf(<span class="string">"%d "</span>,node.E)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span><span class="title">LevelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue := <span class="built_in">make</span>([]*Node,<span class="number">0</span>)</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, this.root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		curNode := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>,curNode.E)</span><br><span class="line">		<span class="keyword">if</span> curNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue,curNode.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> curNode.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue,curNode.Right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二分搜索树中搜索最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">FindMin</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"二叉树为空，无法删除任何节点"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minimum(this.root).E</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimum</span><span class="params">(node *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minimum(node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二分搜索树中搜索最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">FindMax</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"二叉树为空，无法删除任何节点"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maximum(this.root).E</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximum</span><span class="params">(node *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从二分搜索树中删除最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">DelMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret <span class="keyword">int</span> = this.FindMin()</span><br><span class="line">	this.root = this.rmMin(this.root)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树的最小节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">rmMin</span><span class="params">(node *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">		nodeRight := node.Right</span><br><span class="line">		node.Right = <span class="literal">nil</span></span><br><span class="line">		this.size--</span><br><span class="line">		<span class="keyword">return</span> nodeRight</span><br><span class="line">	&#125;</span><br><span class="line">	node.Left = this.rmMin(node.Left)</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从二分搜索树种删除最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">DelMax</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret <span class="keyword">int</span> = this.FindMax()</span><br><span class="line">	this.root = this.rmMax(this.root)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树的最小节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">rmMax</span><span class="params">(node *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">		nodeLeft := node.Left</span><br><span class="line">		node.Left = <span class="literal">nil</span></span><br><span class="line">		this.size--</span><br><span class="line">		<span class="keyword">return</span> nodeLeft</span><br><span class="line">	&#125;</span><br><span class="line">	node.Right = this.rmMax(node.Right)</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在二分搜索树中删除值为e的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">Remove</span> <span class="params">(e <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	this.root = this.remove(this.root,e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">remove</span><span class="params">(node *Node,e <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e &gt; node.E &#123;</span><br><span class="line">		node.Right = this.remove(node.Right,e)</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e &lt; node.E &#123;</span><br><span class="line">		node.Left = this.remove(node.Left,e)</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果左子树为空的时候</span></span><br><span class="line">		<span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">			nodeRight := node.Right</span><br><span class="line">			node.Right = <span class="literal">nil</span></span><br><span class="line">			this.size--</span><br><span class="line">			<span class="keyword">return</span> nodeRight</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果右子树为空</span></span><br><span class="line">		<span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			nodeLeft := node.Left</span><br><span class="line">			node.Left = <span class="literal">nil</span></span><br><span class="line">			this.size--</span><br><span class="line">			<span class="keyword">return</span> nodeLeft</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果左右子树都不为空，那么我们需要找到node的后继</span></span><br><span class="line">		<span class="comment">// 就是所有比node值大的节点中值最小的那个，显然它在node的右子树中</span></span><br><span class="line">		nodeNext := minimum(node.Right)</span><br><span class="line">		nodeNext.Right = this.rmMin(node.Right)</span><br><span class="line">		nodeNext.Left = node.Left</span><br><span class="line">		node.Left = <span class="literal">nil</span></span><br><span class="line">		node.Right = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> nodeNext</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的打印方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		builder strings.Builder</span><br><span class="line">	)</span><br><span class="line">	generateBSTString(this.root,<span class="number">0</span>,&amp;builder)</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBSTString</span><span class="params">(node *Node,depth <span class="keyword">int</span>,builder *strings.Builder)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(builder,generateDepthString(depth) + <span class="string">"null"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintln(builder,generateDepthString(depth),node.E)</span><br><span class="line">	generateBSTString(node.Left,depth+<span class="number">1</span>,builder)</span><br><span class="line">	generateBSTString(node.Right,depth+<span class="number">1</span>,builder)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateDepthString</span><span class="params">(depth <span class="keyword">int</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> builder strings.Builder</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;depth;i++ &#123;</span><br><span class="line">		fmt.Fprintf(&amp;builder,<span class="string">"--"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	tree := Tree&#123;&#125;</span><br><span class="line">	tree.AddE(<span class="number">3</span>)</span><br><span class="line">	tree.Root().Left = InitNode(<span class="number">0</span>)</span><br><span class="line">	tree.Root().Left.Right = InitNode(<span class="number">2</span>)</span><br><span class="line">	tree.Root().Right = InitNode(<span class="number">5</span>)</span><br><span class="line">	tree.Root().Right.Left = InitNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(tree.String())</span><br><span class="line"></span><br><span class="line">	tree.PreOrder()</span><br><span class="line">	tree.MidOrder()</span><br><span class="line">	tree.BackOrder()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-红黑树"><a href="#9-3-红黑树" class="headerlink" title="9.3 红黑树"></a>9.3 红黑树</h2><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树。 红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015, Hu Keping . All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package rbtree implements operations on Red-Black tree.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Red-Black tree properties:  http://en.wikipedia.org/wiki/Rbtree</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1) A node is either red or black</span></span><br><span class="line"><span class="comment">//  2) The root is black</span></span><br><span class="line"><span class="comment">//  3) All leaves (NULL) are black</span></span><br><span class="line"><span class="comment">//  4) Both children of every red node are black</span></span><br><span class="line"><span class="comment">//  5) Every simple path from root to leaves contains the same number</span></span><br><span class="line"><span class="comment">//     of black nodes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Left   *Node</span><br><span class="line">	Right  *Node</span><br><span class="line">	Parent *Node</span><br><span class="line">	Color  <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// for use by client.</span></span><br><span class="line">	Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	RED   = <span class="number">0</span></span><br><span class="line">	BLACK = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">	Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rbtree represents a Red-Black tree.</span></span><br><span class="line"><span class="keyword">type</span> Rbtree <span class="keyword">struct</span> &#123;</span><br><span class="line">	NIL   *Node</span><br><span class="line">	root  *Node</span><br><span class="line">	count <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">less</span><span class="params">(x, y Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.Less(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an initialized Red-Black tree</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Rbtree</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(Rbtree).Init() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">Rbtree</span></span> &#123;</span><br><span class="line">	node := &amp;Node&#123;<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, BLACK, <span class="literal">nil</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Rbtree&#123;</span><br><span class="line">		NIL:   node,</span><br><span class="line">		root:  node,</span><br><span class="line">		count: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">leftRotate</span><span class="params">(x *Node)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Since we are doing the left rotation, the right child should *NOT* nil.</span></span><br><span class="line">	<span class="keyword">if</span> x.Right == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The illation of left rotation</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//          |                                  |</span></span><br><span class="line">	<span class="comment">//          X                                  Y</span></span><br><span class="line">	<span class="comment">//         / \         left rotate            / \</span></span><br><span class="line">	<span class="comment">//        α  Y       -------------&gt;         X   γ</span></span><br><span class="line">	<span class="comment">//           / \                            / \</span></span><br><span class="line">	<span class="comment">//          β  γ                         α  β</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It should be note that during the rotating we do not change</span></span><br><span class="line">	<span class="comment">// the Nodes' color.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	y := x.Right</span><br><span class="line">	x.Right = y.Left</span><br><span class="line">	<span class="keyword">if</span> y.Left != t.NIL &#123;</span><br><span class="line">		y.Left.Parent = x</span><br><span class="line">	&#125;</span><br><span class="line">	y.Parent = x.Parent</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> x.Parent == t.NIL &#123;</span><br><span class="line">		t.root = y</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == x.Parent.Left &#123;</span><br><span class="line">		x.Parent.Left = y</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x.Parent.Right = y</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	y.Left = x</span><br><span class="line">	x.Parent = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">rightRotate</span><span class="params">(x *Node)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Since we are doing the right rotation, the left child should *NOT* nil.</span></span><br><span class="line">	<span class="keyword">if</span> x.Left == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The illation of right rotation</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//          |                                  |</span></span><br><span class="line">	<span class="comment">//          X                                  Y</span></span><br><span class="line">	<span class="comment">//         / \         right rotate           / \</span></span><br><span class="line">	<span class="comment">//        Y   γ      -------------&gt;         α  X</span></span><br><span class="line">	<span class="comment">//       / \                                    / \</span></span><br><span class="line">	<span class="comment">//      α  β                                 β  γ</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It should be note that during the rotating we do not change</span></span><br><span class="line">	<span class="comment">// the Nodes' color.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	y := x.Left</span><br><span class="line">	x.Left = y.Right</span><br><span class="line">	<span class="keyword">if</span> y.Right != t.NIL &#123;</span><br><span class="line">		y.Right.Parent = x</span><br><span class="line">	&#125;</span><br><span class="line">	y.Parent = x.Parent</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> x.Parent == t.NIL &#123;</span><br><span class="line">		t.root = y</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == x.Parent.Left &#123;</span><br><span class="line">		x.Parent.Left = y</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x.Parent.Right = y</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	y.Right = x</span><br><span class="line">	x.Parent = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">insert</span><span class="params">(z *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	x := t.root</span><br><span class="line">	y := t.NIL</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> x != t.NIL &#123;</span><br><span class="line">		y = x</span><br><span class="line">		<span class="keyword">if</span> less(z.Item, x.Item) &#123;</span><br><span class="line">			x = x.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> less(x.Item, z.Item) &#123;</span><br><span class="line">			x = x.Right</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z.Parent = y</span><br><span class="line">	<span class="keyword">if</span> y == t.NIL &#123;</span><br><span class="line">		t.root = z</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> less(z.Item, y.Item) &#123;</span><br><span class="line">		y.Left = z</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y.Right = z</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.count++</span><br><span class="line">	t.insertFixup(z)</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">insertFixup</span><span class="params">(z *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> z.Parent.Color == RED &#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Howerver, we do not need the assertion of non-nil grandparent</span></span><br><span class="line">		<span class="comment">// because</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//  2) The root is black</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Since the color of the parent is RED, so the parent is not root</span></span><br><span class="line">		<span class="comment">// and the grandparent must be exist.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> z.Parent == z.Parent.Parent.Left &#123;</span><br><span class="line">			<span class="comment">// Take y as the uncle, although it can be NIL, in that case</span></span><br><span class="line">			<span class="comment">// its color is BLACK</span></span><br><span class="line">			y := z.Parent.Parent.Right</span><br><span class="line">			<span class="keyword">if</span> y.Color == RED &#123;</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// Case 1:</span></span><br><span class="line">				<span class="comment">// Parent and uncle are both RED, the grandparent must be BLACK</span></span><br><span class="line">				<span class="comment">// due to</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">//  4) Both children of every red node are black</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// Since the current node and its parent are all RED, we still</span></span><br><span class="line">				<span class="comment">// in violation of 4), So repaint both the parent and the uncle</span></span><br><span class="line">				<span class="comment">// to BLACK and grandparent to RED(to maintain 5)</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">//  5) Every simple path from root to leaves contains the same</span></span><br><span class="line">				<span class="comment">//     number of black nodes.</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				z.Parent.Color = BLACK</span><br><span class="line">				y.Color = BLACK</span><br><span class="line">				z.Parent.Parent.Color = RED</span><br><span class="line">				z = z.Parent.Parent</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> z == z.Parent.Right &#123;</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					<span class="comment">// Case 2:</span></span><br><span class="line">					<span class="comment">// Parent is RED and uncle is BLACK and the current node</span></span><br><span class="line">					<span class="comment">// is right child</span></span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					<span class="comment">// A left rotation on the parent of the current node will</span></span><br><span class="line">					<span class="comment">// switch the roles of each other. This still leaves us in</span></span><br><span class="line">					<span class="comment">// violation of 4).</span></span><br><span class="line">					<span class="comment">// The continuation into Case 3 will fix that.</span></span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					z = z.Parent</span><br><span class="line">					t.leftRotate(z)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// Case 3:</span></span><br><span class="line">				<span class="comment">// Parent is RED and uncle is BLACK and the current node is</span></span><br><span class="line">				<span class="comment">// left child</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// At the very beginning of Case 3, current node and parent are</span></span><br><span class="line">				<span class="comment">// both RED, thus we violate 4).</span></span><br><span class="line">				<span class="comment">// Repaint parent to BLACK will fix it, but 5) does not allow</span></span><br><span class="line">				<span class="comment">// this because all paths that go through the parent will get</span></span><br><span class="line">				<span class="comment">// 1 more black node. Then repaint grandparent to RED (as we</span></span><br><span class="line">				<span class="comment">// discussed before, the grandparent is BLACK) and do a right</span></span><br><span class="line">				<span class="comment">// rotation will fix that.</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				z.Parent.Color = BLACK</span><br><span class="line">				z.Parent.Parent.Color = RED</span><br><span class="line">				t.rightRotate(z.Parent.Parent)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// same as then clause with "right" and "left" exchanged</span></span><br><span class="line">			y := z.Parent.Parent.Left</span><br><span class="line">			<span class="keyword">if</span> y.Color == RED &#123;</span><br><span class="line">				z.Parent.Color = BLACK</span><br><span class="line">				y.Color = BLACK</span><br><span class="line">				z.Parent.Parent.Color = RED</span><br><span class="line">				z = z.Parent.Parent</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> z == z.Parent.Left &#123;</span><br><span class="line">					z = z.Parent</span><br><span class="line">					t.rightRotate(z)</span><br><span class="line">				&#125;</span><br><span class="line">				z.Parent.Color = BLACK</span><br><span class="line">				z.Parent.Parent.Color = RED</span><br><span class="line">				t.leftRotate(z.Parent.Parent)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t.root.Color = BLACK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just traverse the node from root to left recursively until left is NIL.</span></span><br><span class="line"><span class="comment">// The node whose left is NIL is the node with minimum value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">min</span><span class="params">(x *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> t.NIL</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> x.Left != t.NIL &#123;</span><br><span class="line">		x = x.Left</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just traverse the node from root to right recursively until right is NIL.</span></span><br><span class="line"><span class="comment">// The node whose right is NIL is the node with maximum value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">max</span><span class="params">(x *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> t.NIL</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> x.Right != t.NIL &#123;</span><br><span class="line">		x = x.Right</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">search</span><span class="params">(x *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	p := t.root</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> p != t.NIL &#123;</span><br><span class="line">		<span class="keyword">if</span> less(p.Item, x.Item) &#123;</span><br><span class="line">			p = p.Right</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> less(x.Item, p.Item) &#123;</span><br><span class="line">			p = p.Left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Need Document</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">successor</span><span class="params">(x *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> t.NIL</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the minimum from the right sub-tree if it existed.</span></span><br><span class="line">	<span class="keyword">if</span> x.Right != t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> t.min(x.Right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	y := x.Parent</span><br><span class="line">	<span class="keyword">for</span> y != t.NIL &amp;&amp; x == y.Right &#123;</span><br><span class="line">		x = y</span><br><span class="line">		y = y.Parent</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Need Document</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">delete</span><span class="params">(key *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	z := t.search(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> z == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> t.NIL</span><br><span class="line">	&#125;</span><br><span class="line">	ret := &amp;Node&#123;t.NIL, t.NIL, t.NIL, z.Color, z.Item&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> y *Node</span><br><span class="line">	<span class="keyword">var</span> x *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> z.Left == t.NIL || z.Right == t.NIL &#123;</span><br><span class="line">		y = z</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = t.successor(z)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y.Left != t.NIL &#123;</span><br><span class="line">		x = y.Left</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = y.Right</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Even if x is NIL, we do the assign. In that case all the NIL nodes will</span></span><br><span class="line">	<span class="comment">// change from &#123;nil, nil, nil, BLACK, nil&#125; to &#123;nil, nil, ADDR, BLACK, nil&#125;,</span></span><br><span class="line">	<span class="comment">// but do not worry about that because it will not affect the compare</span></span><br><span class="line">	<span class="comment">// between Node-X with Node-NIL</span></span><br><span class="line">	x.Parent = y.Parent</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y.Parent == t.NIL &#123;</span><br><span class="line">		t.root = x</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> y == y.Parent.Left &#123;</span><br><span class="line">		y.Parent.Left = x</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y.Parent.Right = x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y != z &#123;</span><br><span class="line">		z.Item = y.Item</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> y.Color == BLACK &#123;</span><br><span class="line">		t.deleteFixup(x)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.count--</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">deleteFixup</span><span class="params">(x *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> x != t.root &amp;&amp; x.Color == BLACK &#123;</span><br><span class="line">		<span class="keyword">if</span> x == x.Parent.Left &#123;</span><br><span class="line">			w := x.Parent.Right</span><br><span class="line">			<span class="keyword">if</span> w.Color == RED &#123;</span><br><span class="line">				w.Color = BLACK</span><br><span class="line">				x.Parent.Color = RED</span><br><span class="line">				t.leftRotate(x.Parent)</span><br><span class="line">				w = x.Parent.Right</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> w.Left.Color == BLACK &amp;&amp; w.Right.Color == BLACK &#123;</span><br><span class="line">				w.Color = RED</span><br><span class="line">				x = x.Parent</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> w.Right.Color == BLACK &#123;</span><br><span class="line">					w.Left.Color = BLACK</span><br><span class="line">					w.Color = RED</span><br><span class="line">					t.rightRotate(w)</span><br><span class="line">					w = x.Parent.Right</span><br><span class="line">				&#125;</span><br><span class="line">				w.Color = x.Parent.Color</span><br><span class="line">				x.Parent.Color = BLACK</span><br><span class="line">				w.Right.Color = BLACK</span><br><span class="line">				t.leftRotate(x.Parent)</span><br><span class="line">				<span class="comment">// this is to exit while loop</span></span><br><span class="line">				x = t.root</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// the code below is has left and right switched from above</span></span><br><span class="line">			w := x.Parent.Left</span><br><span class="line">			<span class="keyword">if</span> w.Color == RED &#123;</span><br><span class="line">				w.Color = BLACK</span><br><span class="line">				x.Parent.Color = RED</span><br><span class="line">				t.rightRotate(x.Parent)</span><br><span class="line">				w = x.Parent.Left</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> w.Left.Color == BLACK &amp;&amp; w.Right.Color == BLACK &#123;</span><br><span class="line">				w.Color = RED</span><br><span class="line">				x = x.Parent</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> w.Left.Color == BLACK &#123;</span><br><span class="line">					w.Right.Color = BLACK</span><br><span class="line">					w.Color = RED</span><br><span class="line">					t.leftRotate(w)</span><br><span class="line">					w = x.Parent.Left</span><br><span class="line">				&#125;</span><br><span class="line">				w.Color = x.Parent.Color</span><br><span class="line">				x.Parent.Color = BLACK</span><br><span class="line">				w.Left.Color = BLACK</span><br><span class="line">				t.rightRotate(x.Parent)</span><br><span class="line">				x = t.root</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x.Color = BLACK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This file contains most of the methods that can be used</span></span><br><span class="line"><span class="comment">// by the user. Anyone who wants to look for some API about</span></span><br><span class="line"><span class="comment">// the rbtree, this is the right place.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of nodes in the tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">uint</span></span> &#123; <span class="keyword">return</span> t.count &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Insert</span><span class="params">(item Item)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always insert a RED node</span></span><br><span class="line">	t.insert(&amp;Node&#123;t.NIL, t.NIL, t.NIL, RED, item&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InsertOrGet inserts or retrieves the item in the tree. If the</span></span><br><span class="line"><span class="comment">//item is already in the tree then the return value will be that.</span></span><br><span class="line"><span class="comment">//If the item is not in the tree the return value will be the item</span></span><br><span class="line"><span class="comment">//you put in.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">InsertOrGet</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.insert(&amp;Node&#123;t.NIL, t.NIL, t.NIL, RED, item&#125;).Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Delete</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The `color` field here is nobody</span></span><br><span class="line">	<span class="keyword">return</span> t.<span class="built_in">delete</span>(&amp;Node&#123;t.NIL, t.NIL, t.NIL, RED, item&#125;).Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Get</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The `color` field here is nobody</span></span><br><span class="line">	ret := t.search(&amp;Node&#123;t.NIL, t.NIL, t.NIL, RED, item&#125;)</span><br><span class="line">	<span class="keyword">if</span> ret == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret.Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> This is for debug, delete it in the future</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Search</span><span class="params">(item Item)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.search(&amp;Node&#123;t.NIL, t.NIL, t.NIL, RED, item&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Min</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	x := t.min(t.root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x.Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	x := t.max(t.root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x.Item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Iterator <span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ascend will call iterator once for each element greater or equal than pivot</span></span><br><span class="line"><span class="comment">// in ascending order. It will stop whenever the iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Ascend</span><span class="params">(pivot Item, iterator Iterator)</span></span> &#123;</span><br><span class="line">	t.ascend(t.root, pivot, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">ascend</span><span class="params">(x *Node, pivot Item, iterator Iterator)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !less(x.Item, pivot) &#123;</span><br><span class="line">		<span class="keyword">if</span> !t.ascend(x.Left, pivot, iterator) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !iterator(x.Item) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.ascend(x.Right, pivot, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Descend will call iterator once for each element less or equal than pivot</span></span><br><span class="line"><span class="comment">// in descending order. It will stop whenever the iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">Descend</span><span class="params">(pivot Item, iterator Iterator)</span></span> &#123;</span><br><span class="line">	t.descend(t.root, pivot, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">descend</span><span class="params">(x *Node, pivot Item, iterator Iterator)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !less(pivot, x.Item) &#123;</span><br><span class="line">		<span class="keyword">if</span> !t.descend(x.Right, pivot, iterator) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !iterator(x.Item) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.descend(x.Left, pivot, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AscendRange will call iterator once for elements greater or equal than @ge</span></span><br><span class="line"><span class="comment">// and less than @lt, which means the range would be [ge, lt).</span></span><br><span class="line"><span class="comment">// It will stop whenever the iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">AscendRange</span><span class="params">(ge, lt Item, iterator Iterator)</span></span> &#123;</span><br><span class="line">	t.ascendRange(t.root, ge, lt, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Rbtree)</span> <span class="title">ascendRange</span><span class="params">(x *Node, inf, sup Item, iterator Iterator)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == t.NIL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !less(x.Item, sup) &#123;</span><br><span class="line">		<span class="keyword">return</span> t.ascendRange(x.Left, inf, sup, iterator)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> less(x.Item, inf) &#123;</span><br><span class="line">		<span class="keyword">return</span> t.ascendRange(x.Right, inf, sup, iterator)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !t.ascendRange(x.Left, inf, sup, iterator) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !iterator(x.Item) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.ascendRange(x.Right, inf, sup, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	text <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts *testStruct)</span> <span class="title">Less</span><span class="params">(than Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ts.id &lt; than.(*testStruct).id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Int implements the Item interface for integers.</span></span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns true if int(a) &lt; int(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Int)</span> <span class="title">Less</span><span class="params">(b Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b.(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rbTree := New()</span><br><span class="line">	items := []*testStruct&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="string">"this"</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="string">"is"</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="string">"a"</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="string">"test"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> items &#123;</span><br><span class="line">		rbTree.Insert(items[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rbTree.Descend(items[<span class="number">2</span>], <span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	newItem := &amp;testStruct&#123;items[<span class="number">0</span>].id, <span class="string">"not"</span>&#125;</span><br><span class="line">	newItem = rbTree.InsertOrGet(newItem).(*testStruct)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> newItem.text != items[<span class="number">0</span>].text &#123;</span><br><span class="line">		fmt.Println(fmt.Errorf(<span class="string">"tree.InsertOrGet = &#123;id: %d, text: %s&#125;, expect &#123;id %d, text %s&#125;"</span>, newItem.id, newItem.text, items[<span class="number">0</span>].id, items[<span class="number">0</span>].text))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newItem = &amp;testStruct&#123;<span class="number">5</span>, <span class="string">"new"</span>&#125;</span><br><span class="line">	newItem = rbTree.InsertOrGet(newItem).(*testStruct)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> newItem.text != <span class="string">"new"</span> &#123;</span><br><span class="line">		fmt.Println(fmt.Errorf(<span class="string">"tree.InsertOrGet = &#123;id: %d, text: %s&#125;, expect &#123;id %d, text %s&#125;"</span>, newItem.id, newItem.text, <span class="number">5</span>, <span class="string">"new"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-4-Trie字典树"><a href="#9-4-Trie字典树" class="headerlink" title="9.4 Trie字典树"></a>9.4 Trie字典树</h2><p>字典树（Trie）是一种很特别的树状信息检索数据结构，如同其名，它的构成就像一本字典，可以让你快速的进行字符插入、字符串搜索等。 </p>
<p>字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的<strong>共同前缀（Common Prefix）</strong>作为存储依据，以此来节省存储空间，并加速搜索时间。Trie 的字符串搜索时间复杂度为 <strong>O(m)</strong>，m 为最长的字符串的长度，其查询性能与集合中的字符串的数量无关。其在搜索字符串时表现出的高效，使得特别适用于构建文本搜索和词频统计等应用。 </p>
<p><strong>map实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典树(前缀树)</span></span><br><span class="line"><span class="keyword">type</span> trieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	isWord <span class="keyword">bool</span>  <span class="comment">// 是否是单词结尾</span></span><br><span class="line">	next   <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*trieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	size <span class="keyword">int</span>  <span class="comment">// 节点数量</span></span><br><span class="line">	root *trieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrie</span><span class="params">()</span> *<span class="title">trie</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;trie&#123;</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;trieNode&#123;<span class="literal">false</span>, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*trieNode)&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *trie)</span> <span class="title">GetSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *trie)</span> <span class="title">Add</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := this.root</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> word &#123;</span><br><span class="line">		_, ok := cur.next[v] <span class="comment">// 在NewTrie中已经初始化，能直接用</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			cur.next[v] = &amp;trieNode&#123;<span class="literal">false</span>, <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*trieNode&#123;&#125;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.next[v]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断该单词之前是否已经添加到tree中了</span></span><br><span class="line">	<span class="keyword">if</span> !cur.isWord &#123;</span><br><span class="line">		cur.isWord = <span class="literal">true</span></span><br><span class="line">		this.size++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *trie)</span> <span class="title">Add2</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	cur := this.root</span><br><span class="line">	this.size = this.size + cur.insert(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助完成递归函数:在node节点中插入word,如果是已经存在的单词,返回0,如果不存在返回1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *trieNode)</span> <span class="title">insert</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	_, ok := node.next[<span class="keyword">rune</span>(word[<span class="number">0</span>])]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		node.next[<span class="keyword">rune</span>(word[<span class="number">0</span>])] = &amp;trieNode&#123;<span class="literal">false</span>,</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*trieNode&#123;&#125;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node = node.next[<span class="keyword">rune</span>(word[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !node.isWord &#123;</span><br><span class="line">			node.isWord = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node.insert(word[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询是否包含某个单词</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *trie)</span> <span class="title">Contains</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := this.root</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> word &#123;</span><br><span class="line">		t1, ok := cur.next[v]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur = t1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur.isWord</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缀是否有以prefix为前缀的单词</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *trie)</span> <span class="title">IsPrefix</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := this.root</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> word &#123;</span><br><span class="line">		t1, ok := cur.next[v]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur = t1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trie := NewTrie()</span><br><span class="line">	trie.Add(<span class="string">"a傲慢"</span>)</span><br><span class="line">	trie.Add(<span class="string">"傲慢"</span>)</span><br><span class="line">	trie.Add2(<span class="string">"ff"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"一共"</span>,trie.GetSize(),<span class="string">"个单词"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(trie.Contains(<span class="string">"a傲慢"</span>))</span><br><span class="line">	fmt.Println(trie.Contains(<span class="string">"傲慢"</span>))</span><br><span class="line">	fmt.Println(trie.Contains(<span class="string">"ff"</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(trie.IsPrefix(<span class="string">"傲"</span>))</span><br><span class="line">	fmt.Println(trie.IsPrefix(<span class="string">"a"</span>))</span><br><span class="line">	fmt.Println(trie.IsPrefix(<span class="string">"f"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-5-线段树"><a href="#9-5-线段树" class="headerlink" title="9.5 线段树"></a>9.5 线段树</h2><p><strong>线段树（segment tree）</strong>，顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的<strong>区间查询（range query）</strong>和<strong>元素更新（update）</strong>操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行<strong>区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值</strong>的查询。</p>
<p>对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。</p>
<p>注意：</p>
<ol>
<li>线段树不是完全二叉树</li>
<li>线段树是平衡二叉树</li>
<li>堆（完全二叉树）也是平衡二叉树</li>
<li>二分搜索树不一定是平衡二叉树</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Inf is defined as the max value of an integer, used as +∞</span></span><br><span class="line">	Inf = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// NegInf is defined as the min value of an integer, used as -∞</span></span><br><span class="line">	NegInf = -Inf - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interval <span class="keyword">struct</span> &#123;</span><br><span class="line">	segment</span><br><span class="line">	element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> segment <span class="keyword">struct</span> &#123;</span><br><span class="line">	from <span class="keyword">int</span></span><br><span class="line">	to   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	segment     segment</span><br><span class="line">	left, right *node</span><br><span class="line">	intervals   []*interval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	base     []interval</span><br><span class="line">	elements <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	root     *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push pushes an interval to the interval stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">Push</span><span class="params">(from, to <span class="keyword">int</span>, element <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> to &lt; from &#123;</span><br><span class="line">		from, to = to, from</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.elements == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.elements = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	t.elements[element] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	t.base = <span class="built_in">append</span>(t.base, interval&#123;segment&#123;from, to&#125;, element&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear clears the interval stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t.root = <span class="literal">nil</span></span><br><span class="line">	t.base = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BuildTree builds the segment tree from the interval stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">BuildTree</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.base) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"No intervals in stack. Push intervals on the stack of the tree first."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leaves := elementaryIntervals(t.endpoints())</span><br><span class="line">	t.root = t.insertNodes(leaves)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> t.base &#123;</span><br><span class="line">		t.root.insertInterval(&amp;t.base[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print prints a binary tree recursively to sdout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	endpoints := <span class="built_in">len</span>(t.base)*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">	leaves := endpoints*<span class="number">2</span> - <span class="number">3</span></span><br><span class="line">	height := <span class="number">1</span> + log2(leaves)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Height:"</span>, height, <span class="string">", leaves:"</span>, leaves)</span><br><span class="line">	levels := <span class="built_in">make</span>([][]*node, height+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	traverse(t.root, <span class="number">0</span>, <span class="function"><span class="keyword">func</span><span class="params">(n *node, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		levels[depth] = <span class="built_in">append</span>(levels[depth], n)</span><br><span class="line">	&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, level := <span class="keyword">range</span> levels &#123;</span><br><span class="line">		<span class="keyword">for</span> j, n := <span class="keyword">range</span> level &#123;</span><br><span class="line">			space(<span class="number">12</span> * (<span class="built_in">len</span>(levels) - <span class="number">1</span> - i))</span><br><span class="line">			n.<span class="built_in">print</span>()</span><br><span class="line">			space(<span class="number">1</span> * (height - i))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> j<span class="number">-1</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				space(<span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Removes duplicate entries from a sorted slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removedups</span><span class="params">(sorted []<span class="keyword">int</span>)</span> <span class="params">(unique []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	unique = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(sorted))</span><br><span class="line">	unique = <span class="built_in">append</span>(unique, sorted[<span class="number">0</span>])</span><br><span class="line">	prev := sorted[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> sorted[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> val != prev &#123;</span><br><span class="line">			unique = <span class="built_in">append</span>(unique, val)</span><br><span class="line">			prev = val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a sorted slice of unique endpoints from a tree's base</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">endpoints</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	baseLen := <span class="built_in">len</span>(t.base)</span><br><span class="line">	endpoints := <span class="built_in">make</span>([]<span class="keyword">int</span>, baseLen*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When there are a lot of intervals, there is a big chance of big overlaps</span></span><br><span class="line">	<span class="comment">// Try to have the endpoints sorted as much as possible when putting them</span></span><br><span class="line">	<span class="comment">// in the slice to reduce the final sort time.</span></span><br><span class="line">	<span class="comment">// endpoints[0] = NegInf</span></span><br><span class="line">	<span class="keyword">for</span> i, interval := <span class="keyword">range</span> t.base &#123;</span><br><span class="line">		endpoints[i] = interval.from</span><br><span class="line">		endpoints[i+baseLen] = interval.to</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// endpoints[baseLen*2+1] = Inf</span></span><br><span class="line"></span><br><span class="line">	sort.Sort(sort.IntSlice(endpoints))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> removedups(endpoints)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a slice of elementary intervals from a slice of (sorted) endpoints</span></span><br><span class="line"><span class="comment">// Input: [p1, p2, ..., pn]</span></span><br><span class="line"><span class="comment">// Output: [&#123;p1 : p1&#125;, &#123;p1 : p2&#125;, &#123;p2 : p2&#125;,... , &#123;pn : pn&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">elementaryIntervals</span><span class="params">(endpoints []<span class="keyword">int</span>)</span> []<span class="title">segment</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(endpoints) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []segment&#123;segment&#123;endpoints[<span class="number">0</span>], endpoints[<span class="number">0</span>]&#125;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	intervals := <span class="built_in">make</span>([]segment, <span class="built_in">len</span>(endpoints)*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(endpoints); i++ &#123;</span><br><span class="line">		intervals[i*<span class="number">2</span>] = segment&#123;endpoints[i], endpoints[i]&#125;</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(endpoints)<span class="number">-1</span> &#123;</span><br><span class="line">			intervals[i*<span class="number">2</span>+<span class="number">1</span>] = segment&#123;endpoints[i], endpoints[i+<span class="number">1</span>]&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insertNodes builds the tree structure from the elementary intervals</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">insertNodes</span><span class="params">(leaves []segment)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n *node</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(leaves) == <span class="number">1</span> &#123;</span><br><span class="line">		n = &amp;node&#123;segment: leaves[<span class="number">0</span>]&#125;</span><br><span class="line">		n.left = <span class="literal">nil</span></span><br><span class="line">		n.right = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n = &amp;node&#123;segment: segment&#123;leaves[<span class="number">0</span>].from, leaves[<span class="built_in">len</span>(leaves)<span class="number">-1</span>].to&#125;&#125;</span><br><span class="line">		center := <span class="built_in">len</span>(leaves) / <span class="number">2</span></span><br><span class="line">		n.left = t.insertNodes(leaves[:center])</span><br><span class="line">		n.right = t.insertNodes(leaves[center:])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *segment)</span> <span class="title">subsetOf</span><span class="params">(other *segment)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> other.from &lt;= s.from &amp;&amp; other.to &gt;= s.to</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *segment)</span> <span class="title">intersectsWith</span><span class="params">(other *segment)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> other.from &lt;= s.to &amp;&amp; s.from &lt;= other.to ||</span><br><span class="line">		s.from &lt;= other.to &amp;&amp; other.from &lt;= s.to</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inserts interval into given tree structure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insertInterval</span><span class="params">(i *interval)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.segment.subsetOf(&amp;i.segment) &#123;</span><br><span class="line">		<span class="keyword">if</span> n.intervals == <span class="literal">nil</span> &#123;</span><br><span class="line">			n.intervals = <span class="built_in">make</span>([]*interval, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n.intervals = <span class="built_in">append</span>(n.intervals, i)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n.left != <span class="literal">nil</span> &amp;&amp; n.left.segment.intersectsWith(&amp;i.segment) &#123;</span><br><span class="line">			n.left.insertInterval(i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n.right != <span class="literal">nil</span> &amp;&amp; n.right.segment.intersectsWith(&amp;i.segment) &#123;</span><br><span class="line">			n.right.insertInterval(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	from := fmt.Sprintf(<span class="string">"%d"</span>, n.segment.from)</span><br><span class="line">	<span class="keyword">switch</span> n.segment.from &#123;</span><br><span class="line">	<span class="keyword">case</span> Inf:</span><br><span class="line">		from = <span class="string">"+∞"</span></span><br><span class="line">	<span class="keyword">case</span> NegInf:</span><br><span class="line">		from = <span class="string">"-∞"</span></span><br><span class="line">	&#125;</span><br><span class="line">	to := fmt.Sprintf(<span class="string">"%d"</span>, n.segment.to)</span><br><span class="line">	<span class="keyword">switch</span> n.segment.to &#123;</span><br><span class="line">	<span class="keyword">case</span> Inf:</span><br><span class="line">		to = <span class="string">"Inf"</span></span><br><span class="line">	<span class="keyword">case</span> NegInf:</span><br><span class="line">		to = <span class="string">"NegInf"</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"(%s,%s)"</span>, from, to)</span><br><span class="line">	<span class="keyword">if</span> n.intervals != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Print(<span class="string">"-&gt;["</span>)</span><br><span class="line">		<span class="keyword">for</span> _, intrvl := <span class="keyword">range</span> n.intervals &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"(%v,%v)=[%v]"</span>, intrvl.from, intrvl.to, intrvl.element)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(<span class="string">"]"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QueryIndex looks for all segments in the interval tree that contain</span></span><br><span class="line"><span class="comment">// a given index. The elements associated with the segments will be sent</span></span><br><span class="line"><span class="comment">// on the returned channel. No element will be sent twice.</span></span><br><span class="line"><span class="comment">// The elements will not be sent in any specific order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">QueryIndex</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Tree is empty. Build the tree first"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	intervals := <span class="built_in">make</span>(<span class="keyword">chan</span> *interval)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *Tree, index <span class="keyword">int</span>, intervals <span class="keyword">chan</span> *interval)</span></span> &#123;</span><br><span class="line">		query(t.root, index, intervals)</span><br><span class="line">		<span class="built_in">close</span>(intervals)</span><br><span class="line">	&#125;(t, index, intervals)</span><br><span class="line"></span><br><span class="line">	elements := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intervals <span class="keyword">chan</span> *interval, elements <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(elements)</span><br><span class="line">		results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">for</span> interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">			_, alreadyFound := results[interval.element]</span><br><span class="line">			<span class="keyword">if</span> !alreadyFound &#123;</span><br><span class="line">				<span class="comment">// Store an empty struct in the map to minimize memory footprint</span></span><br><span class="line">				results[interval.element] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				elements &lt;- interval.element</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(results) &gt;= <span class="built_in">len</span>(t.elements) &#123;</span><br><span class="line">					<span class="comment">// found all elements that can be found</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(intervals, elements)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> elements, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s segment)</span> <span class="title">contains</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.from &lt;= index &amp;&amp; index &lt;= s.to</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(node *node, index <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- *interval)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.segment.contains(index) &#123;</span><br><span class="line">		<span class="keyword">for</span> _, interval := <span class="keyword">range</span> node.intervals &#123;</span><br><span class="line">			results &lt;- interval</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.left != <span class="literal">nil</span> &#123;</span><br><span class="line">			query(node.left, index, results)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			query(node.right, index, results)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse tree recursively call enter when entering node, resp. leave</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(node *node, depth <span class="keyword">int</span>, enter, leave <span class="keyword">func</span>(*node, <span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> enter != <span class="literal">nil</span> &#123;</span><br><span class="line">		enter(node, depth)</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(node.left, depth+<span class="number">1</span>, enter, leave)</span><br><span class="line">	traverse(node.right, depth+<span class="number">1</span>, enter, leave)</span><br><span class="line">	<span class="keyword">if</span> leave != <span class="literal">nil</span> &#123;</span><br><span class="line">		leave(node, depth)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returs log with base 2 of an int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log2</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> NegInf</span><br><span class="line">	&#125;</span><br><span class="line">	i := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">		num = num &gt;&gt; <span class="number">1</span></span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">space</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fmt.Print(<span class="string">" "</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">10</span>, <span class="string">"hello, world"</span>)</span><br><span class="line">	tree.Push(<span class="number">5</span>, <span class="number">6</span>, <span class="string">"how are you today?"</span>)</span><br><span class="line">	tree.Push(<span class="number">6</span>, <span class="number">45</span>, <span class="string">"test"</span>)</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	results,err := tree.QueryIndex(<span class="number">6</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	result := &lt;-results</span><br><span class="line">	fmt.Println(result)</span><br><span class="line"></span><br><span class="line">	tree.Print()</span><br><span class="line"></span><br><span class="line">	FindingSingleElement()</span><br><span class="line">	FindingElementSizeZeroRange()</span><br><span class="line">	FindingElementPseudoEndlessRange()</span><br><span class="line">	FindingMultipleElements()</span><br><span class="line">	FindingOverlappingElements()</span><br><span class="line">	OutOfRangeNotFound()</span><br><span class="line">	AddingReverseDirection()</span><br><span class="line">	FindingSameElementTwice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingSingleElement</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">10</span>, test)</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result != test &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,test)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingElementSizeZeroRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">1</span>, test)</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result != test &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,test)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingElementPseudoEndlessRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line">	tree.Push(<span class="number">1</span>, Inf, test)</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">9999</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result != test &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,test)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(element <span class="keyword">interface</span>&#123;&#125;, elements []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, e := <span class="keyword">range</span> elements &#123;</span><br><span class="line">		<span class="keyword">if</span> element == e &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingMultipleElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	tests := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line">	tests[<span class="number">0</span>] = <span class="string">"one"</span></span><br><span class="line">	tests[<span class="number">1</span>] = <span class="string">"two"</span></span><br><span class="line">	tests[<span class="number">2</span>] = <span class="number">3.14</span></span><br><span class="line">	tests[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">	tests[<span class="number">4</span>] = <span class="string">"stuff"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		tree.Push(<span class="number">10</span>+i, <span class="number">100</span>+i, test)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tree.BuildTree()</span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		found, index := find(result, tests)</span><br><span class="line">		<span class="keyword">if</span> !found &#123;</span><br><span class="line">			fmt.Println(<span class="string">"receivedUnexpected"</span>,result)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Remove element from tests</span></span><br><span class="line">		tests[index], tests = tests[<span class="built_in">len</span>(tests)<span class="number">-1</span>], tests[:<span class="built_in">len</span>(tests)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tests) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">			fmt.Println(fmt.Errorf(<span class="string">"Did not find %v\n"</span>, test))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingOverlappingElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	tests := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line">	tests[<span class="number">0</span>] = <span class="string">"one"</span></span><br><span class="line">	tests[<span class="number">1</span>] = <span class="string">"two"</span></span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">10</span>, tests[<span class="number">0</span>])</span><br><span class="line">	tree.Push(<span class="number">5</span>, <span class="number">15</span>, tests[<span class="number">1</span>])</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Index only in first range</span></span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line">	<span class="keyword">if</span> result != tests[<span class="number">0</span>] &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,tests[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Index only in second range</span></span><br><span class="line">	results, err = tree.QueryIndex(<span class="number">11</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = &lt;-results</span><br><span class="line">	<span class="keyword">if</span> result != tests[<span class="number">1</span>] &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,tests[<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Index in both ranges</span></span><br><span class="line">	results, err = tree.QueryIndex(<span class="number">6</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		found, index := find(result, tests)</span><br><span class="line">		<span class="keyword">if</span> !found &#123;</span><br><span class="line">			fmt.Println(<span class="string">"receivedUnexpected"</span>,result)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Remove element from tests</span></span><br><span class="line">		tests[index], tests = tests[<span class="built_in">len</span>(tests)<span class="number">-1</span>], tests[:<span class="built_in">len</span>(tests)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tests) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">			fmt.Println(fmt.Errorf(<span class="string">"Did not find %v\n"</span>, test))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OutOfRangeNotFound</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line"></span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">10</span>, test)</span><br><span class="line"></span><br><span class="line">	tree.BuildTree()</span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"receivedUnexpected"</span>,result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddingReverseDirection</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line">	tree.Push(<span class="number">10</span>, <span class="number">1</span>, test)</span><br><span class="line">	tree.BuildTree()</span><br><span class="line"></span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result != test &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,test)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindingSameElementTwice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(Tree)</span><br><span class="line">	test := <span class="string">"hello, world"</span></span><br><span class="line"></span><br><span class="line">	tree.Push(<span class="number">1</span>, <span class="number">10</span>, test)</span><br><span class="line">	tree.Push(<span class="number">5</span>, <span class="number">15</span>, test)</span><br><span class="line"></span><br><span class="line">	tree.BuildTree()</span><br><span class="line">	results, err := tree.QueryIndex(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"queryFailed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &lt;-results</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result != test &#123;</span><br><span class="line">		fmt.Println(<span class="string">"wrongElement"</span>,result,test)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `test` should only be sent once</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := &lt;-results; ok != <span class="literal">false</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"toManyElements"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6-平衡二叉树"><a href="#9-6-平衡二叉树" class="headerlink" title="9.6 平衡二叉树"></a>9.6 平衡二叉树</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AVL <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span>      <span class="comment">//值</span></span><br><span class="line">	height <span class="keyword">int</span>     <span class="comment">//深度</span></span><br><span class="line">	left *AVL      <span class="comment">//左子树</span></span><br><span class="line">	right *AVL     <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">Search</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	compare := value - t.value</span><br><span class="line">	<span class="keyword">if</span> compare &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.left.Search(value)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> compare &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.right.Search(value)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">leftRotate</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;  <span class="comment">//左旋转</span></span><br><span class="line">	headNode := t.right</span><br><span class="line">	t.right = headNode.left</span><br><span class="line">	headNode.left = t</span><br><span class="line">	<span class="comment">//更新结点高度</span></span><br><span class="line">	t.height = max(t.left.getHeight(),t.right.getHeight()) + <span class="number">1</span></span><br><span class="line">	headNode.height = max(headNode.left.getHeight(),headNode.right.getHeight()) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> headNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">rightRotate</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;  <span class="comment">//右旋转</span></span><br><span class="line">	headNode := t.left</span><br><span class="line">	t.left = headNode.right</span><br><span class="line">	headNode.right = t</span><br><span class="line">	<span class="comment">//更新结点高度</span></span><br><span class="line">	t.height = max(t.left.getHeight(),t.right.getHeight()) +<span class="number">1</span></span><br><span class="line">	headNode.height = max(headNode.left.getHeight(),headNode.right.getHeight()) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> headNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">rightThenLeftRotate</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;  <span class="comment">//右旋转,之后左旋转</span></span><br><span class="line">	<span class="comment">//以失衡点右结点先右旋转</span></span><br><span class="line">	sonHeadNode := t.right.rightRotate()</span><br><span class="line">	t.right = sonHeadNode</span><br><span class="line">	<span class="comment">//再以失衡点左旋转</span></span><br><span class="line">	<span class="keyword">return</span> t.leftRotate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">LeftThenRightRotate</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;  <span class="comment">//左旋转,之后右旋转</span></span><br><span class="line">	<span class="comment">//以失衡点左结点先左旋转</span></span><br><span class="line">	sonHeadNode := t.left.leftRotate()</span><br><span class="line">	t.left = sonHeadNode</span><br><span class="line">	<span class="comment">//再以失衡点左旋转</span></span><br><span class="line">	<span class="keyword">return</span> t.rightRotate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">adjust</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.right.getHeight() - t.left.getHeight() == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.right.right.getHeight() &gt; t.right.left.getHeight() &#123;</span><br><span class="line">			t = t.leftRotate()</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			t = t.rightThenLeftRotate()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> t.left.getHeight() - t.right.getHeight() == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.left.left.getHeight() &gt; t.left.right.getHeight() &#123;</span><br><span class="line">			t = t.rightRotate()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			t = t.LeftThenRightRotate()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">Insert</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">AVL</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		newNode := AVL&#123;value,<span class="number">1</span>,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;newNode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">		t.left = t.left.Insert(value)</span><br><span class="line">		t = t.adjust()</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> value &gt; t.value&#123;</span><br><span class="line">		t.right = t.right.Insert(value)</span><br><span class="line">		t = t.adjust()</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"the node exit"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t.height = max(t.left.getHeight(),t.right.getHeight()) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除元素</span></span><br><span class="line"><span class="comment">*1、如果被删除结点只有一个子结点，就直接将A的子结点连至A的父结点上，并将A删除</span></span><br><span class="line"><span class="comment">*2、如果被删除结点有两个子结点，将该结点右子数内的最小结点取代A。</span></span><br><span class="line"><span class="comment">*3、查看是否平衡,该调整调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">Delete</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">AVL</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t ==<span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line">	compare := value - t.value</span><br><span class="line">	<span class="keyword">if</span> compare &lt; <span class="number">0</span> &#123;</span><br><span class="line">		t.left = t.left.Delete(value)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> compare &gt; <span class="number">0</span>&#123;</span><br><span class="line">		t.right = t.right.Delete(value)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123; <span class="comment">//找到结点,删除结点（）</span></span><br><span class="line">		<span class="keyword">if</span> t.left != <span class="literal">nil</span> &amp;&amp; t.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.value = t.right.getMin()</span><br><span class="line">			t.right = t.right.Delete(t.value)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.left !=<span class="literal">nil</span> &#123;</span><br><span class="line">			t = t.left</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//只有一个右孩子或没孩子</span></span><br><span class="line">			t = t.right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.height = max(t.left.getHeight(),t.right.getHeight()) + <span class="number">1</span></span><br><span class="line">		t = t.adjust()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按顺序获得树中元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getAll</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	values := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> addValues(values,t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个节点加入切片中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValues</span><span class="params">(values []<span class="keyword">int</span>,t *AVL)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		values = addValues(values,t.left)</span><br><span class="line">		values = <span class="built_in">append</span>(values,t.value)</span><br><span class="line">		fmt.Println(t.value,t.height)</span><br><span class="line">		values = addValues(values,t.right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找子树最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.left == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.left.getMin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找子树最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getMax</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.right == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.right.getMax()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最小结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getMinNode</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t.left != <span class="literal">nil</span> &#123;</span><br><span class="line">			t = t.left</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最大结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getMaxNode</span><span class="params">()</span> *<span class="title">AVL</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			t = t.right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到树高</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *AVL)</span> <span class="title">getHeight</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bsTree := AVL&#123;<span class="number">100</span>,<span class="number">1</span>,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">	newTree := bsTree.Insert(<span class="number">60</span>)</span><br><span class="line">	newTree = bsTree.Insert(<span class="number">120</span>)</span><br><span class="line">	newTree = bsTree.Insert(<span class="number">110</span>)</span><br><span class="line">	newTree = bsTree.Insert(<span class="number">130</span>)</span><br><span class="line">	newTree = bsTree.Insert(<span class="number">105</span>)</span><br><span class="line">	fmt.Println(newTree.getAll())</span><br><span class="line"></span><br><span class="line">	newTree.Delete(<span class="number">110</span>)</span><br><span class="line">	fmt.Println(newTree.getAll())</span><br><span class="line">	fmt.Println(newTree.Search(<span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-7-B树-2-3-4树"><a href="#9-7-B树-2-3-4树" class="headerlink" title="9.7 B树(2-3-4树)"></a>9.7 B树(2-3-4树)</h2><p>234树是B树的特例。B树每个节点含有很多个子节点及数据项，每个数据项放的是一个数据块。 2-3-4树中一个节点最多只能有4个孩子，那如果每个孩子数再多一些呢，这就是B树。  </p>
<p>B树又称B-树，是一种平衡的多路查找树。B-树的阶是所有结点的孩子结点树的最大值。一棵m阶B-树，或为空树，或为满足下列特性的m叉树： </p>
<p><a href="https://github.com/google/btree" target="_blank" rel="noopener">https://github.com/google/btree</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item represents a single object in the tree.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Less tests whether the current item is less than the given argument.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This must provide a strict weak ordering.</span></span><br><span class="line">	<span class="comment">// If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (i.e. we can only</span></span><br><span class="line">	<span class="comment">// hold one of either a or b in the tree).</span></span><br><span class="line">	Less(than Item) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	DefaultFreeListSize = <span class="number">32</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	nilItems    = <span class="built_in">make</span>(items, <span class="number">16</span>)</span><br><span class="line">	nilChildren = <span class="built_in">make</span>(children, <span class="number">16</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeList represents a free list of btree nodes. By default each</span></span><br><span class="line"><span class="comment">// BTree has its own FreeList, but multiple BTrees can share the same</span></span><br><span class="line"><span class="comment">// FreeList.</span></span><br><span class="line"><span class="comment">// Two Btrees using the same freelist are safe for concurrent write access.</span></span><br><span class="line"><span class="keyword">type</span> FreeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu       sync.Mutex</span><br><span class="line">	freelist []*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFreeList creates a new free list.</span></span><br><span class="line"><span class="comment">// size is the maximum size of the returned free list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFreeList</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">FreeList</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;FreeList&#123;freelist: <span class="built_in">make</span>([]*node, <span class="number">0</span>, size)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FreeList)</span> <span class="title">newNode</span><span class="params">()</span> <span class="params">(n *node)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	index := <span class="built_in">len</span>(f.freelist) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">		f.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(node)</span><br><span class="line">	&#125;</span><br><span class="line">	n = f.freelist[index]</span><br><span class="line">	f.freelist[index] = <span class="literal">nil</span></span><br><span class="line">	f.freelist = f.freelist[:index]</span><br><span class="line">	f.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// freeNode adds the given node to the list, returning true if it was added</span></span><br><span class="line"><span class="comment">// and false if it was discarded.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FreeList)</span> <span class="title">freeNode</span><span class="params">(n *node)</span> <span class="params">(out <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	f.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.freelist) &lt; <span class="built_in">cap</span>(f.freelist) &#123;</span><br><span class="line">		f.freelist = <span class="built_in">append</span>(f.freelist, n)</span><br><span class="line">		out = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	f.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemIterator allows callers of Ascend* to iterate in-order over portions of</span></span><br><span class="line"><span class="comment">// the tree.  When this function returns false, iteration will stop and the</span></span><br><span class="line"><span class="comment">// associated Ascend* function will immediately return.</span></span><br><span class="line"><span class="keyword">type</span> ItemIterator <span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a new B-Tree with the given degree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// New(2), for example, will create a 2-3-4 tree (each node contains 1-3 items</span></span><br><span class="line"><span class="comment">// and 2-4 children).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(degree <span class="keyword">int</span>)</span> *<span class="title">BTree</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewWithFreeList(degree, NewFreeList(DefaultFreeListSize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWithFreeList creates a new B-Tree that uses the given node free list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWithFreeList</span><span class="params">(degree <span class="keyword">int</span>, f *FreeList)</span> *<span class="title">BTree</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> degree &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"bad degree"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;BTree&#123;</span><br><span class="line">		degree: degree,</span><br><span class="line">		cow:    &amp;copyOnWriteContext&#123;freelist: f&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// items stores items in a node.</span></span><br><span class="line"><span class="keyword">type</span> items []Item</span><br><span class="line"></span><br><span class="line"><span class="comment">// insertAt inserts a value into the given index, pushing all subsequent values</span></span><br><span class="line"><span class="comment">// forward.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *items)</span> <span class="title">insertAt</span><span class="params">(index <span class="keyword">int</span>, item Item)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(*s) &#123;</span><br><span class="line">		<span class="built_in">copy</span>((*s)[index+<span class="number">1</span>:], (*s)[index:])</span><br><span class="line">	&#125;</span><br><span class="line">	(*s)[index] = item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeAt removes a value at a given index, pulling all subsequent values</span></span><br><span class="line"><span class="comment">// back.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *items)</span> <span class="title">removeAt</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	item := (*s)[index]</span><br><span class="line">	<span class="built_in">copy</span>((*s)[index:], (*s)[index+<span class="number">1</span>:])</span><br><span class="line">	(*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">	*s = (*s)[:<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop removes and returns the last element in the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *items)</span> <span class="title">pop</span><span class="params">()</span> <span class="params">(out Item)</span></span> &#123;</span><br><span class="line">	index := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">	out = (*s)[index]</span><br><span class="line">	(*s)[index] = <span class="literal">nil</span></span><br><span class="line">	*s = (*s)[:index]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// truncate truncates this instance at index so that it contains only the</span></span><br><span class="line"><span class="comment">// first index items. index must be less than or equal to length.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *items)</span> <span class="title">truncate</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> toClear items</span><br><span class="line">	*s, toClear = (*s)[:index], (*s)[index:]</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(toClear) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		toClear = toClear[<span class="built_in">copy</span>(toClear, nilItems):]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find returns the index where the given item should be inserted into this</span></span><br><span class="line"><span class="comment">// list.  'found' is true if the item already exists in the list at the given</span></span><br><span class="line"><span class="comment">// index.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s items)</span> <span class="title">find</span><span class="params">(item Item)</span> <span class="params">(index <span class="keyword">int</span>, found <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> item.Less(s[i])</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; !s[i<span class="number">-1</span>].Less(item) &#123;</span><br><span class="line">		<span class="keyword">return</span> i - <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// children stores child nodes in a node.</span></span><br><span class="line"><span class="keyword">type</span> children []*node</span><br><span class="line"></span><br><span class="line"><span class="comment">// insertAt inserts a value into the given index, pushing all subsequent values</span></span><br><span class="line"><span class="comment">// forward.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *children)</span> <span class="title">insertAt</span><span class="params">(index <span class="keyword">int</span>, n *node)</span></span> &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(*s) &#123;</span><br><span class="line">		<span class="built_in">copy</span>((*s)[index+<span class="number">1</span>:], (*s)[index:])</span><br><span class="line">	&#125;</span><br><span class="line">	(*s)[index] = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeAt removes a value at a given index, pulling all subsequent values</span></span><br><span class="line"><span class="comment">// back.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *children)</span> <span class="title">removeAt</span><span class="params">(index <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	n := (*s)[index]</span><br><span class="line">	<span class="built_in">copy</span>((*s)[index:], (*s)[index+<span class="number">1</span>:])</span><br><span class="line">	(*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">	*s = (*s)[:<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop removes and returns the last element in the list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *children)</span> <span class="title">pop</span><span class="params">()</span> <span class="params">(out *node)</span></span> &#123;</span><br><span class="line">	index := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">	out = (*s)[index]</span><br><span class="line">	(*s)[index] = <span class="literal">nil</span></span><br><span class="line">	*s = (*s)[:index]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// truncate truncates this instance at index so that it contains only the</span></span><br><span class="line"><span class="comment">// first index children. index must be less than or equal to length.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *children)</span> <span class="title">truncate</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> toClear children</span><br><span class="line">	*s, toClear = (*s)[:index], (*s)[index:]</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(toClear) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		toClear = toClear[<span class="built_in">copy</span>(toClear, nilChildren):]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node is an internal node in a tree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It must at all times maintain the invariant that either</span></span><br><span class="line"><span class="comment">//   * len(children) == 0, len(items) unconstrained</span></span><br><span class="line"><span class="comment">//   * len(children) == len(items) + 1</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	items    items</span><br><span class="line">	children children</span><br><span class="line">	cow      *copyOnWriteContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">mutableFor</span><span class="params">(cow *copyOnWriteContext)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.cow == cow &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	out := cow.newNode()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span>(out.items) &gt;= <span class="built_in">len</span>(n.items) &#123;</span><br><span class="line">		out.items = out.items[:<span class="built_in">len</span>(n.items)]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		out.items = <span class="built_in">make</span>(items, <span class="built_in">len</span>(n.items), <span class="built_in">cap</span>(n.items))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(out.items, n.items)</span><br><span class="line">	<span class="comment">// Copy children</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span>(out.children) &gt;= <span class="built_in">len</span>(n.children) &#123;</span><br><span class="line">		out.children = out.children[:<span class="built_in">len</span>(n.children)]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		out.children = <span class="built_in">make</span>(children, <span class="built_in">len</span>(n.children), <span class="built_in">cap</span>(n.children))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(out.children, n.children)</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">mutableChild</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	c := n.children[i].mutableFor(n.cow)</span><br><span class="line">	n.children[i] = c</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split splits the given node at the given index.  The current node shrinks,</span></span><br><span class="line"><span class="comment">// and this function returns the item that existed at that index and a new node</span></span><br><span class="line"><span class="comment">// containing all items/children after it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">split</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(Item, *node)</span></span> &#123;</span><br><span class="line">	item := n.items[i]</span><br><span class="line">	next := n.cow.newNode()</span><br><span class="line">	next.items = <span class="built_in">append</span>(next.items, n.items[i+<span class="number">1</span>:]...)</span><br><span class="line">	n.items.truncate(i)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		next.children = <span class="built_in">append</span>(next.children, n.children[i+<span class="number">1</span>:]...)</span><br><span class="line">		n.children.truncate(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> item, next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maybeSplitChild checks if a child should be split, and if so splits it.</span></span><br><span class="line"><span class="comment">// Returns whether or not a split occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">maybeSplitChild</span><span class="params">(i, maxItems <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.children[i].items) &lt; maxItems &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	first := n.mutableChild(i)</span><br><span class="line">	item, second := first.split(maxItems / <span class="number">2</span>)</span><br><span class="line">	n.items.insertAt(i, item)</span><br><span class="line">	n.children.insertAt(i+<span class="number">1</span>, second)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert inserts an item into the subtree rooted at this node, making sure</span></span><br><span class="line"><span class="comment">// no nodes in the subtree exceed maxItems items.  Should an equivalent item be</span></span><br><span class="line"><span class="comment">// be found/replaced by insert, it will be returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insert</span><span class="params">(item Item, maxItems <span class="keyword">int</span>)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	i, found := n.items.find(item)</span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		out := n.items[i]</span><br><span class="line">		n.items[i] = item</span><br><span class="line">		<span class="keyword">return</span> out</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.items.insertAt(i, item)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.maybeSplitChild(i, maxItems) &#123;</span><br><span class="line">		inTree := n.items[i]</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> item.Less(inTree):</span><br><span class="line">			<span class="comment">// no change, we want first split node</span></span><br><span class="line">		<span class="keyword">case</span> inTree.Less(item):</span><br><span class="line">			i++ <span class="comment">// we want second split node</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			out := n.items[i]</span><br><span class="line">			n.items[i] = item</span><br><span class="line">			<span class="keyword">return</span> out</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.mutableChild(i).insert(item, maxItems)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get finds the given key in the subtree and returns it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">get</span><span class="params">(key Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	i, found := n.items.find(key)</span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		<span class="keyword">return</span> n.items[i]</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.children[i].get(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min returns the first item in the subtree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(n *node)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n = n.children[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.items) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.items[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max returns the last item in the subtree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(n *node)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n = n.children[<span class="built_in">len</span>(n.children)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.items) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.items[<span class="built_in">len</span>(n.items)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toRemove details what item to remove in a node.remove call.</span></span><br><span class="line"><span class="keyword">type</span> toRemove <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	removeItem toRemove = <span class="literal">iota</span> <span class="comment">// removes the given item</span></span><br><span class="line">	removeMin                  <span class="comment">// removes smallest item in the subtree</span></span><br><span class="line">	removeMax                  <span class="comment">// removes largest item in the subtree</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove removes an item from the subtree rooted at this node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">remove</span><span class="params">(item Item, minItems <span class="keyword">int</span>, typ toRemove)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> found <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">switch</span> typ &#123;</span><br><span class="line">	<span class="keyword">case</span> removeMax:</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.items.pop()</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="built_in">len</span>(n.items)</span><br><span class="line">	<span class="keyword">case</span> removeMin:</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n.items.removeAt(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> removeItem:</span><br><span class="line">		i, found = n.items.find(item)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> found &#123;</span><br><span class="line">				<span class="keyword">return</span> n.items.removeAt(i)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"invalid type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If we get to here, we have children.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.children[i].items) &lt;= minItems &#123;</span><br><span class="line">		<span class="keyword">return</span> n.growChildAndRemove(i, item, minItems, typ)</span><br><span class="line">	&#125;</span><br><span class="line">	child := n.mutableChild(i)</span><br><span class="line">	<span class="comment">// Either we had enough items to begin with, or we've done some</span></span><br><span class="line">	<span class="comment">// merging/stealing, because we've got enough now and we're ready to return</span></span><br><span class="line">	<span class="comment">// stuff.</span></span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		<span class="comment">// The item exists at index 'i', and the child we've selected can give us a</span></span><br><span class="line">		<span class="comment">// predecessor, since if we've gotten here it's got &gt; minItems items in it.</span></span><br><span class="line">		out := n.items[i]</span><br><span class="line">		<span class="comment">// We use our special-case 'remove' call with typ=maxItem to pull the</span></span><br><span class="line">		<span class="comment">// predecessor of item i (the rightmost leaf of our immediate left child)</span></span><br><span class="line">		<span class="comment">// and set it into where we pulled the item from.</span></span><br><span class="line">		n.items[i] = child.remove(<span class="literal">nil</span>, minItems, removeMax)</span><br><span class="line">		<span class="keyword">return</span> out</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Final recursive call.  Once we're here, we know that the item isn't in this</span></span><br><span class="line">	<span class="comment">// node and that the child is big enough to remove from.</span></span><br><span class="line">	<span class="keyword">return</span> child.remove(item, minItems, typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// growChildAndRemove grows child 'i' to make sure it's possible to remove an</span></span><br><span class="line"><span class="comment">// item from it while keeping it at minItems, then calls remove to actually</span></span><br><span class="line"><span class="comment">// remove it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Most documentation says we have to do two sets of special casing:</span></span><br><span class="line"><span class="comment">//   1) item is in this node</span></span><br><span class="line"><span class="comment">//   2) item is in child</span></span><br><span class="line"><span class="comment">// In both cases, we need to handle the two subcases:</span></span><br><span class="line"><span class="comment">//   A) node has enough values that it can spare one</span></span><br><span class="line"><span class="comment">//   B) node doesn't have enough values</span></span><br><span class="line"><span class="comment">// For the latter, we have to check:</span></span><br><span class="line"><span class="comment">//   a) left sibling has node to spare</span></span><br><span class="line"><span class="comment">//   b) right sibling has node to spare</span></span><br><span class="line"><span class="comment">//   c) we must merge</span></span><br><span class="line"><span class="comment">// To simplify our code here, we handle cases #1 and #2 the same:</span></span><br><span class="line"><span class="comment">// If a node doesn't have enough items, we make sure it does (using a,b,c).</span></span><br><span class="line"><span class="comment">// We then simply redo our remove call, and the second time (regardless of</span></span><br><span class="line"><span class="comment">// whether we're in case 1 or 2), we'll have enough items and can guarantee</span></span><br><span class="line"><span class="comment">// that we hit case A.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">growChildAndRemove</span><span class="params">(i <span class="keyword">int</span>, item Item, minItems <span class="keyword">int</span>, typ toRemove)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children[i<span class="number">-1</span>].items) &gt; minItems &#123;</span><br><span class="line">		<span class="comment">// Steal from left child</span></span><br><span class="line">		child := n.mutableChild(i)</span><br><span class="line">		stealFrom := n.mutableChild(i - <span class="number">1</span>)</span><br><span class="line">		stolenItem := stealFrom.items.pop()</span><br><span class="line">		child.items.insertAt(<span class="number">0</span>, n.items[i<span class="number">-1</span>])</span><br><span class="line">		n.items[i<span class="number">-1</span>] = stolenItem</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(stealFrom.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			child.children.insertAt(<span class="number">0</span>, stealFrom.children.pop())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.items) &amp;&amp; <span class="built_in">len</span>(n.children[i+<span class="number">1</span>].items) &gt; minItems &#123;</span><br><span class="line">		<span class="comment">// steal from right child</span></span><br><span class="line">		child := n.mutableChild(i)</span><br><span class="line">		stealFrom := n.mutableChild(i + <span class="number">1</span>)</span><br><span class="line">		stolenItem := stealFrom.items.removeAt(<span class="number">0</span>)</span><br><span class="line">		child.items = <span class="built_in">append</span>(child.items, n.items[i])</span><br><span class="line">		n.items[i] = stolenItem</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(stealFrom.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			child.children = <span class="built_in">append</span>(child.children, stealFrom.children.removeAt(<span class="number">0</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(n.items) &#123;</span><br><span class="line">			i--</span><br><span class="line">		&#125;</span><br><span class="line">		child := n.mutableChild(i)</span><br><span class="line">		<span class="comment">// merge with right child</span></span><br><span class="line">		mergeItem := n.items.removeAt(i)</span><br><span class="line">		mergeChild := n.children.removeAt(i + <span class="number">1</span>)</span><br><span class="line">		child.items = <span class="built_in">append</span>(child.items, mergeItem)</span><br><span class="line">		child.items = <span class="built_in">append</span>(child.items, mergeChild.items...)</span><br><span class="line">		child.children = <span class="built_in">append</span>(child.children, mergeChild.children...)</span><br><span class="line">		n.cow.freeNode(mergeChild)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n.remove(item, minItems, typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> direction <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	descend = direction(<span class="number">-1</span>)</span><br><span class="line">	ascend  = direction(+<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate provides a simple method for iterating over elements in the tree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When ascending, the 'start' should be less than 'stop' and when descending,</span></span><br><span class="line"><span class="comment">// the 'start' should be greater than 'stop'. Setting 'includeStart' to true</span></span><br><span class="line"><span class="comment">// will force the iterator to include the first item when it equals 'start',</span></span><br><span class="line"><span class="comment">// thus creating a "greaterOrEqual" or "lessThanEqual" rather than just a</span></span><br><span class="line"><span class="comment">// "greaterThan" or "lessThan" queries.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">iterate</span><span class="params">(dir direction, start, stop Item, includeStart <span class="keyword">bool</span>, hit <span class="keyword">bool</span>, iter ItemIterator)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok, found <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">switch</span> dir &#123;</span><br><span class="line">	<span class="keyword">case</span> ascend:</span><br><span class="line">		<span class="keyword">if</span> start != <span class="literal">nil</span> &#123;</span><br><span class="line">			index, _ = n.items.find(start)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := index; i &lt; <span class="built_in">len</span>(n.items); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> hit, ok = n.children[i].iterate(dir, start, stop, includeStart, hit, iter); !ok &#123;</span><br><span class="line">					<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !includeStart &amp;&amp; !hit &amp;&amp; start != <span class="literal">nil</span> &amp;&amp; !start.Less(n.items[i]) &#123;</span><br><span class="line">				hit = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			hit = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> stop != <span class="literal">nil</span> &amp;&amp; !n.items[i].Less(stop) &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !iter(n.items[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> hit, ok = n.children[<span class="built_in">len</span>(n.children)<span class="number">-1</span>].iterate(dir, start, stop, includeStart, hit, iter); !ok &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> descend:</span><br><span class="line">		<span class="keyword">if</span> start != <span class="literal">nil</span> &#123;</span><br><span class="line">			index, found = n.items.find(start)</span><br><span class="line">			<span class="keyword">if</span> !found &#123;</span><br><span class="line">				index = index - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			index = <span class="built_in">len</span>(n.items) - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := index; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">if</span> start != <span class="literal">nil</span> &amp;&amp; !n.items[i].Less(start) &#123;</span><br><span class="line">				<span class="keyword">if</span> !includeStart || hit || start.Less(n.items[i]) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> hit, ok = n.children[i+<span class="number">1</span>].iterate(dir, start, stop, includeStart, hit, iter); !ok &#123;</span><br><span class="line">					<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> stop != <span class="literal">nil</span> &amp;&amp; !stop.Less(n.items[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span> <span class="comment">//	continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			hit = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> !iter(n.items[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> hit, ok = n.children[<span class="number">0</span>].iterate(dir, start, stop, includeStart, hit, iter); !ok &#123;</span><br><span class="line">				<span class="keyword">return</span> hit, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hit, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Used for testing/debugging purposes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">print</span><span class="params">(w io.Writer, level <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"%sNODE:%v\n"</span>, strings.Repeat(<span class="string">"  "</span>, level), n.items)</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		c.<span class="built_in">print</span>(w, level+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BTree is an implementation of a B-Tree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// BTree stores Item instances in an ordered structure, allowing easy insertion,</span></span><br><span class="line"><span class="comment">// removal, and iteration.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write operations are not safe for concurrent mutation by multiple</span></span><br><span class="line"><span class="comment">// goroutines, but Read operations are.</span></span><br><span class="line"><span class="keyword">type</span> BTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	degree <span class="keyword">int</span></span><br><span class="line">	length <span class="keyword">int</span></span><br><span class="line">	root   *node</span><br><span class="line">	cow    *copyOnWriteContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copyOnWriteContext pointers determine node ownership... a tree with a write</span></span><br><span class="line"><span class="comment">// context equivalent to a node's write context is allowed to modify that node.</span></span><br><span class="line"><span class="comment">// A tree whose write context does not match a node's is not allowed to modify</span></span><br><span class="line"><span class="comment">// it, and must create a new, writable copy (IE: it's a Clone).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When doing any write operation, we maintain the invariant that the current</span></span><br><span class="line"><span class="comment">// node's context is equal to the context of the tree that requested the write.</span></span><br><span class="line"><span class="comment">// We do this by, before we descend into any node, creating a copy with the</span></span><br><span class="line"><span class="comment">// correct context if the contexts don't match.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since the node we're currently visiting on any write has the requesting</span></span><br><span class="line"><span class="comment">// tree's context, that node is modifiable in place.  Children of that node may</span></span><br><span class="line"><span class="comment">// not share context, but before we descend into them, we'll make a mutable</span></span><br><span class="line"><span class="comment">// copy.</span></span><br><span class="line"><span class="keyword">type</span> copyOnWriteContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	freelist *FreeList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone clones the btree, lazily.  Clone should not be called concurrently,</span></span><br><span class="line"><span class="comment">// but the original tree (t) and the new tree (t2) can be used concurrently</span></span><br><span class="line"><span class="comment">// once the Clone call completes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The internal tree structure of b is marked read-only and shared between t and</span></span><br><span class="line"><span class="comment">// t2.  Writes to both t and t2 use copy-on-write logic, creating new nodes</span></span><br><span class="line"><span class="comment">// whenever one of b's original nodes would have been modified.  Read operations</span></span><br><span class="line"><span class="comment">// should have no performance degredation.  Write operations for both t and t2</span></span><br><span class="line"><span class="comment">// will initially experience minor slow-downs caused by additional allocs and</span></span><br><span class="line"><span class="comment">// copies due to the aforementioned copy-on-write logic, but should converge to</span></span><br><span class="line"><span class="comment">// the original performance characteristics of the original tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Clone</span><span class="params">()</span> <span class="params">(t2 *BTree)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create two entirely new copy-on-write contexts.</span></span><br><span class="line">	<span class="comment">// This operation effectively creates three trees:</span></span><br><span class="line">	<span class="comment">//   the original, shared nodes (old b.cow)</span></span><br><span class="line">	<span class="comment">//   the new b.cow nodes</span></span><br><span class="line">	<span class="comment">//   the new out.cow nodes</span></span><br><span class="line">	cow1, cow2 := *t.cow, *t.cow</span><br><span class="line">	out := *t</span><br><span class="line">	t.cow = &amp;cow1</span><br><span class="line">	out.cow = &amp;cow2</span><br><span class="line">	<span class="keyword">return</span> &amp;out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxItems returns the max number of items to allow per node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">maxItems</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.degree*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// minItems returns the min number of items to allow per node (ignored for the</span></span><br><span class="line"><span class="comment">// root node).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">minItems</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.degree - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyOnWriteContext)</span> <span class="title">newNode</span><span class="params">()</span> <span class="params">(n *node)</span></span> &#123;</span><br><span class="line">	n = c.freelist.newNode()</span><br><span class="line">	n.cow = c</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> freeType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ftFreelistFull freeType = <span class="literal">iota</span> <span class="comment">// node was freed (available for GC, not stored in freelist)</span></span><br><span class="line">	ftStored                       <span class="comment">// node was stored in the freelist for later use</span></span><br><span class="line">	ftNotOwned                     <span class="comment">// node was ignored by COW, since it's owned by another one</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// freeNode frees a node within a given COW context, if it's owned by that</span></span><br><span class="line"><span class="comment">// context.  It returns what happened to the node (see freeType const</span></span><br><span class="line"><span class="comment">// documentation).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyOnWriteContext)</span> <span class="title">freeNode</span><span class="params">(n *node)</span> <span class="title">freeType</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.cow == c &#123;</span><br><span class="line">		<span class="comment">// clear to allow GC</span></span><br><span class="line">		n.items.truncate(<span class="number">0</span>)</span><br><span class="line">		n.children.truncate(<span class="number">0</span>)</span><br><span class="line">		n.cow = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> c.freelist.freeNode(n) &#123;</span><br><span class="line">			<span class="keyword">return</span> ftStored</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ftFreelistFull</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ftNotOwned</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReplaceOrInsert adds the given item to the tree.  If an item in the tree</span></span><br><span class="line"><span class="comment">// already equals the given one, it is removed from the tree and returned.</span></span><br><span class="line"><span class="comment">// Otherwise, nil is returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// nil cannot be added to the tree (will panic).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">ReplaceOrInsert</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"nil item being added to BTree"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.root = t.cow.newNode()</span><br><span class="line">		t.root.items = <span class="built_in">append</span>(t.root.items, item)</span><br><span class="line">		t.length++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.root = t.root.mutableFor(t.cow)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t.root.items) &gt;= t.maxItems() &#123;</span><br><span class="line">			item2, second := t.root.split(t.maxItems() / <span class="number">2</span>)</span><br><span class="line">			oldroot := t.root</span><br><span class="line">			t.root = t.cow.newNode()</span><br><span class="line">			t.root.items = <span class="built_in">append</span>(t.root.items, item2)</span><br><span class="line">			t.root.children = <span class="built_in">append</span>(t.root.children, oldroot, second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	out := t.root.insert(item, t.maxItems())</span><br><span class="line">	<span class="keyword">if</span> out == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.length++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete removes an item equal to the passed in item from the tree, returning</span></span><br><span class="line"><span class="comment">// it.  If no such item exists, returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Delete</span><span class="params">(item Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.deleteItem(item, removeItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteMin removes the smallest item in the tree and returns it.</span></span><br><span class="line"><span class="comment">// If no such item exists, returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">DeleteMin</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.deleteItem(<span class="literal">nil</span>, removeMin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteMax removes the largest item in the tree and returns it.</span></span><br><span class="line"><span class="comment">// If no such item exists, returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">DeleteMax</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.deleteItem(<span class="literal">nil</span>, removeMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">deleteItem</span><span class="params">(item Item, typ toRemove)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> || <span class="built_in">len</span>(t.root.items) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root = t.root.mutableFor(t.cow)</span><br><span class="line">	out := t.root.remove(item, t.minItems(), typ)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.root.items) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(t.root.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		oldroot := t.root</span><br><span class="line">		t.root = t.root.children[<span class="number">0</span>]</span><br><span class="line">		t.cow.freeNode(oldroot)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.length--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AscendRange calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [greaterOrEqual, lessThan), until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">AscendRange</span><span class="params">(greaterOrEqual, lessThan Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(ascend, greaterOrEqual, lessThan, <span class="literal">true</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AscendLessThan calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [first, pivot), until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">AscendLessThan</span><span class="params">(pivot Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(ascend, <span class="literal">nil</span>, pivot, <span class="literal">false</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AscendGreaterOrEqual calls the iterator for every value in the tree within</span></span><br><span class="line"><span class="comment">// the range [pivot, last], until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">AscendGreaterOrEqual</span><span class="params">(pivot Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(ascend, pivot, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ascend calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [first, last], until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Ascend</span><span class="params">(iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(ascend, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DescendRange calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [lessOrEqual, greaterThan), until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">DescendRange</span><span class="params">(lessOrEqual, greaterThan Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(descend, lessOrEqual, greaterThan, <span class="literal">true</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DescendLessOrEqual calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [pivot, first], until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">DescendLessOrEqual</span><span class="params">(pivot Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(descend, pivot, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DescendGreaterThan calls the iterator for every value in the tree within</span></span><br><span class="line"><span class="comment">// the range [last, pivot), until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">DescendGreaterThan</span><span class="params">(pivot Item, iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(descend, <span class="literal">nil</span>, pivot, <span class="literal">false</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Descend calls the iterator for every value in the tree within the range</span></span><br><span class="line"><span class="comment">// [last, first], until iterator returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Descend</span><span class="params">(iterator ItemIterator)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.root.iterate(descend, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>, iterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get looks for the key item in the tree, returning it.  It returns nil if</span></span><br><span class="line"><span class="comment">// unable to find that item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Get</span><span class="params">(key Item)</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.root.get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Min returns the smallest item in the tree, or nil if the tree is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Min</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> min(t.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max returns the largest item in the tree, or nil if the tree is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">Item</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> max(t.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has returns true if the given key is in the tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Has</span><span class="params">(key Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.Get(key) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len returns the number of items currently in the tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear removes all items from the btree.  If addNodesToFreelist is true,</span></span><br><span class="line"><span class="comment">// t's nodes are added to its freelist as part of this call, until the freelist</span></span><br><span class="line"><span class="comment">// is full.  Otherwise, the root node is simply dereferenced and the subtree</span></span><br><span class="line"><span class="comment">// left to Go's normal GC processes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This can be much faster</span></span><br><span class="line"><span class="comment">// than calling Delete on all elements, because that requires finding/removing</span></span><br><span class="line"><span class="comment">// each element in the tree and updating the tree accordingly.  It also is</span></span><br><span class="line"><span class="comment">// somewhat faster than creating a new tree to replace the old one, because</span></span><br><span class="line"><span class="comment">// nodes from the old tree are reclaimed into the freelist for use by the new</span></span><br><span class="line"><span class="comment">// one, instead of being lost to the garbage collector.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This call takes:</span></span><br><span class="line"><span class="comment">//   O(1): when addNodesToFreelist is false, this is a single operation.</span></span><br><span class="line"><span class="comment">//   O(1): when the freelist is already full, it breaks out immediately</span></span><br><span class="line"><span class="comment">//   O(freelist size):  when the freelist is empty and the nodes are all owned</span></span><br><span class="line"><span class="comment">//       by this tree, nodes are added to the freelist until full.</span></span><br><span class="line"><span class="comment">//   O(tree size):  when all nodes are owned by another tree, all nodes are</span></span><br><span class="line"><span class="comment">//       iterated over looking for nodes to add to the freelist, and due to</span></span><br><span class="line"><span class="comment">//       ownership, none are.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BTree)</span> <span class="title">Clear</span><span class="params">(addNodesToFreelist <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root != <span class="literal">nil</span> &amp;&amp; addNodesToFreelist &#123;</span><br><span class="line">		t.root.reset(t.cow)</span><br><span class="line">	&#125;</span><br><span class="line">	t.root, t.length = <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset returns a subtree to the freelist.  It breaks out immediately if the</span></span><br><span class="line"><span class="comment">// freelist is full, since the only benefit of iterating is to fill that</span></span><br><span class="line"><span class="comment">// freelist up.  Returns true if parent reset call should continue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">reset</span><span class="params">(c *copyOnWriteContext)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> !child.reset(c) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.freeNode(n) != ftFreelistFull</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Int implements the Item interface for integers.</span></span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns true if int(a) &lt; int(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Int)</span> <span class="title">Less</span><span class="params">(b Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b.(Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	seed := time.Now().Unix()</span><br><span class="line">	fmt.Println(seed)</span><br><span class="line">	rand.Seed(seed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// perm returns a random permutation of n Int items in the range [0, n).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perm</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(out []Item)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rand.Perm(n) &#123;</span><br><span class="line">		out = <span class="built_in">append</span>(out, Int(v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rang returns an ordered list of Int items in the range [0, n).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rang</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(out []Item)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		out = <span class="built_in">append</span>(out, Int(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all extracts all items from a tree in order as a slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(t *BTree)</span> <span class="params">(out []Item)</span></span> &#123;</span><br><span class="line">	t.Ascend(<span class="function"><span class="keyword">func</span><span class="params">(a Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		out = <span class="built_in">append</span>(out, a)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rangerev returns a reversed ordered list of Int items in the range [0, n).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangrev</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(out []Item)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		out = <span class="built_in">append</span>(out, Int(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allrev extracts all items from a tree in reverse order as a slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allrev</span><span class="params">(t *BTree)</span> <span class="params">(out []Item)</span></span> &#123;</span><br><span class="line">	t.Descend(<span class="function"><span class="keyword">func</span><span class="params">(a Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		out = <span class="built_in">append</span>(out, a)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	bTree := New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _,item := <span class="keyword">range</span> perm(<span class="number">100</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> x := bTree.ReplaceOrInsert(item); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"insert didn't find item"</span>, item)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(bTree.Min())</span><br><span class="line">	fmt.Println(bTree.Max())</span><br><span class="line">	fmt.Println(bTree.Len())</span><br><span class="line"></span><br><span class="line">	fmt.Println(bTree.DeleteMin())</span><br><span class="line">	fmt.Println(bTree.DeleteMax())</span><br><span class="line">	fmt.Println(bTree.Len())</span><br><span class="line"></span><br><span class="line">	fmt.Println(bTree.Get(Int(<span class="number">55</span>)))</span><br><span class="line">	fmt.Println(bTree.Has(Int(<span class="number">111</span>)))</span><br><span class="line">	fmt.Println(bTree.Delete(Int(<span class="number">98</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 升序遍历</span></span><br><span class="line">	bTree.Ascend(<span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	bTree.AscendRange(Int(<span class="number">10</span>),Int(<span class="number">20</span>), <span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 降序遍历</span></span><br><span class="line">	bTree.Descend(<span class="function"><span class="keyword">func</span><span class="params">(i Item)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="9-8-B-树"><a href="#9-8-B-树" class="headerlink" title="9.8 B+树"></a>9.8 B+树</h2><p><a href="https://github.com/timtadh/fs2" target="_blank" rel="noopener">https://github.com/timtadh/fs2</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	defaultOrder = <span class="number">4</span></span><br><span class="line">	minOrder     = <span class="number">3</span></span><br><span class="line">	maxOrder     = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	order          = defaultOrder</span><br><span class="line">	queue          *Node</span><br><span class="line">	verbose_output = <span class="literal">false</span></span><br><span class="line">	version        = <span class="number">0.1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BPlusTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	Root *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pointers []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Keys     []<span class="keyword">int</span></span><br><span class="line">	Parent   *Node</span><br><span class="line">	IsLeaf   <span class="keyword">bool</span></span><br><span class="line">	NumKeys  <span class="keyword">int</span></span><br><span class="line">	Next     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBPlusTree</span><span class="params">()</span> *<span class="title">BPlusTree</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BPlusTree&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">Insert</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pointer *Record</span><br><span class="line">	<span class="keyword">var</span> leaf *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := t.Find(key, <span class="literal">false</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"key already exists"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer, err := makeRecord(value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.Root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.startNewTree(key, pointer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leaf = t.findLeaf(key, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> leaf.NumKeys &lt; order<span class="number">-1</span> &#123;</span><br><span class="line">		insertIntoLeaf(leaf, key, pointer)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.insertIntoLeafAfterSplitting(leaf, key, pointer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">Find</span><span class="params">(key <span class="keyword">int</span>, verbose <span class="keyword">bool</span>)</span> <span class="params">(*Record, error)</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	c := t.findLeaf(key, verbose)</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"key not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; c.NumKeys; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> c.Keys[i] == key &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i == c.NumKeys &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"key not found"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r, _ := c.Pointers[i].(*Record)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">FindAndPrint</span><span class="params">(key <span class="keyword">int</span>, verbose <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	r, err := t.Find(key, verbose)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || r == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Record not found under key %d.\n"</span>, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Record at %d -- key %d, value %s.\n"</span>, r, key, r.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">FindAndPrintRange</span><span class="params">(keyStart, keyEnd <span class="keyword">int</span>, verbose <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	arraySize := keyEnd - keyStart + <span class="number">1</span></span><br><span class="line">	returnedKeys := <span class="built_in">make</span>([]<span class="keyword">int</span>, arraySize)</span><br><span class="line">	returnedPointers := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, arraySize)</span><br><span class="line">	numFound := t.findRange(keyStart, keyEnd, verbose, returnedKeys, returnedPointers)</span><br><span class="line">	<span class="keyword">if</span> numFound == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"None found,\n"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; numFound; i++ &#123;</span><br><span class="line">			c, _ := returnedPointers[i].(*Record)</span><br><span class="line">			fmt.Printf(<span class="string">"Key: %d  Location: %d  Value: %s\n"</span>,</span><br><span class="line">				returnedKeys[i],</span><br><span class="line">				returnedPointers[i],</span><br><span class="line">				c.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">PrintTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n *Node</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	rank := <span class="number">0</span></span><br><span class="line">	newRank := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.Root == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Empty tree.\n"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue = <span class="literal">nil</span></span><br><span class="line">	enqueue(t.Root)</span><br><span class="line">	<span class="keyword">for</span> queue != <span class="literal">nil</span> &#123;</span><br><span class="line">		n = dequeue()</span><br><span class="line">		<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> n.Parent != <span class="literal">nil</span> &amp;&amp; n == n.Parent.Pointers[<span class="number">0</span>] &#123;</span><br><span class="line">				newRank = t.pathToRoot(n)</span><br><span class="line">				<span class="keyword">if</span> newRank != rank &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> verbose_output &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"(%d)"</span>, n)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n.NumKeys; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> verbose_output &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"%d "</span>, n.Pointers[i])</span><br><span class="line">				&#125;</span><br><span class="line">				fmt.Printf(<span class="string">"%d "</span>, n.Keys[i])</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !n.IsLeaf &#123;</span><br><span class="line">				<span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= n.NumKeys; i++ &#123;</span><br><span class="line">					c, _ := n.Pointers[i].(*Node)</span><br><span class="line">					enqueue(c)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> verbose_output &#123;</span><br><span class="line">				<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"%d "</span>, n.Pointers[order<span class="number">-1</span>])</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"%d "</span>, n.Pointers[n.NumKeys])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">" | "</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">PrintLeaves</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.Root == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Empty tree.\n"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	c := t.Root</span><br><span class="line">	<span class="keyword">for</span> !c.IsLeaf &#123;</span><br><span class="line">		c, _ = c.Pointers[<span class="number">0</span>].(*Node)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; c.NumKeys; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> verbose_output &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"%d "</span>, c.Pointers[i])</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%d "</span>, c.Keys[i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> verbose_output &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%d "</span>, c.Pointers[order<span class="number">-1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> c.Pointers[order<span class="number">-1</span>] != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">" | "</span>)</span><br><span class="line">			c, _ = c.Pointers[order<span class="number">-1</span>].(*Node)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	keyRecord, err := t.Find(key, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	keyLeaf := t.findLeaf(key, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> keyRecord != <span class="literal">nil</span> &amp;&amp; keyLeaf != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.deleteEntry(keyLeaf, key, keyRecord)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Private Functions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(newNode *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c *Node</span><br><span class="line">	<span class="keyword">if</span> queue == <span class="literal">nil</span> &#123;</span><br><span class="line">		queue = newNode</span><br><span class="line">		queue.Next = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c = queue</span><br><span class="line">		<span class="keyword">for</span> c.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">			c = c.Next</span><br><span class="line">		&#125;</span><br><span class="line">		c.Next = newNode</span><br><span class="line">		newNode.Next = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	n := queue</span><br><span class="line">	queue = queue.Next</span><br><span class="line">	n.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">height</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	h := <span class="number">0</span></span><br><span class="line">	c := t.Root</span><br><span class="line">	<span class="keyword">for</span> !c.IsLeaf &#123;</span><br><span class="line">		c, _ = c.Pointers[<span class="number">0</span>].(*Node)</span><br><span class="line">		h++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">pathToRoot</span><span class="params">(child *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="number">0</span></span><br><span class="line">	c := child</span><br><span class="line">	<span class="keyword">for</span> c != t.Root &#123;</span><br><span class="line">		c = c.Parent</span><br><span class="line">		length += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">findRange</span><span class="params">(keyStart, keyEnd <span class="keyword">int</span>, verbose <span class="keyword">bool</span>, returnedKeys []<span class="keyword">int</span>, returnedPointers []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	numFound := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	n := t.findLeaf(keyStart, verbose)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n.NumKeys &amp;&amp; n.Keys[i] &lt; keyStart; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i == n.NumKeys &#123; <span class="comment">// could be wrong</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i = i; i &lt; n.NumKeys &amp;&amp; n.Keys[i] &lt;= keyEnd; i++ &#123;</span><br><span class="line">			returnedKeys[numFound] = n.Keys[i]</span><br><span class="line">			returnedPointers[numFound] = n.Pointers[i]</span><br><span class="line">			numFound += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		n, _ = n.Pointers[order<span class="number">-1</span>].(*Node)</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">findLeaf</span><span class="params">(key <span class="keyword">int</span>, verbose <span class="keyword">bool</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	c := t.Root</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> verbose &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Empty tree.\n"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> !c.IsLeaf &#123;</span><br><span class="line">		<span class="keyword">if</span> verbose &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"["</span>)</span><br><span class="line">			<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; c.NumKeys<span class="number">-1</span>; i++ &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"%d "</span>, c.Keys[i])</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%d]"</span>, c.Keys[i])</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; c.NumKeys &#123;</span><br><span class="line">			<span class="keyword">if</span> key &gt;= c.Keys[i] &#123;</span><br><span class="line">				i += <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> verbose &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%d -&gt;\n"</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		c, _ = c.Pointers[i].(*Node)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> verbose &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Leaf ["</span>)</span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; c.NumKeys<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%d "</span>, c.Keys[i])</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"%d] -&gt;\n"</span>, c.Keys[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cut</span><span class="params">(length <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> length%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> length / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> length/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	INSERTION</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeRecord</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Record, error)</span></span> &#123;</span><br><span class="line">	newRecord := <span class="built_in">new</span>(Record)</span><br><span class="line">	<span class="keyword">if</span> newRecord == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Error: Record creation."</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		newRecord.Value = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newRecord, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeNode</span><span class="params">()</span> <span class="params">(*Node, error)</span></span> &#123;</span><br><span class="line">	newNode := <span class="built_in">new</span>(Node)</span><br><span class="line">	<span class="keyword">if</span> newNode == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Error: Node creation."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newNode.Keys = <span class="built_in">make</span>([]<span class="keyword">int</span>, order<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> newNode.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Error: New node keys array."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newNode.Pointers = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, order)</span><br><span class="line">	<span class="keyword">if</span> newNode.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Error: New node pointers array."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newNode.IsLeaf = <span class="literal">false</span></span><br><span class="line">	newNode.NumKeys = <span class="number">0</span></span><br><span class="line">	newNode.Parent = <span class="literal">nil</span></span><br><span class="line">	newNode.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> newNode, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeLeaf</span><span class="params">()</span> <span class="params">(*Node, error)</span></span> &#123;</span><br><span class="line">	leaf, err := makeNode()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	leaf.IsLeaf = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> leaf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeftIndex</span><span class="params">(parent, left *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	leftIndex := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> leftIndex &lt;= parent.NumKeys &amp;&amp; parent.Pointers[leftIndex] != left &#123;</span><br><span class="line">		leftIndex += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> leftIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoLeaf</span><span class="params">(leaf *Node, key <span class="keyword">int</span>, pointer *Record)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, insertionPoint <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> insertionPoint &lt; leaf.NumKeys &amp;&amp; leaf.Keys[insertionPoint] &lt; key &#123;</span><br><span class="line">		insertionPoint += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = leaf.NumKeys; i &gt; insertionPoint; i-- &#123;</span><br><span class="line">		leaf.Keys[i] = leaf.Keys[i<span class="number">-1</span>]</span><br><span class="line">		leaf.Pointers[i] = leaf.Pointers[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	leaf.Keys[insertionPoint] = key</span><br><span class="line">	leaf.Pointers[insertionPoint] = pointer</span><br><span class="line">	leaf.NumKeys += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">insertIntoLeafAfterSplitting</span><span class="params">(leaf *Node, key <span class="keyword">int</span>, pointer *Record)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newLeaf *Node</span><br><span class="line">	<span class="keyword">var</span> insertionIndex, split, newKey, i, j <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	newLeaf, err = makeLeaf()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tempKeys := <span class="built_in">make</span>([]<span class="keyword">int</span>, order)</span><br><span class="line">	<span class="keyword">if</span> tempKeys == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"Error: Temporary keys array."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tempPointers := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, order)</span><br><span class="line">	<span class="keyword">if</span> tempPointers == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"Error: Temporary pointers array."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> insertionIndex &lt; order<span class="number">-1</span> &amp;&amp; leaf.Keys[insertionIndex] &lt; key &#123;</span><br><span class="line">		insertionIndex += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; leaf.NumKeys; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> j == insertionIndex &#123;</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		tempKeys[j] = leaf.Keys[i]</span><br><span class="line">		tempPointers[j] = leaf.Pointers[i]</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tempKeys[insertionIndex] = key</span><br><span class="line">	tempPointers[insertionIndex] = pointer</span><br><span class="line"></span><br><span class="line">	leaf.NumKeys = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	split = cut(order - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; split; i++ &#123;</span><br><span class="line">		leaf.Pointers[i] = tempPointers[i]</span><br><span class="line">		leaf.Keys[i] = tempKeys[i]</span><br><span class="line">		leaf.NumKeys += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = split; i &lt; order; i++ &#123;</span><br><span class="line">		newLeaf.Pointers[j] = tempPointers[i]</span><br><span class="line">		newLeaf.Keys[j] = tempKeys[i]</span><br><span class="line">		newLeaf.NumKeys += <span class="number">1</span></span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newLeaf.Pointers[order<span class="number">-1</span>] = leaf.Pointers[order<span class="number">-1</span>]</span><br><span class="line">	leaf.Pointers[order<span class="number">-1</span>] = newLeaf</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = leaf.NumKeys; i &lt; order<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		leaf.Pointers[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i = newLeaf.NumKeys; i &lt; order<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		newLeaf.Pointers[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newLeaf.Parent = leaf.Parent</span><br><span class="line">	newKey = newLeaf.Keys[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.insertIntoParent(leaf, newKey, newLeaf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoNode</span><span class="params">(n *Node, leftIndex, key <span class="keyword">int</span>, right *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i = n.NumKeys; i &gt; leftIndex; i-- &#123;</span><br><span class="line">		n.Pointers[i+<span class="number">1</span>] = n.Pointers[i]</span><br><span class="line">		n.Keys[i] = n.Keys[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	n.Pointers[leftIndex+<span class="number">1</span>] = right</span><br><span class="line">	n.Keys[leftIndex] = key</span><br><span class="line">	n.NumKeys += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">insertIntoNodeAfterSplitting</span><span class="params">(oldNode *Node, leftIndex, key <span class="keyword">int</span>, right *Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, j, split, kPrime <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> newNode, child *Node</span><br><span class="line">	<span class="keyword">var</span> tempKeys []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> tempPointers []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">	tempPointers = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, order+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> tempPointers == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"Error: Temporary pointers array for splitting nodes."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tempKeys = <span class="built_in">make</span>([]<span class="keyword">int</span>, order)</span><br><span class="line">	<span class="keyword">if</span> tempKeys == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"Error: Temporary keys array for splitting nodes."</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; oldNode.NumKeys+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> j == leftIndex+<span class="number">1</span> &#123;</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		tempPointers[j] = oldNode.Pointers[i]</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; oldNode.NumKeys; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> j == leftIndex &#123;</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		tempKeys[j] = oldNode.Keys[i]</span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tempPointers[leftIndex+<span class="number">1</span>] = right</span><br><span class="line">	tempKeys[leftIndex] = key</span><br><span class="line"></span><br><span class="line">	split = cut(order)</span><br><span class="line">	newNode, err = makeNode()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	oldNode.NumKeys = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; split<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		oldNode.Pointers[i] = tempPointers[i]</span><br><span class="line">		oldNode.Keys[i] = tempKeys[i]</span><br><span class="line">		oldNode.NumKeys += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldNode.Pointers[i] = tempPointers[i]</span><br><span class="line">	kPrime = tempKeys[split<span class="number">-1</span>]</span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i += <span class="number">1</span>; i &lt; order; i++ &#123;</span><br><span class="line">		newNode.Pointers[j] = tempPointers[i]</span><br><span class="line">		newNode.Keys[j] = tempKeys[i]</span><br><span class="line">		newNode.NumKeys += <span class="number">1</span></span><br><span class="line">		j += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	newNode.Pointers[j] = tempPointers[i]</span><br><span class="line">	newNode.Parent = oldNode.Parent</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= newNode.NumKeys; i++ &#123;</span><br><span class="line">		child, _ = newNode.Pointers[i].(*Node)</span><br><span class="line">		child.Parent = newNode</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.insertIntoParent(oldNode, kPrime, newNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">insertIntoParent</span><span class="params">(left *Node, key <span class="keyword">int</span>, right *Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> leftIndex <span class="keyword">int</span></span><br><span class="line">	parent := left.Parent</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.insertIntoNewRoot(left, key, right)</span><br><span class="line">	&#125;</span><br><span class="line">	leftIndex = getLeftIndex(parent, left)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> parent.NumKeys &lt; order<span class="number">-1</span> &#123;</span><br><span class="line">		insertIntoNode(parent, leftIndex, key, right)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> t.insertIntoNodeAfterSplitting(parent, leftIndex, key, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">insertIntoNewRoot</span><span class="params">(left *Node, key <span class="keyword">int</span>, right *Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	t.Root, err = makeNode()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	t.Root.Keys[<span class="number">0</span>] = key</span><br><span class="line">	t.Root.Pointers[<span class="number">0</span>] = left</span><br><span class="line">	t.Root.Pointers[<span class="number">1</span>] = right</span><br><span class="line">	t.Root.NumKeys += <span class="number">1</span></span><br><span class="line">	t.Root.Parent = <span class="literal">nil</span></span><br><span class="line">	left.Parent = t.Root</span><br><span class="line">	right.Parent = t.Root</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">startNewTree</span><span class="params">(key <span class="keyword">int</span>, pointer *Record)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	t.Root, err = makeLeaf()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	t.Root.Keys[<span class="number">0</span>] = key</span><br><span class="line">	t.Root.Pointers[<span class="number">0</span>] = pointer</span><br><span class="line">	t.Root.Pointers[order<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">	t.Root.Parent = <span class="literal">nil</span></span><br><span class="line">	t.Root.NumKeys += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNeighbourIndex</span><span class="params">(n *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= n.Parent.NumKeys; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> reflect.DeepEqual(n.Parent.Pointers[i], n) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeEntryFromNode</span><span class="params">(n *Node, key <span class="keyword">int</span>, pointer <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, numPointers <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n.Keys[i] != key &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i += <span class="number">1</span>; i &lt; n.NumKeys; i++ &#123;</span><br><span class="line">		n.Keys[i<span class="number">-1</span>] = n.Keys[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">		numPointers = n.NumKeys</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		numPointers = n.NumKeys + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n.Pointers[i] != pointer &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i += <span class="number">1</span>; i &lt; numPointers; i++ &#123;</span><br><span class="line">		n.Pointers[i<span class="number">-1</span>] = n.Pointers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	n.NumKeys -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">		<span class="keyword">for</span> i = n.NumKeys; i &lt; order<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			n.Pointers[i] = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i = n.NumKeys + <span class="number">1</span>; i &lt; order; i++ &#123;</span><br><span class="line">			n.Pointers[i] = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">adjustRoot</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newRoot *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> t.Root.NumKeys &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !t.Root.IsLeaf &#123;</span><br><span class="line">		newRoot, _ = t.Root.Pointers[<span class="number">0</span>].(*Node)</span><br><span class="line">		newRoot.Parent = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		newRoot = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	t.Root = newRoot</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">coalesceNodes</span><span class="params">(n, neighbour *Node, neighbourIndex, kPrime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, j, neighbourInsertionIndex, nEnd <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> tmp *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> neighbourIndex == <span class="number">-1</span> &#123;</span><br><span class="line">		tmp = n</span><br><span class="line">		n = neighbour</span><br><span class="line">		neighbour = tmp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	neighbourInsertionIndex = neighbour.NumKeys</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !n.IsLeaf &#123;</span><br><span class="line">		neighbour.Keys[neighbourInsertionIndex] = kPrime</span><br><span class="line">		neighbour.NumKeys += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		nEnd = n.NumKeys</span><br><span class="line">		i = neighbourInsertionIndex + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span>; j &lt; nEnd; j++ &#123;</span><br><span class="line">			neighbour.Keys[i] = n.Keys[j]</span><br><span class="line">			neighbour.Pointers[i] = n.Pointers[j]</span><br><span class="line">			neighbour.NumKeys += <span class="number">1</span></span><br><span class="line">			n.NumKeys -= <span class="number">1</span></span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		neighbour.Pointers[i] = n.Pointers[j]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; neighbour.NumKeys+<span class="number">1</span>; i++ &#123;</span><br><span class="line">			tmp, _ = neighbour.Pointers[i].(*Node)</span><br><span class="line">			tmp.Parent = neighbour</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i = neighbourInsertionIndex</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span>; j &lt; n.NumKeys; j++ &#123;</span><br><span class="line">			neighbour.Keys[i] = n.Keys[j]</span><br><span class="line">			n.Pointers[i] = n.Pointers[j]</span><br><span class="line">			neighbour.NumKeys += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		neighbour.Pointers[order<span class="number">-1</span>] = n.Pointers[order<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.deleteEntry(n.Parent, kPrime, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">redistributeNodes</span><span class="params">(n, neighbour *Node, neighbourIndex, kPrimeIndex, kPrime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> tmp *Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> neighbourIndex != <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !n.IsLeaf &#123;</span><br><span class="line">			n.Pointers[n.NumKeys+<span class="number">1</span>] = n.Pointers[n.NumKeys]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i = n.NumKeys; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			n.Keys[i] = n.Keys[i<span class="number">-1</span>]</span><br><span class="line">			n.Pointers[i] = n.Pointers[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !n.IsLeaf &#123; <span class="comment">// why the second if !n.IsLeaf</span></span><br><span class="line">			n.Pointers[<span class="number">0</span>] = neighbour.Pointers[neighbour.NumKeys]</span><br><span class="line">			tmp, _ = n.Pointers[<span class="number">0</span>].(*Node)</span><br><span class="line">			tmp.Parent = n</span><br><span class="line">			neighbour.Pointers[neighbour.NumKeys] = <span class="literal">nil</span></span><br><span class="line">			n.Keys[<span class="number">0</span>] = kPrime</span><br><span class="line">			n.Parent.Keys[kPrimeIndex] = neighbour.Keys[neighbour.NumKeys<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n.Pointers[<span class="number">0</span>] = neighbour.Pointers[neighbour.NumKeys<span class="number">-1</span>]</span><br><span class="line">			neighbour.Pointers[neighbour.NumKeys<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">			n.Keys[<span class="number">0</span>] = neighbour.Keys[neighbour.NumKeys<span class="number">-1</span>]</span><br><span class="line">			n.Parent.Keys[kPrimeIndex] = n.Keys[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">			n.Keys[n.NumKeys] = neighbour.Keys[<span class="number">0</span>]</span><br><span class="line">			n.Pointers[n.NumKeys] = neighbour.Pointers[<span class="number">0</span>]</span><br><span class="line">			n.Parent.Keys[kPrimeIndex] = neighbour.Keys[<span class="number">1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n.Keys[n.NumKeys] = kPrime</span><br><span class="line">			n.Pointers[n.NumKeys+<span class="number">1</span>] = neighbour.Pointers[<span class="number">0</span>]</span><br><span class="line">			tmp, _ = n.Pointers[n.NumKeys+<span class="number">1</span>].(*Node)</span><br><span class="line">			tmp.Parent = n</span><br><span class="line">			n.Parent.Keys[kPrimeIndex] = neighbour.Keys[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; neighbour.NumKeys<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			neighbour.Keys[i] = neighbour.Keys[i+<span class="number">1</span>]</span><br><span class="line">			neighbour.Pointers[i] = neighbour.Pointers[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !n.IsLeaf &#123;</span><br><span class="line">			neighbour.Pointers[i] = neighbour.Pointers[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n.NumKeys += <span class="number">1</span></span><br><span class="line">	neighbour.NumKeys -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *BPlusTree)</span> <span class="title">deleteEntry</span><span class="params">(n *Node, key <span class="keyword">int</span>, pointer <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> minKeys, neighbourIndex, kPrimeIndex, kPrime, capacity <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> neighbour *Node</span><br><span class="line"></span><br><span class="line">	n = removeEntryFromNode(n, key, pointer)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == t.Root &#123;</span><br><span class="line">		t.adjustRoot()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">		minKeys = cut(order - <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		minKeys = cut(order) - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.NumKeys &gt;= minKeys &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	neighbourIndex = getNeighbourIndex(n)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> neighbourIndex == <span class="number">-1</span> &#123;</span><br><span class="line">		kPrimeIndex = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kPrimeIndex = neighbourIndex</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kPrime = n.Parent.Keys[kPrimeIndex]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> neighbourIndex == <span class="number">-1</span> &#123;</span><br><span class="line">		neighbour, _ = n.Parent.Pointers[<span class="number">1</span>].(*Node)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		neighbour, _ = n.Parent.Pointers[neighbourIndex].(*Node)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.IsLeaf &#123;</span><br><span class="line">		capacity = order</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		capacity = order - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> neighbour.NumKeys+n.NumKeys &lt; capacity &#123;</span><br><span class="line">		t.coalesceNodes(n, neighbour, neighbourIndex, kPrime)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t.redistributeNodes(n, neighbour, neighbourIndex, kPrimeIndex, kPrime)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	tree := NewBPlusTree()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span>;i++ &#123;</span><br><span class="line">		err := tree.Insert(i, fmt.Sprintf(<span class="string">"test%d"</span>,i))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">100</span>;i++ &#123;</span><br><span class="line">		r, err := tree.Find(i, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(r.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// tree</span></span><br><span class="line">	fmt.Println(<span class="string">"================tree================"</span>)</span><br><span class="line">	tree.PrintTree()</span><br><span class="line">	<span class="comment">// leaves</span></span><br><span class="line">	fmt.Println(<span class="string">"================leaves================"</span>)</span><br><span class="line">	tree.PrintLeaves()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-图"><a href="#10-图" class="headerlink" title="10.图"></a>10.图</h1><h2 id="10-1-网"><a href="#10-1-网" class="headerlink" title="10.1 网"></a>10.1 网</h2><p>带权的图就是网</p>
<h2 id="10-2-图的存储结构"><a href="#10-2-图的存储结构" class="headerlink" title="10.2 图的存储结构"></a>10.2 图的存储结构</h2><h3 id="10-2-1-邻接矩阵-顺序存储"><a href="#10-2-1-邻接矩阵-顺序存储" class="headerlink" title="10.2.1 邻接矩阵(顺序存储)"></a>10.2.1 邻接矩阵(顺序存储)</h3><ol>
<li>顶点数组：存储顶点信息</li>
<li>边数组:存储顶点数组中2个顶点关系和权</li>
<li>图{顶点数组，边数组，顶点数，边数，图类型}</li>
</ol>
<p>不适合:查找顶点的度，需要扫描整张边数组，效率低，对顶点的相关操作 适合:对边依次进行处理的操作，</p>
<h3 id="10-2-2-邻接表-链式存储"><a href="#10-2-2-邻接表-链式存储" class="headerlink" title="10.2.2 邻接表(链式存储)"></a>10.2.2 邻接表(链式存储)</h3><ol>
<li>表头结点：存储顶点信息(data)和第一个邻接点地址(firstarc)，一般顺序存储在<strong>一个数组中</strong></li>
<li>表中结点：存储表头结点在数组中的位置和下一个结点的指针，可存储权值</li>
<li>图{表头结点数组，顶点数，边数，图类型}</li>
</ol>
<p>特点:</p>
<ol>
<li>出度为各自链表中的结点数，入度需要遍历整个表的结点，还有一种方法，求入度，建立一个逆邻接表</li>
<li>稀疏图存储时，比使用邻接矩阵节省空间</li>
</ol>
<h3 id="10-2-3-十字链表-链式存储"><a href="#10-2-3-十字链表-链式存储" class="headerlink" title="10.2.3 十字链表(链式存储)"></a>10.2.3 十字链表(链式存储)</h3><ol>
<li>顶点结点:存储顶点信息(data) 一个弧头结点指针(firstin)  一个弧尾结点指针(firstout)</li>
<li>弧结点:tailvex 和 headvex 分别存储的是弧尾和弧头对应的顶点在数组中的位置下标； hlink 和 tlink 为指针域，分别指向弧头相同的下一个弧和弧尾相同的下一个弧； info 为指针域，存储的是该弧具有的相关信息，例如权值等</li>
<li>图{顶点结点数组，弧数，顶点数}</li>
</ol>
<p>特点:</p>
<ol>
<li>存储的是有向图或者有向网</li>
<li>求入度出度方便，入度为弧头的数量，出度为弧尾的数量</li>
<li>程序中构建链表对于每个新初始化的结点采用头插法进行插入</li>
</ol>
<h3 id="10-2-4-邻接多重表-链式存储"><a href="#10-2-4-邻接多重表-链式存储" class="headerlink" title="10.2.4 邻接多重表(链式存储)"></a>10.2.4 邻接多重表(链式存储)</h3><p>邻接多重表可以看做是邻接表和十字链表的结合体</p>
<p>使用邻接表解决在无向图中删除某两个结点之间的边的操作时，由于表示边的结点分别处在两个顶点为头结点的链表中，所以需要都找到并删除，操作比较麻烦。处理类似这种操作，使用邻接多重表会更合适。</p>
<ol>
<li>表结点构成：</li>
</ol>
<p>mark 为标志域，作用是标记某结点是否已经被操作过，例如在遍历各结点时， mark 域为 0 表示还未遍历；mark 域为 1 表示该结点遍历过； ivex 和 jvex 分别表示该结点表示的边两端的顶点在数组中的位置下标； ilink 指向下一条与 ivex 相关的边； jlink 指向下一条与 jvex 相关的边； info 指向与该边相关的信息。</p>
<ol>
<li>顶点结点构成：</li>
</ol>
<p>data 为该顶点的数据域； firstedge 为指向第一条跟该顶点有关系的边。</p>
<h3 id="10-2-5-总结"><a href="#10-2-5-总结" class="headerlink" title="10.2.5 总结"></a>10.2.5 总结</h3><ol>
<li>邻接表适用于所有的图结构，无论是有向图（网）还是无向图（网），存储结构较为简单，但是在存储一些问题时，例如计算某顶点的度，需要通过遍历的方式自己求得</li>
<li>十字链表适用于有向图（网）的存储，使用该方式存储的有向图，可以很容易计算出顶点的出度和入度，只需要知道对应链表中的结点个数即可</li>
<li>邻接多重表适用于无向图（网）的存储，该方式避免了使用邻接表存储无向图时出现的存储空间浪费的现象，同时相比邻接表存储无向图，更方便了某些边操作（遍历、删除等）的实现</li>
</ol>
<h2 id="10-3-有向无向图"><a href="#10-3-有向无向图" class="headerlink" title="10.3 有向无向图"></a>10.3 有向无向图</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Infinity <span class="keyword">int</span> = <span class="number">65535</span> <span class="comment">//无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非线程安全</span></span><br><span class="line"><span class="keyword">type</span> VertexId <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertices []VertexId</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123;</span><br><span class="line">	From VertexId</span><br><span class="line">	To   VertexId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	edges      <span class="keyword">map</span>[VertexId]<span class="keyword">map</span>[VertexId]<span class="keyword">int</span></span><br><span class="line">	edgesCount <span class="keyword">int</span></span><br><span class="line">	isDirected <span class="keyword">bool</span> <span class="comment">//定向图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EdgesIterable <span class="keyword">interface</span> &#123;</span><br><span class="line">	EdgesIter() &lt;-<span class="keyword">chan</span> Edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VerticesIterable <span class="keyword">interface</span> &#123;</span><br><span class="line">	VerticesIter() &lt;-<span class="keyword">chan</span> VertexId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">EdgesIter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Edge</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Edge)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> from, connectedVertices := <span class="keyword">range</span> g.edges &#123;</span><br><span class="line">			<span class="keyword">for</span> to, _ := <span class="keyword">range</span> connectedVertices &#123;</span><br><span class="line">				<span class="keyword">if</span> g.isDirected &#123; <span class="comment">//有向边</span></span><br><span class="line">					ch &lt;- Edge&#123;from, to&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> from &lt; to &#123; <span class="comment">//无向边，只输出一次</span></span><br><span class="line">						ch &lt;- Edge&#123;from, to&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">VerticesIter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> VertexId)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> vertex, _ := <span class="keyword">range</span> g.edges &#123;</span><br><span class="line">			ch &lt;- vertex</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查顶点是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">CheckVertex</span><span class="params">(vertex VertexId)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	_, exists := g.edges[vertex]</span><br><span class="line">	<span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加顶点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">AddVertex</span><span class="params">(vertex VertexId)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckVertex(vertex) &#123;</span><br><span class="line">		g.edges[vertex] = <span class="built_in">make</span>(<span class="keyword">map</span>[VertexId]<span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"Vertex already exists"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除顶点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">RemoveVertex</span><span class="params">(vertex VertexId)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckVertex(vertex) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"unknow vertex"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先删除边</span></span><br><span class="line">	<span class="keyword">for</span> _to, _ := <span class="keyword">range</span> g.edges[vertex] &#123;</span><br><span class="line">		g.RemoveEdge(vertex, _to)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(g.edges, vertex)</span><br><span class="line">	<span class="keyword">for</span> _, connectedVertices := <span class="keyword">range</span> g.edges &#123;</span><br><span class="line">		<span class="built_in">delete</span>(connectedVertices, vertex)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计顶点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">VerticesCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(g.edges)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断边是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">CheckEdge</span><span class="params">(from, to VertexId)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := g.edges[from][to]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加边,存在就修改权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">AddEdge</span><span class="params">(from, to VertexId, weight <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//自身循环</span></span><br><span class="line">	<span class="keyword">if</span> from == to &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"cannot add self loop"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不存在边</span></span><br><span class="line">	<span class="keyword">if</span> !g.CheckVertex(from) || !g.CheckVertex(to) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"vertices not exist"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断边存在不</span></span><br><span class="line">	<span class="keyword">if</span> g.edges[from][to] &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"edge  exist"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	g.edges[from][to] = weight</span><br><span class="line">	<span class="keyword">if</span> !g.isDirected &#123;</span><br><span class="line">		g.edges[to][from] = weight</span><br><span class="line">	&#125;</span><br><span class="line">	g.edgesCount++</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">RemoveEdge</span><span class="params">(from, to VertexId)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//判断边是否存在</span></span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(from, to) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"edge not exist"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	<span class="built_in">delete</span>(g.edges[from], to)</span><br><span class="line">	<span class="keyword">if</span> !g.isDirected &#123;</span><br><span class="line">		<span class="built_in">delete</span>(g.edges[to], from)</span><br><span class="line">	&#125;</span><br><span class="line">	g.edgesCount--</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">EdgesCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.edgesCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取边权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">GetEdgeWeight</span><span class="params">(from, to VertexId)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(from, to) &#123;</span><br><span class="line">		<span class="keyword">return</span> Infinity</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g.edges[from][to]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取邻结点和权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">GetNeighbours</span><span class="params">(vertex VertexId)</span> <span class="title">VerticesIterable</span></span> &#123;</span><br><span class="line">	iterator := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> VertexId)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> connected, ok := g.edges[vertex]; ok &#123;</span><br><span class="line">				<span class="keyword">for</span> vid, _ := <span class="keyword">range</span> connected &#123;</span><br><span class="line">					ch &lt;- vid</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> VerticesIterable(&amp;VerticesIterableHelp&#123;iter: iterator&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//帮助获取</span></span><br><span class="line"><span class="keyword">type</span> VerticesIterableHelp <span class="keyword">struct</span> &#123;</span><br><span class="line">	iter <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VerticesIterableHelp)</span> <span class="title">VerticesIter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.iter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DirGraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	graph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================有向图=======================</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirected</span><span class="params">()</span> *<span class="title">DirGraph</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DirGraph&#123;</span><br><span class="line">		graph&#123;</span><br><span class="line">			edgesCount: <span class="number">0</span>,</span><br><span class="line">			edges:      <span class="built_in">make</span>(<span class="keyword">map</span>[VertexId]<span class="keyword">map</span>[VertexId]<span class="keyword">int</span>),</span><br><span class="line">			isDirected: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">GetPredecessors</span><span class="params">(vertex VertexId)</span> <span class="title">VerticesIterable</span></span> &#123;</span><br><span class="line">	iterator := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> VertexId)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> VertexId, _ := <span class="keyword">range</span> g.edges &#123;</span><br><span class="line">				<span class="keyword">if</span> g.CheckEdge(VertexId, vertex) &#123;</span><br><span class="line">					ch &lt;- VertexId</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> VerticesIterable(&amp;VerticesIterableHelp&#123;iter: iterator&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">GetSuccessors</span><span class="params">(vertex VertexId)</span> <span class="title">VerticesIterable</span></span> &#123;</span><br><span class="line">	iterator := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">VertexId</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> VertexId)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> connected, ok := g.edges[vertex]; ok &#123;</span><br><span class="line">				<span class="keyword">for</span> VertexId, _ := <span class="keyword">range</span> connected &#123;</span><br><span class="line">					<span class="keyword">if</span> g.CheckEdge(vertex, VertexId) &#123;</span><br><span class="line">						ch &lt;- VertexId</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> VerticesIterable(&amp;VerticesIterableHelp&#123;iter: iterator&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *DirGraph)</span> <span class="title">Reverse</span><span class="params">()</span> *<span class="title">DirGraph</span></span> &#123;</span><br><span class="line">	r := NewDirected()</span><br><span class="line"></span><br><span class="line">	vertices := g.VerticesIter()</span><br><span class="line">	<span class="keyword">for</span> vertex := <span class="keyword">range</span> vertices &#123;</span><br><span class="line">		r.AddVertex(vertex)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	edges := g.EdgesIter()</span><br><span class="line">	<span class="keyword">for</span> edge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		r.AddEdge(edge.To, edge.From, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//================无向图=======================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnGraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	graph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUndirected</span><span class="params">()</span> *<span class="title">UnGraph</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;UnGraph&#123;</span><br><span class="line">		graph&#123;</span><br><span class="line">			edgesCount: <span class="number">0</span>,</span><br><span class="line">			edges:      <span class="built_in">make</span>(<span class="keyword">map</span>[VertexId]<span class="keyword">map</span>[VertexId]<span class="keyword">int</span>),</span><br><span class="line">			isDirected: <span class="literal">false</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	TestNewUndirected()</span><br><span class="line">	TestNewDirected()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewUndirected</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := NewUndirected()</span><br><span class="line">	<span class="comment">//增加顶点</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		g.AddVertex(VertexId(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.VerticesCount() != <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"count err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//增加边</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		_ = g.AddEdge(VertexId(i), VertexId(i%<span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(<span class="number">2</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">2</span>, <span class="number">1</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.GetEdgeWeight(<span class="number">2</span>, <span class="number">0</span>) != <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除顶点</span></span><br><span class="line">	<span class="keyword">if</span> err := g.RemoveVertex(VertexId(<span class="number">2</span>));err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckVertex(VertexId(<span class="number">2</span>)) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">2</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//增加边，存在修改</span></span><br><span class="line">	<span class="keyword">if</span> err := g.AddEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(<span class="number">3</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除边</span></span><br><span class="line">	<span class="keyword">if</span> err := g.RemoveEdge(<span class="number">3</span>, <span class="number">0</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">3</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计边</span></span><br><span class="line">	c := g.EdgesIter()</span><br><span class="line">	countEdge := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _ = <span class="keyword">range</span> c &#123;</span><br><span class="line">		countEdge++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.EdgesCount() != countEdge &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewDirected</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := NewDirected()</span><br><span class="line">	<span class="comment">//增加顶点</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		g.AddVertex(VertexId(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.VerticesCount() != <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"count err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//增加边</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		g.AddEdge(VertexId(i), VertexId(i%<span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(<span class="number">2</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">2</span>, <span class="number">1</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.GetEdgeWeight(<span class="number">2</span>, <span class="number">0</span>) != <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除顶点</span></span><br><span class="line">	<span class="keyword">if</span> err := g.RemoveVertex(VertexId(<span class="number">2</span>));err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckVertex(VertexId(<span class="number">2</span>)) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">2</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//增加边，存在修改</span></span><br><span class="line">	<span class="keyword">if</span> err := g.AddEdge(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !g.CheckEdge(<span class="number">3</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除边</span></span><br><span class="line">	<span class="keyword">if</span> err := g.RemoveEdge(<span class="number">3</span>, <span class="number">0</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> g.CheckEdge(<span class="number">3</span>, <span class="number">0</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计边</span></span><br><span class="line">	c := g.EdgesIter()</span><br><span class="line">	countEdge := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _ = <span class="keyword">range</span> c &#123;</span><br><span class="line">		countEdge++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.EdgesCount() != countEdge &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看</span></span><br><span class="line">	<span class="comment">//for p := range g.EdgesIter() &#123;</span></span><br><span class="line">	<span class="comment">//	t.Log(p)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//入度</span></span><br><span class="line">	gp := g.GetPredecessors(VertexId(<span class="number">1</span>)).VerticesIter()</span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> gp &#123;</span><br><span class="line">		<span class="keyword">if</span> p != <span class="number">3</span> &amp;&amp; p != <span class="number">5</span> &amp;&amp; p != <span class="number">7</span> &amp;&amp; p != <span class="number">9</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> p := <span class="keyword">range</span> g.GetSuccessors(VertexId(<span class="number">4</span>)).VerticesIter() &#123;</span><br><span class="line">		<span class="keyword">if</span> p != VertexId(<span class="number">0</span>) &#123;</span><br><span class="line">			fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="11-最短路径"><a href="#11-最短路径" class="headerlink" title="11.最短路径"></a>11.最短路径</h1><h2 id="11-1-Dijkstra"><a href="#11-1-Dijkstra" class="headerlink" title="11.1 Dijkstra"></a>11.1 Dijkstra</h2><p> Dijkstra算法适用于边权为正的无向和有向图,不适用于有负边权的图 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	hp <span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> edge <span class="keyword">struct</span> &#123;</span><br><span class="line">	node   <span class="keyword">string</span></span><br><span class="line">	weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	nodes <span class="keyword">map</span>[<span class="keyword">string</span>][]edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGraph</span><span class="params">()</span> *<span class="title">graph</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;graph&#123;nodes: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]edge)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">addEdge</span><span class="params">(origin, destiny <span class="keyword">string</span>, weight <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	g.nodes[origin] = <span class="built_in">append</span>(g.nodes[origin], edge&#123;node: destiny, weight: weight&#125;)</span><br><span class="line">	g.nodes[destiny] = <span class="built_in">append</span>(g.nodes[destiny], edge&#123;node: origin, weight: weight&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">getEdges</span><span class="params">(node <span class="keyword">string</span>)</span> []<span class="title">edge</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.nodes[node]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span> <span class="title">Dijkstra</span><span class="params">(origin, destiny <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	h := newHeap()</span><br><span class="line">	h.push(path&#123;value: <span class="number">0</span>, nodes: []<span class="keyword">string</span>&#123;origin&#125;&#125;)</span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(*h.values) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Find the nearest yet to visit node</span></span><br><span class="line">		p := h.pop()</span><br><span class="line">		node := p.nodes[<span class="built_in">len</span>(p.nodes)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> visited[node] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> node == destiny &#123;</span><br><span class="line">			<span class="keyword">return</span> p.value, p.nodes</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> g.getEdges(node) &#123;</span><br><span class="line">			<span class="keyword">if</span> !visited[e.node] &#123;</span><br><span class="line">				<span class="comment">// We calculate the total spent so far plus the cost and the path of getting here</span></span><br><span class="line">				h.push(path&#123;value: p.value + e.weight, nodes: <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;&#125;, <span class="built_in">append</span>(p.nodes, e.node)...)&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		visited[node] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> path <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int</span></span><br><span class="line">	nodes []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> minPath []path</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minPath)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minPath)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i].value &lt; h[j].value &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minPath)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minPath)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minPath)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> heap <span class="keyword">struct</span> &#123;</span><br><span class="line">	values *minPath</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHeap</span><span class="params">()</span> *<span class="title">heap</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;heap&#123;values: &amp;minPath&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heap)</span> <span class="title">push</span><span class="params">(p path)</span></span> &#123;</span><br><span class="line">	hp.Push(h.values, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *heap)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">path</span></span> &#123;</span><br><span class="line">	i := hp.Pop(h.values)</span><br><span class="line">	<span class="keyword">return</span> i.(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Dijkstra"</span>)</span><br><span class="line">	<span class="comment">// Example</span></span><br><span class="line">	graph := newGraph()</span><br><span class="line">	graph.addEdge(<span class="string">"S"</span>, <span class="string">"B"</span>, <span class="number">4</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"S"</span>, <span class="string">"C"</span>, <span class="number">2</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">1</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">5</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">8</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"C"</span>, <span class="string">"E"</span>, <span class="number">10</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">2</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"D"</span>, <span class="string">"T"</span>, <span class="number">6</span>)</span><br><span class="line">	graph.addEdge(<span class="string">"E"</span>, <span class="string">"T"</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(graph.Dijkstra(<span class="string">"S"</span>, <span class="string">"T"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-2-Prim"><a href="#11-2-Prim" class="headerlink" title="11.2 Prim"></a>11.2 Prim</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="comment">//"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123;</span><br><span class="line">	src    Node</span><br><span class="line">	dst    Node</span><br><span class="line">	weight <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	edge    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span></span><br><span class="line">	nodeMap <span class="keyword">map</span>[<span class="keyword">string</span>]Node <span class="comment">// record all the node in a graph</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">	NodeID() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;node&#123;id: id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">NodeID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEdge</span><span class="params">(src Node, dst Node, w <span class="keyword">float64</span>)</span> *<span class="title">Edge</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Edge&#123;src: src, dst: dst, weight: w&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGraph</span><span class="params">()</span> *<span class="title">Graph</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Graph&#123;</span><br><span class="line">		edge:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>),</span><br><span class="line">		nodeMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Node),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span> <span class="title">AddEdge</span><span class="params">(nodeID1 <span class="keyword">string</span>, nodeID2 <span class="keyword">string</span>, w <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	g.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nodeID1 == nodeID2 &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"can't add same vertex in one edge"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"weight can't use 0"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// record each vertex</span></span><br><span class="line">	g.nodeMap[nodeID1] = NewNode(nodeID1)</span><br><span class="line">	g.nodeMap[nodeID2] = NewNode(nodeID2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := g.edge[nodeID1]; ok &#123;</span><br><span class="line">		g.edge[nodeID1][nodeID2] = w</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tempMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>)</span><br><span class="line">		tempMap[nodeID2] = w</span><br><span class="line">		g.edge[nodeID1] = tempMap</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := NewGraph()</span><br><span class="line">	g.AddEdge(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">7</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"A"</span>, <span class="string">"D"</span>, <span class="number">5</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">8</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="number">7</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"B"</span>, <span class="string">"D"</span>, <span class="number">9</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"B"</span>, <span class="string">"E"</span>, <span class="number">7</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"C"</span>, <span class="string">"B"</span>, <span class="number">8</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"C"</span>, <span class="string">"E"</span>, <span class="number">5</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"D"</span>, <span class="string">"A"</span>, <span class="number">5</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="number">9</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"D"</span>, <span class="string">"F"</span>, <span class="number">6</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"D"</span>, <span class="string">"E"</span>, <span class="number">15</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"D"</span>, <span class="string">"F"</span>, <span class="number">6</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"E"</span>, <span class="string">"B"</span>, <span class="number">7</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"E"</span>, <span class="string">"C"</span>, <span class="number">5</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"E"</span>, <span class="string">"D"</span>, <span class="number">15</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="number">8</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"E"</span>, <span class="string">"G"</span>, <span class="number">9</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="number">6</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"F"</span>, <span class="string">"E"</span>, <span class="number">8</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"F"</span>, <span class="string">"G"</span>, <span class="number">11</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"G"</span>, <span class="string">"E"</span>, <span class="number">9</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"G"</span>, <span class="string">"F"</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	g.Prim(<span class="string">"D"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span> <span class="title">Prim</span><span class="params">(src <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	knowNode := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	unknowNode := g.nodeMap</span><br><span class="line">	tempEdgeMap := g.edge</span><br><span class="line">	edgeMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Edge)</span><br><span class="line">	totalWeight := <span class="keyword">float64</span>(<span class="number">0</span>)</span><br><span class="line">	key := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	knowNode[key] = src</span><br><span class="line">	<span class="built_in">delete</span>(unknowNode, knowNode[key])</span><br><span class="line">	key++</span><br><span class="line">	<span class="keyword">var</span> temp <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到与knowNodeMap里节点权值最小的节点，并将该节点加入nodeMap</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(unknowNode) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		min := <span class="keyword">float64</span>(<span class="number">1000000</span>)</span><br><span class="line">		<span class="keyword">for</span> nodeID := <span class="keyword">range</span> unknowNode &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> knowNode &#123;</span><br><span class="line">				<span class="keyword">if</span> tempEdgeMap[nodeID][v] &lt; min &amp;&amp; tempEdgeMap[nodeID][v] != <span class="number">0</span> &#123;</span><br><span class="line">					min = tempEdgeMap[nodeID][v]</span><br><span class="line">					knowNode[key] = nodeID</span><br><span class="line">					temp = v</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n1 := NewNode(temp)</span><br><span class="line">		n2 := NewNode(knowNode[key])</span><br><span class="line">		edge := NewEdge(n1, n2, min)</span><br><span class="line">		edgeMap[key<span class="number">-1</span>] = edge</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从未知节点map删除已经找到的当前权值最小的节点</span></span><br><span class="line">		<span class="built_in">delete</span>(unknowNode, knowNode[key])</span><br><span class="line">		totalWeight += min</span><br><span class="line">		key++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(totalWeight)</span><br><span class="line">	fmt.Println(knowNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="11-3-Kruskal"><a href="#11-3-Kruskal" class="headerlink" title="11.3 Kruskal"></a>11.3 Kruskal</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"container/list"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edge is a connection bitween two vertecies. Every edge has a weight between the vertecies.</span></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123;</span><br><span class="line">	source <span class="keyword">string</span></span><br><span class="line">	sink   <span class="keyword">string</span></span><br><span class="line">	weight <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> edgeSlice []Edge</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e edgeSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e edgeSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e[i].weight &lt; e[j].weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e edgeSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	e[i], e[j] = e[j], e[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortEdges</span><span class="params">(edges []Edge)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> readyToSort edgeSlice = edges</span><br><span class="line">	sort.Sort(readyToSort)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Graph is a complete graph with vertecies and edges between them.</span></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	vertecies <span class="keyword">map</span>[<span class="keyword">string</span>][]Edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddVertex adds a vertex to the graph</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span> <span class="title">AddVertex</span><span class="params">(vertex <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	g.vertecies[vertex] = <span class="built_in">make</span>([]Edge, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddEdge adds an edge to the graph</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span> <span class="title">AddEdge</span><span class="params">(source <span class="keyword">string</span>, sink <span class="keyword">string</span>, weight <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">	edge := Edge&#123;source, sink, weight&#125;</span><br><span class="line">	g.vertecies[source] = <span class="built_in">append</span>(g.vertecies[source], edge)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph)</span> <span class="title">getVertecies</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> edges = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(g.vertecies))</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> g.vertecies &#123;</span><br><span class="line">		edges[i] = k</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> edges</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Graph)</span> <span class="title">getEdges</span><span class="params">(vertex <span class="keyword">string</span>)</span> <span class="params">([]Edge, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	edges, ok := g.vertecies[vertex]</span><br><span class="line">	<span class="keyword">return</span> edges, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vertexQueue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vq vertexQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>            &#123; <span class="keyword">return</span> <span class="built_in">len</span>(vq) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vq vertexQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span>  &#123; <span class="keyword">return</span> vq[i] &lt; vq[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vq vertexQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>       &#123; vq[i], vq[j] = vq[j], vq[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vq *vertexQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; *vq = <span class="built_in">append</span>(*vq, x.(<span class="keyword">string</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vq *vertexQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	items := *vq</span><br><span class="line">	n := <span class="built_in">len</span>(*vq)</span><br><span class="line">	x := items[n<span class="number">-1</span>]</span><br><span class="line">	*vq = items[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">graphContainsNoCycles</span><span class="params">(g traverseGraph, from, to <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> depthFirstSearch(g, from, to) == <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depthFirstSearch</span><span class="params">(g traverseGraph, from, to <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	verteciesNext := <span class="built_in">make</span>(vertexQueue, <span class="number">0</span>)</span><br><span class="line">	heap.Init(&amp;verteciesNext)</span><br><span class="line">	heap.Push(&amp;verteciesNext, from)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> verteciesNext.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		vertex := heap.Pop(&amp;verteciesNext).(<span class="keyword">string</span>)</span><br><span class="line">		edges, hasVertex := g.vertecies[vertex]</span><br><span class="line">		<span class="keyword">if</span> hasVertex &#123;</span><br><span class="line">			<span class="keyword">for</span> e := edges.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">				edge := e.Value.(Edge)</span><br><span class="line">				<span class="keyword">if</span> edge.sink == to &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				heap.Push(&amp;verteciesNext, edge.sink)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addUndirectedEdge</span><span class="params">(tg *traverseGraph, edge Edge)</span></span> &#123;</span><br><span class="line">	addEdge(tg, edge)</span><br><span class="line">	reverseEdge := Edge&#123;edge.sink, edge.source, edge.weight&#125;</span><br><span class="line">	addEdge(tg, reverseEdge)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addEdge</span><span class="params">(tg *traverseGraph, x Edge)</span></span> &#123;</span><br><span class="line">	edgesForVertex, hasVertex := tg.vertecies[x.source]</span><br><span class="line">	<span class="keyword">if</span> !hasVertex &#123;</span><br><span class="line">		edgesForVertex = list.New()</span><br><span class="line">		tg.vertecies[x.source] = edgesForVertex</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	edgesForVertex.PushBack(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUniqueEdges</span><span class="params">(g *Graph, vertecies []<span class="keyword">string</span>)</span> []<span class="title">Edge</span></span> &#123;</span><br><span class="line">	edges := <span class="built_in">make</span>([]Edge, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, vertex := <span class="keyword">range</span> vertecies &#123;</span><br><span class="line">		edgeInVertex, hasVertex := g.getEdges(vertex)</span><br><span class="line">		<span class="keyword">if</span> hasVertex &#123;</span><br><span class="line">			<span class="keyword">for</span> _, edge := <span class="keyword">range</span> edgeInVertex &#123;</span><br><span class="line">				has := <span class="literal">false</span></span><br><span class="line">				<span class="keyword">for</span> _, e := <span class="keyword">range</span> edges &#123;</span><br><span class="line">					has = has || e == edge</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> has == <span class="literal">false</span> &#123;</span><br><span class="line">					edges = <span class="built_in">append</span>(edges, edge)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> edges</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskals performs kruskal's algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kruskals</span><span class="params">(g *Graph)</span> []<span class="title">Edge</span></span> &#123;</span><br><span class="line">	vertecies := g.getVertecies()</span><br><span class="line">	numVertecies := <span class="built_in">len</span>(vertecies)</span><br><span class="line"></span><br><span class="line">	edges := getUniqueEdges(g, vertecies)</span><br><span class="line">	sortEdges(edges)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gCopy = createEmptyGraphWithVertecies(*g)</span><br><span class="line"></span><br><span class="line">	traversedVertecies := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	a := <span class="built_in">make</span>([]Edge, numVertecies<span class="number">-1</span>) <span class="comment">// resulting set</span></span><br><span class="line">	it := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, currentEdge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		_, hasSource := traversedVertecies[currentEdge.source]</span><br><span class="line">		_, hasSink := traversedVertecies[currentEdge.sink]</span><br><span class="line">		<span class="keyword">if</span> hasSource &amp;&amp; hasSink &#123;</span><br><span class="line">			<span class="keyword">if</span> graphContainsNoCycles(gCopy, currentEdge.source, currentEdge.sink) &#123;</span><br><span class="line">				a[it] = currentEdge</span><br><span class="line">				traversedVertecies[currentEdge.source] = <span class="literal">true</span></span><br><span class="line">				traversedVertecies[currentEdge.sink] = <span class="literal">true</span></span><br><span class="line">				addUndirectedEdge(&amp;gCopy, currentEdge)</span><br><span class="line">				it++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">"Dropped %v -&gt; %v"</span>, currentEdge.source, currentEdge.sink)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[it] = currentEdge</span><br><span class="line">			traversedVertecies[currentEdge.source] = <span class="literal">true</span></span><br><span class="line">			traversedVertecies[currentEdge.sink] = <span class="literal">true</span></span><br><span class="line">			addUndirectedEdge(&amp;gCopy, currentEdge)</span><br><span class="line">			it++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> it == numVertecies<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a new graph and assigns its values</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">Graph</span></span> &#123;</span><br><span class="line">	vertecies := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]Edge)</span><br><span class="line">	g := Graph&#123;vertecies&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> traverseGraph <span class="keyword">struct</span> &#123;</span><br><span class="line">	vertecies <span class="keyword">map</span>[<span class="keyword">string</span>]*list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createEmptyGraphWithVertecies</span><span class="params">(g Graph)</span> <span class="title">traverseGraph</span></span> &#123;</span><br><span class="line">	vertecies := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.List)</span><br><span class="line">	<span class="keyword">var</span> gCopy = traverseGraph&#123;vertecies&#125;</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> g.vertecies &#123;</span><br><span class="line">		traverseEdges := list.New()</span><br><span class="line">		gCopy.vertecies[k] = traverseEdges</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> gCopy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildExampleGraph</span><span class="params">()</span> <span class="title">Graph</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g = New()</span><br><span class="line">	<span class="keyword">var</span> vertecies = []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, vertex := <span class="keyword">range</span> vertecies &#123;</span><br><span class="line">		g.AddVertex(vertex)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.AddEdge(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">1</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">2</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="number">2</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"c"</span>, <span class="string">"d"</span>, <span class="number">8</span>)</span><br><span class="line">	g.AddEdge(<span class="string">"d"</span>, <span class="string">"a"</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := buildExampleGraph()</span><br><span class="line">	edges := Kruskals(&amp;g)</span><br><span class="line">	<span class="keyword">for</span> _, edge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		log.Printf(<span class="string">"Edge from %s to %s with cost %v"</span>, edge.source, edge.sink, edge.weight)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-LRU"><a href="#12-LRU" class="headerlink" title="12.LRU"></a>12.LRU</h1><p>LRU（Least Recently Used）是一种常见的页面置换算法，在计算中，所有的文件操作都要放在内存中进行，然而计算机内存大小是固定的，所以我们不可能把所有的文件都加载到内存，因此我们需要制定一种策略对加入到内存中的文件进项选择。</p>
<p>常见的页面置换算法有如下几种：</p>
<ul>
<li>LRU 最近最久未使用</li>
<li>FIFO 先进先出置换算法 类似队列</li>
<li>OPT 最佳置换算法 （理想中存在的）</li>
<li>NRU Clock置换算法</li>
<li>LFU 最少使用置换算法</li>
<li>PBA 页面缓冲算法</li>
</ul>
<p>LRU原理</p>
<p>LRU的设计原理就是，当数据在最近一段时间经常被访问，那么它在以后也会经常被访问。这就意味着，如果经常访问的数据，我们需要然其能够快速命中，而不常访问的数据，我们在容量超出限制内，要将其淘汰。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Wang YangYang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wangyangyangisme.github.io/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">http://wangyangyangisme.github.io/2019/11/22/algorithm-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wangyangyangisme.github.io" target="_blank">WangYangYang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/76bc52296bcf2e0b7a1d628106ffcd52.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/fab2285fdcd13ead0a8b4a853c659d03.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/26/frontend-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%BA%93%E6%94%B6%E9%9B%86/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/frontend/4b1cba54d3f6cd545f94bc3ef927e4f0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端常用库收集</div></div></a></div><div class="next-post pull_right"><a href="/2019/11/22/golang-go%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/golang/a91a19eff20b2bb042a7ea0c92dbfc4b.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">go知识图谱</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: false,
  appId: '49gEIIGN7uRbL6vHhieSpBzM-MdYXbMMI',
  appKey: 'uqts0urLKwikYQ0fKmIkMHBE',
  placeholder: '请留下你的脚印',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang YangYang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://wangyangyangisme.github.io/">blog</a>!</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/algolia.js"></script></body></html>