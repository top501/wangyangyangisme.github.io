<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Etcd应用 | WangYangYang</title><meta name="description" content="Etcd应用"><meta name="author" content="Wang YangYang"><meta name="copyright" content="Wang YangYang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Etcd应用"><meta name="twitter:description" content="Etcd应用"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/etcd/41896216ab5517c3b870d9ed6bb1b126.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Etcd应用"><meta property="og:url" content="http://wangyangyangisme.github.io/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/"><meta property="og:site_name" content="WangYangYang"><meta property="og:description" content="Etcd应用"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/etcd/41896216ab5517c3b870d9ed6bb1b126.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wangyangyangisme.github.io/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/"><link rel="prev" title="Etcd的简单使用" href="http://wangyangyangisme.github.io/2019/10/31/etcd-etcd%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"><link rel="next" title="GitBook工具生成PDF格式的文档" href="http://wangyangyangisme.github.io/2019/10/31/git-gitbook%E7%94%9F%E6%88%90pdf/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C4QN4OTLJM","apiKey":"c2c026ba64eeb77abd2164975fa41f34","indexName":"wyy","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://wangyangyangisme.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">190</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">38</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Etcd应用"><span class="toc-text">Etcd应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#经典应用场景"><span class="toc-text">经典应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景一：服务发现（Service-Discovery）"><span class="toc-text">场景一：服务发现（Service Discovery）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景二：消息发布与订阅"><span class="toc-text">场景二：消息发布与订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景三：负载均衡"><span class="toc-text">场景三：负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景四：分布式通知与协调"><span class="toc-text">场景四：分布式通知与协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景五：分布式锁"><span class="toc-text">场景五：分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景六：分布式队列"><span class="toc-text">场景六：分布式队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景七：集群监控与Leader竞选"><span class="toc-text">场景七：集群监控与Leader竞选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景八：为什么用etcd而不用ZooKeeper？"><span class="toc-text">场景八：为什么用etcd而不用ZooKeeper？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#etcd实现原理解读"><span class="toc-text">etcd实现原理解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-架构"><span class="toc-text">1 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-新版etcd重要变更列表"><span class="toc-text">2 新版etcd重要变更列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-etcd概念词汇表"><span class="toc-text">3 etcd概念词汇表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-集群化应用实践"><span class="toc-text">4 集群化应用实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-集群启动"><span class="toc-text">4.1 集群启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-静态配置"><span class="toc-text">4.1.1. 静态配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-etcd自发现模式"><span class="toc-text">4.1.2. etcd自发现模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-DNS自发现模式"><span class="toc-text">4.1.3. DNS自发现模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-关键部分源码解析"><span class="toc-text">4.2 关键部分源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-运行时节点变更"><span class="toc-text">4.3 运行时节点变更</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-节点迁移、替换"><span class="toc-text">4.3.1. 节点迁移、替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-节点增加"><span class="toc-text">4.3.2. 节点增加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-节点移除"><span class="toc-text">4.3.3. 节点移除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-强制性重启集群"><span class="toc-text">4.3.4. 强制性重启集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Proxy模式"><span class="toc-text">5 Proxy模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Proxy取代Standby模式的原因"><span class="toc-text">5.1 Proxy取代Standby模式的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-关键部分源码解析"><span class="toc-text">5.2 关键部分源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-数据存储"><span class="toc-text">6 数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-预写式日志（WAL）"><span class="toc-text">6.1 预写式日志（WAL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-关键部分源码解析"><span class="toc-text">6.2 关键部分源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Raft"><span class="toc-text">7 Raft</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-Raft常见问答一览"><span class="toc-text">7.1 Raft常见问答一览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-关键部分源码解析"><span class="toc-text">7.2 关键部分源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Store"><span class="toc-text">8 Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-总结"><span class="toc-text">9 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/etcd/41896216ab5517c3b870d9ed6bb1b126.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangYangYang</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Etcd应用</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-31<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-06</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/etcd/">etcd</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">14.5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 47 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Etcd应用"><a href="#Etcd应用" class="headerlink" title="Etcd应用"></a>Etcd应用</h1><p>随着CoreOS和Kubernetes等项目在开源社区日益火热，它们项目中都用到的etcd组件作为一个高可用强一致性的服务发现存储仓库，渐渐为开发人员所关注。在云计算时代，如何让服务快速透明地接入到计算集群中，如何让共享配置信息快速被集群中的所有机器发现，更为重要的是，如何构建这样一套高可用、安全、易于部署以及响应快速的服务集群，已经成为了迫切需要解决的问题。etcd为解决这类问题带来了福音，本文将从etcd的应用场景开始，深入解读etcd的实现方式，以供开发者们更为充分地享用etcd所带来的便利。</p>
<h2 id="经典应用场景"><a href="#经典应用场景" class="headerlink" title="经典应用场景"></a>经典应用场景</h2><p>要问etcd是什么？很多人第一反应可能是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。</p>
<blockquote>
<p><strong>A highly-available key value store for shared configuration and service discovery.</strong></p>
</blockquote>
<p>实际上，etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p>
<ul>
<li>简单：基于HTTP+JSON的API让你用curl就可以轻松使用。</li>
<li>安全：可选SSL客户认证机制。</li>
<li>快速：每个实例每秒支持一千次写操作。</li>
<li>可信：使用Raft算法充分实现了分布式。</li>
</ul>
<p>随着云计算的不断发展，分布式系统中涉及到的问题越来越受到人们重视。受阿里中间件团队对<a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="noopener">ZooKeeper典型应用场景一览</a>一文的启发，笔者根据自己的理解也总结了一些etcd的经典使用场景。让我们来看看etcd这个基于Raft强一致性算法的分布式存储仓库能给我们带来哪些帮助。</p>
<p>值得注意的是，分布式系统中的数据分为控制数据和应用数据。<strong>使用etcd的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况</strong>。</p>
<h3 id="场景一：服务发现（Service-Discovery）"><a href="#场景一：服务发现（Service-Discovery）" class="headerlink" title="场景一：服务发现（Service Discovery）"></a>场景一：服务发现（Service Discovery）</h3><p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。</p>
<ol>
<li><strong>一个强一致性、高可用的服务存储目录</strong>。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</li>
<li><strong>一种注册服务和监控服务健康状态的机制</strong>。用户可以在etcd中注册服务，并且对注册的服务设置<code>key TTL</code>，定时保持服务的心跳以达到监控健康状态的效果。</li>
<li><strong>一种查找和连接服务的机制</strong>。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。</li>
</ol>
<p><img src="/" alt="图1 服务发现示意图" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd1.jpg"></p>
<p>下面我们来看服务发现对应的具体场景。</p>
<ul>
<li><strong>微服务协同工作架构中，服务动态添加</strong>。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。</li>
</ul>
<p><img src="/" alt="图2 微服务协同工作" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd2.jpg"></p>
<ul>
<li><strong>PaaS平台中应用多实例与实例故障重启透明化</strong>。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。</li>
</ul>
<p><img src="/" alt="图3 云平台多实例透明化" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd3.jpg"></p>
<h3 id="场景二：消息发布与订阅"><a href="#场景二：消息发布与订阅" class="headerlink" title="场景二：消息发布与订阅"></a>场景二：消息发布与订阅</h3><p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p>
<ul>
<li><strong>应用中用到的一些配置信息放到etcd上进行集中管理</strong>。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</li>
<li>分布式搜索服务中，<strong>索引的元信息和服务器集群机器的节点状态存放在etcd中</strong>，供各个客户端订阅使用。使用etcd的<code>key TTL</code>功能可以确保机器状态是实时更新的。</li>
<li><strong>分布式日志收集系统</strong>。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</li>
<li><strong>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。</strong>通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。</li>
</ul>
<p><img src="/" alt="图4 消息发布与订阅" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd4.jpg"></p>
<h3 id="场景三：负载均衡"><a href="#场景三：负载均衡" class="headerlink" title="场景三：负载均衡"></a>场景三：负载均衡</h3><p>在<code>场景一</code>中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p>
<ul>
<li><strong>etcd本身分布式架构存储的信息访问支持负载均衡</strong>。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</li>
<li><strong>利用etcd维护一个负载均衡节点表</strong>。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。</li>
</ul>
<p><img src="/" alt="图5 负载均衡" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd5.jpg"></p>
<h3 id="场景四：分布式通知与协调"><a href="#场景四：分布式通知与协调" class="headerlink" title="场景四：分布式通知与协调"></a>场景四：分布式通知与协调</h3><p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p>
<ul>
<li><strong>通过etcd进行低耦合的心跳检测</strong>。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</li>
<li><strong>通过etcd完成系统调度</strong>。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</li>
<li><strong>通过etcd完成工作汇报</strong>。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。</li>
</ul>
<p><img src="/" alt="图6 分布式协同工作" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd6.jpg"></p>
<h3 id="场景五：分布式锁"><a href="#场景五：分布式锁" class="headerlink" title="场景五：分布式锁"></a>场景五：分布式锁</h3><p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
<ul>
<li><strong>保持独占即所有获取锁的用户最终只有一个可以得到</strong>。etcd为此提供了一套实现分布式锁原子操作CAS（<code>CompareAndSwap</code>）的API。通过设置<code>prevExist</code>值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</li>
<li>控制时序，即所有想要获得锁的用户都会被安排执行，但是<strong>获得锁的顺序也是全局唯一的，同时决定了执行顺序</strong>。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为<code>POST</code>动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</li>
</ul>
<p><img src="/" alt="图7 分布式锁" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd7.jpg"></p>
<h3 id="场景六：分布式队列"><a href="#场景六：分布式队列" class="headerlink" title="场景六：分布式队列"></a>场景六：分布式队列</h3><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p>
<p>另一种比较有意思的实现是<strong>在保证队列达到某个条件时再统一按顺序执行</strong>。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p>
<ul>
<li>condition可以<strong>表示队列大小</strong>。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li>
<li>condition可以<strong>表示某个任务在不在队列</strong>。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li>
<li>condition还可以<strong>表示其它的一类开始执行任务的通知</strong>。可以由控制程序指定，当condition出现变化时，开始执行队列任务。</li>
</ul>
<p><img src="/" alt="图8 分布式队列" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd8.jpg"></p>
<h3 id="场景七：集群监控与Leader竞选"><a href="#场景七：集群监控与Leader竞选" class="headerlink" title="场景七：集群监控与Leader竞选"></a>场景七：集群监控与Leader竞选</h3><p>通过etcd来进行监控实现起来非常简单并且实时性强。</p>
<ol>
<li>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。</li>
<li>节点可以设置<code>TTL key</code>，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。</li>
</ol>
<p>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p>
<p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p>
<p>这个的经典场景是<strong>搜索系统中建立全量索引</strong>。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。</p>
<p><img src="/" alt="图9 Leader竞选" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd9.jpg"></p>
<h3 id="场景八：为什么用etcd而不用ZooKeeper？"><a href="#场景八：为什么用etcd而不用ZooKeeper？" class="headerlink" title="场景八：为什么用etcd而不用ZooKeeper？"></a>场景八：为什么用etcd而不用ZooKeeper？</h3><p>阅读了<a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="noopener">“ZooKeeper典型应用场景一览”</a>一文的读者可能会发现，etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p>
<p>相较之下，ZooKeeper有如下缺点：</p>
<ol>
<li>复杂。ZooKeeper的<strong>部署维护复杂</strong>，管理员需要掌握一系列的知识和技能；而Paxos强一致性<strong>算法\</strong>也是素来以*<em>复杂*</em>难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li>
<li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于<strong>重型应用</strong>，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。</li>
<li><strong>发展缓慢</strong>。Apache基金会项目特有的<a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="noopener">“Apache Way”</a>在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ol>
<p>而etcd作为一个后起之秀，其优点也很明显。</p>
<ol>
<li>简单。使用Go语言编写<strong>部署简单</strong>；使用HTTP作为接口<strong>使用简单\</strong>；使用Raft算法保证强一致性让用户*<em>易于理解*</em>。</li>
<li><strong>数据持久化</strong>。etcd默认数据一更新就进行持久化。</li>
<li><strong>安全</strong>。etcd支持SSL客户端安全认证。</li>
</ol>
<p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p>
<h2 id="etcd实现原理解读"><a href="#etcd实现原理解读" class="headerlink" title="etcd实现原理解读"></a>etcd实现原理解读</h2><p>上一节中，我们概括了许多etcd的经典场景，这一节，我们将从etcd的架构开始，深入到源码中解析etcd。</p>
<h3 id="1-架构"><a href="#1-架构" class="headerlink" title="1 架构"></a>1 架构</h3><p><img src="/" alt="图10 etcd架构图" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd10.jpg"></p>
<p>从etcd的架构图中我们可以看到，etcd主要分为四个部分。</p>
<ul>
<li>HTTP Server： 用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</li>
<li>Store：用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</li>
<li>Raft：Raft强一致性算法的具体实现，是etcd的核心。</li>
<li>WAL：Write Ahead  Log（预写式日志），是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。Snapshot是为了防止数据过多而进行的状态快照；Entry表示存储的具体日志内容。</li>
</ul>
<p>通常，一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p>
<h3 id="2-新版etcd重要变更列表"><a href="#2-新版etcd重要变更列表" class="headerlink" title="2 新版etcd重要变更列表"></a>2 新版etcd重要变更列表</h3><ul>
<li>获得了IANA认证的端口，2379用于客户端通信，2380用于节点通信，与原先的（4001 peers / 7001 clients）共用。</li>
<li>每个节点可监听多个广播地址。监听的地址由原来的一个扩展到多个，用户可以根据需求实现更加复杂的集群环境，如一个是公网IP，一个是虚拟机（容器）之类的私有IP。</li>
<li>etcd可以代理访问leader节点的请求，所以如果你可以访问任何一个etcd节点，那么你就可以无视网络的拓扑结构对整个集群进行读写操作。</li>
<li>etcd集群和集群中的节点都有了自己独特的ID。这样就防止出现配置混淆，不是本集群的其他etcd节点发来的请求将被屏蔽。</li>
<li>etcd集群启动时的配置信息目前变为完全固定，这样有助于用户正确配置和启动。</li>
<li>运行时节点变化(Runtime Reconfiguration)。用户不需要重启 etcd 服务即可实现对 etcd 集群结构进行变更。启动后可以动态变更集群配置。</li>
<li>重新设计和实现了Raft算法，使得运行速度更快，更容易理解，包含更多测试代码。</li>
<li>Raft日志现在是严格的只能向后追加、预写式日志系统，并且在每条记录中都加入了CRC校验码。</li>
<li>启动时使用的_etcd/* 关键字不再暴露给用户</li>
<li>废弃集群自动调整功能的standby模式，这个功能使得用户维护集群更困难。</li>
<li>新增Proxy模式，不加入到etcd一致性集群中，纯粹进行代理转发。</li>
<li>ETCD_NAME（-name）参数目前是可选的，不再用于唯一标识一个节点。</li>
<li>摒弃通过配置文件配置 etcd 属性的方式，你可以用环境变量的方式代替。</li>
<li>通过自发现方式启动集群必须要提供集群大小，这样有助于用户确定集群实际启动的节点数量。</li>
</ul>
<h3 id="3-etcd概念词汇表"><a href="#3-etcd概念词汇表" class="headerlink" title="3 etcd概念词汇表"></a>3 etcd概念词汇表</h3><ul>
<li>Raft：etcd所采用的保证分布式系统强一致性的算法。</li>
<li>Node：一个Raft状态机实例。</li>
<li>Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。</li>
<li>Cluster：由多个Member构成可以协同工作的etcd集群。</li>
<li>Peer：对同一个etcd集群中另外一个Member的称呼。</li>
<li>Client： 向etcd集群发送HTTP请求的客户端。</li>
<li>WAL：预写式日志，etcd用于持久化存储的日志格式。</li>
<li>snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。</li>
<li>Proxy：etcd的一种模式，为etcd集群提供反向代理服务。</li>
<li>Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点。</li>
<li>Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。</li>
<li>Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选。</li>
<li>Term：某个节点成为Leader到下一次竞选时间，称为一个Term。</li>
<li>Index：数据项编号。Raft中通过Term和Index来定位数据。</li>
</ul>
<h3 id="4-集群化应用实践"><a href="#4-集群化应用实践" class="headerlink" title="4 集群化应用实践"></a>4 集群化应用实践</h3><p>etcd作为一个高可用键值存储系统，天生就是为集群化而设计的。由于Raft算法在做决策时需要多数节点的投票，所以etcd一般部署集群推荐奇数个节点，推荐的数量为3、5或者7个节点构成一个集群。</p>
<h4 id="4-1-集群启动"><a href="#4-1-集群启动" class="headerlink" title="4.1 集群启动"></a>4.1 集群启动</h4><p>etcd有三种集群化启动的配置方案，分别为静态配置启动、etcd自身服务发现、通过DNS进行服务发现。</p>
<p><strong>通过配置内容的不同，你可以对不同的方式进行选择。值得一提的是，这也是新版etcd区别于旧版的一大特性，它摒弃了使用配置文件进行参数配置的做法，转而使用命令行参数或者环境变量的做法来配置参数。</strong></p>
<h5 id="4-1-1-静态配置"><a href="#4-1-1-静态配置" class="headerlink" title="4.1.1. 静态配置"></a>4.1.1. 静态配置</h5><p>这种方式比较适用于离线环境，在启动整个集群之前，你就已经预先清楚所要配置的集群大小，以及集群上各节点的地址和端口信息。那么启动时，你就可以通过配置<code>initial-cluster</code>参数进行etcd集群的启动。</p>
<p>在每个etcd机器启动时，配置环境变量或者添加启动参数的方式如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETCD_INITIAL_CLUSTER="infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=new</span><br></pre></td></tr></table></figure>

<p>参数方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-initial-cluster </span><br><span class="line">infra0=http://10.0.1.10:2380,http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="line"> -initial-cluster-state new</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是</strong>，<code>-initial-cluster</code>参数中配置的url地址必须与各个节点启动时设置的<code>initial-advertise-peer-urls</code>参数相同。（<code>initial-advertise-peer-urls</code>参数表示节点监听其他节点同步信号的地址）</p>
<p>如果你所在的网络环境配置了多个etcd集群，为了避免意外发生，最好使用<code>-initial-cluster-token</code>参数为每个集群单独配置一个token认证。这样就可以确保每个集群和集群的成员都拥有独特的ID。</p>
<p>综上所述，如果你要配置包含3个etcd节点的集群，那么你在三个机器上的启动命令分别如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd -name infra0 -initial-advertise-peer-urls http://10.0.1.10:2380 \</span></span><br><span class="line">  -listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  -initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  -initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="line">  -initial-cluster-state new</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> etcd -name infra1 -initial-advertise-peer-urls http://10.0.1.11:2380 \</span></span><br><span class="line">  -listen-peer-urls http://10.0.1.11:2380 \</span><br><span class="line">  -initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  -initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="line">  -initial-cluster-state new</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> etcd -name infra2 -initial-advertise-peer-urls http://10.0.1.12:2380 \</span></span><br><span class="line">  -listen-peer-urls http://10.0.1.12:2380 \</span><br><span class="line">  -initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  -initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="line">  -initial-cluster-state new</span><br></pre></td></tr></table></figure>

<p>在初始化完成后，etcd还提供动态增、删、改etcd集群节点的功能，这个需要用到<code>etcdctl</code>命令进行操作。</p>
<h5 id="4-1-2-etcd自发现模式"><a href="#4-1-2-etcd自发现模式" class="headerlink" title="4.1.2. etcd自发现模式"></a>4.1.2. etcd自发现模式</h5><p>通过自发现的方式启动etcd集群需要事先准备一个etcd集群。如果你已经有一个etcd集群，首先你可以执行如下命令设定集群的大小，假设为3.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X PUT http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83/_config/size -d value=3</span></span><br></pre></td></tr></table></figure>

<p>然后你要把这个url地址<code>http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code>作为<code>-discovery</code>参数来启动etcd。节点会自动使用<code>http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code>目录进行etcd的注册和发现服务。</p>
<p>所以最终你在某个机器上启动etcd的命令如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd -name infra0 -initial-advertise-peer-urls http://10.0.1.10:2380 \</span></span><br><span class="line">  -listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  -discovery http://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</span><br></pre></td></tr></table></figure>

<p>如果你本地没有可用的etcd集群，etcd官网提供了一个可以公网访问的etcd存储地址。你可以通过如下命令得到etcd服务的目录，并把它作为<code>-discovery</code>参数使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://discovery.etcd.io/new?size=3</span></span><br><span class="line">http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</span><br></pre></td></tr></table></figure>

<p>同样的，当你完成了集群的初始化后，这些信息就失去了作用。当你需要增加节点时，需要使用<code>etcdctl</code>来进行操作。</p>
<p>为了安全，请务必每次启动新etcd集群时，都使用新的discovery token进行注册。另外，如果你初始化时启动的节点超过了指定的数量，多余的节点会自动转化为Proxy模式的etcd。</p>
<h5 id="4-1-3-DNS自发现模式"><a href="#4-1-3-DNS自发现模式" class="headerlink" title="4.1.3. DNS自发现模式"></a>4.1.3. DNS自发现模式</h5><p>etcd还支持使用DNS SRV记录进行启动。关于DNS SRV记录如何进行服务发现，可以参阅<a href="http://tools.ietf.org/html/rfc2782" target="_blank" rel="noopener">RFC2782</a>，所以，你要在DNS服务器上进行相应的配置。</p>
<p>(1) 开启DNS服务器上SRV记录查询，并添加相应的域名记录，使得查询到的结果类似如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dig +noall +answer SRV _etcd-server._tcp.example.com</span></span><br><span class="line">_etcd-server._tcp.example.com. 300 IN   SRV 0 0 2380 infra0.example.com.</span><br><span class="line">_etcd-server._tcp.example.com. 300 IN   SRV 0 0 2380 infra1.example.com.</span><br><span class="line">_etcd-server._tcp.example.com. 300 IN   SRV 0 0 2380 infra2.example.com.</span><br></pre></td></tr></table></figure>

<p>(2) 分别为各个域名配置相关的A记录指向etcd核心节点对应的机器IP。使得查询结果类似如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dig +noall +answer infra0.example.com infra1.example.com infra2.example.com</span></span><br><span class="line">infra0.example.com. 300 IN  A   10.0.1.10</span><br><span class="line">infra1.example.com. 300 IN  A   10.0.1.11</span><br><span class="line">infra2.example.com. 300 IN  A   10.0.1.12</span><br></pre></td></tr></table></figure>

<p>做好了上述两步DNS的配置，就可以使用DNS启动etcd集群了。配置DNS解析的url参数为<code>-discovery-srv</code>，其中某一个节点地启动命令如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd -name infra0 \</span></span><br><span class="line">-discovery-srv example.com \</span><br><span class="line">-initial-advertise-peer-urls http://infra0.example.com:2380 \</span><br><span class="line">-initial-cluster-token etcd-cluster-1 \</span><br><span class="line">-initial-cluster-state new \</span><br><span class="line">-advertise-client-urls http://infra0.example.com:2379 \</span><br><span class="line">-listen-client-urls http://infra0.example.com:2379 \</span><br><span class="line">-listen-peer-urls http://infra0.example.com:2380</span><br></pre></td></tr></table></figure>

<p>当然，你也可以直接把节点的域名改成IP来启动。</p>
<h4 id="4-2-关键部分源码解析"><a href="#4-2-关键部分源码解析" class="headerlink" title="4.2 关键部分源码解析"></a>4.2 关键部分源码解析</h4><p>etcd的启动是从主目录下的<code>main.go</code>开始的，然后进入<code>etcdmain/etcd.go</code>，载入配置参数。如果被配置为Proxy模式，则进入startProxy函数，否则进入startEtcd，开启etcd服务模块和http请求处理模块。</p>
<p>在启动http监听时，为了保持与集群其他etcd机器（peers）保持连接，都采用的<code>transport.NewTimeoutListener</code>启动方式，这样在超过指定时间没有获得响应时就会出现超时错误。而在监听client请求时，采用的是<code>transport.NewKeepAliveListener</code>，有助于连接的稳定。</p>
<p>在<code>etcdmain/etcd.go</code>中的setupCluster函数可以看到，根据不同etcd的参数，启动集群的方法略有不同，但是最终需要的就是一个IP与端口构成的字符串。</p>
<p>在静态配置的启动方式中，集群的所有信息都已经在给出，所以直接解析用逗号隔开的集群url信息就好了。</p>
<p>DNS发现的方式类似，会预先发送一个tcp的SRV请求，先查看<code>etcd-server-ssl._tcp.example.com</code>下是否有集群的域名信息，如果没有找到，则去查看<code>etcd-server._tcp.example.com</code>。根据找到的域名，解析出对应的IP和端口，即集群的url信息。</p>
<p>较为复杂是etcd式的自发现启动。首先就用自身单个的url构成一个集群，然后在启动的过程中根据参数进入<code>discovery/discovery.go</code>源码的<code>JoinCluster</code>函数。因为我们事先是知道启动时使用的etcd的token地址的，里面包含了集群大小(size)信息。在这个过程其实是个不断监测与等待的过程。启动的第一步就是在这个etcd的token目录下注册自身的信息，然后再监测token目录下所有节点的数量，如果数量没有达标，则循环等待。当数量达到要求时，才结束，进入正常的启动过程。</p>
<p>配置etcd过程中通常要用到两种url地址容易混淆，一种用于etcd集群同步信息并保持连接，通常称为peer-urls；另外一种用于接收用户端发来的HTTP请求，通常称为client-urls。</p>
<ul>
<li><code>peer-urls</code>：通常监听的端口为<code>2380</code>（老版本使用的端口为<code>7001</code>），包括所有已经在集群中正常工作的所有节点的地址。</li>
<li><code>client-urls</code>：通常监听的端口为<code>2379</code>（老版本使用的端口为<code>4001</code>），为适应复杂的网络环境，新版etcd监听客户端请求的url从原来的1个变为现在可配置的多个。这样etcd可以配合多块网卡同时监听不同网络下的请求。</li>
</ul>
<h4 id="4-3-运行时节点变更"><a href="#4-3-运行时节点变更" class="headerlink" title="4.3 运行时节点变更"></a>4.3 运行时节点变更</h4><p>etcd集群启动完毕后，可以在运行的过程中对集群进行重构，包括核心节点的增加、删除、迁移、替换等。<strong>运行时重构使得etcd集群无须重启即可改变集群的配置，这也是新版etcd区别于旧版包含的新特性。</strong></p>
<p>只有当集群中多数节点正常的情况下，你才可以进行运行时的配置管理。因为配置更改的信息也会被etcd当成一个信息存储和同步，如果集群多数节点损坏，集群就失去了写入数据的能力。所以在配置etcd集群数量时，强烈推荐至少配置3个核心节点。</p>
<h5 id="4-3-1-节点迁移、替换"><a href="#4-3-1-节点迁移、替换" class="headerlink" title="4.3.1. 节点迁移、替换"></a>4.3.1. 节点迁移、替换</h5><p>当你节点所在的机器出现硬件故障，或者节点出现如数据目录损坏等问题，导致节点永久性的不可恢复时，就需要对节点进行迁移或者替换。当一个节点失效以后，必须尽快修复，因为etcd集群正常运行的必要条件是集群中多数节点都正常工作。</p>
<p>迁移一个节点需要进行四步操作：</p>
<ul>
<li>暂停正在运行着的节点程序进程</li>
<li>把数据目录从现有机器拷贝到新机器</li>
<li>使用api更新etcd中对应节点指向机器的url记录更新为新机器的ip</li>
<li>使用同样的配置项和数据目录，在新的机器上启动etcd。</li>
</ul>
<h5 id="4-3-2-节点增加"><a href="#4-3-2-节点增加" class="headerlink" title="4.3.2. 节点增加"></a>4.3.2. 节点增加</h5><p>增加节点可以让etcd的高可用性更强。举例来说，如果你有3个节点，那么最多允许1个节点失效；当你有5个节点时，就可以允许有2个节点失效。同时，增加节点还可以让etcd集群具有更好的读性能。因为etcd的节点都是实时同步的，每个节点上都存储了所有的信息，所以增加节点可以从整体上提升读的吞吐量。</p>
<p>增加一个节点需要进行两步操作：</p>
<ul>
<li>在集群中添加这个节点的url记录，同时获得集群的信息。</li>
<li>使用获得的集群信息启动新etcd节点。</li>
</ul>
<h5 id="4-3-3-节点移除"><a href="#4-3-3-节点移除" class="headerlink" title="4.3.3. 节点移除"></a>4.3.3. 节点移除</h5><p>有时你不得不在提高etcd的写性能和增加集群高可用性上进行权衡。Leader节点在提交一个写记录时，会把这个消息同步到每个节点上，当得到多数节点的同意反馈后，才会真正写入数据。所以节点越多，写入性能越差。在节点过多时，你可能需要移除一个或多个。</p>
<p>移除节点非常简单，只需要一步操作，就是把集群中这个节点的记录删除。然后对应机器上的该节点就会自动停止。</p>
<h5 id="4-3-4-强制性重启集群"><a href="#4-3-4-强制性重启集群" class="headerlink" title="4.3.4. 强制性重启集群"></a>4.3.4. 强制性重启集群</h5><p>当集群超过半数的节点都失效时，就需要通过手动的方式，强制性让某个节点以自己为Leader，利用原有数据启动一个新集群。</p>
<p>此时你需要进行两步操作。</p>
<ul>
<li>备份原有数据到新机器。</li>
<li>使用<code>-force-new-cluster</code>加备份的数据重新启动节点</li>
</ul>
<p><strong>注意：强制性重启是一个迫不得已的选择，它会破坏一致性协议保证的安全性（如果操作时集群中尚有其它节点在正常工作，就会出错），所以在操作前请务必要保存好数据。</strong></p>
<h3 id="5-Proxy模式"><a href="#5-Proxy模式" class="headerlink" title="5 Proxy模式"></a>5 Proxy模式</h3><p><strong>Proxy模式也是新版etcd的一个重要变更</strong>，etcd作为一个反向代理把客户的请求转发给可用的etcd集群。这样，你就可以在每一台机器都部署一个Proxy模式的etcd作为本地服务，如果这些etcd Proxy都能正常运行，那么你的服务发现必然是稳定可靠的。</p>
<p><img src="/" alt="图11 Proxy模式示意图" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd11.jpg"></p>
<p>所以Proxy并不是直接加入到符合强一致性的etcd集群中，也同样的，Proxy并没有增加集群的可靠性，当然也没有降低集群的写入性能。</p>
<h4 id="5-1-Proxy取代Standby模式的原因"><a href="#5-1-Proxy取代Standby模式的原因" class="headerlink" title="5.1 Proxy取代Standby模式的原因"></a>5.1 Proxy取代Standby模式的原因</h4><p>那么，为什么要有Proxy模式而不是直接增加etcd核心节点呢？实际上etcd每增加一个核心节点（peer），都会增加Leader节点一定程度的包括网络、CPU和磁盘的负担，因为每次信息的变化都需要进行同步备份。增加etcd的核心节点可以让整个集群具有更高的可靠性，但是当数量达到一定程度以后，增加可靠性带来的好处就变得不那么明显，反倒是降低了集群写入同步的性能。因此，增加一个轻量级的Proxy模式etcd节点是对直接增加etcd核心节点的一个有效代替。</p>
<p>熟悉0.4.6这个旧版本etcd的用户会发现，Proxy模式实际上是取代了原先的Standby模式。Standby模式除了转发代理的功能以外，还会在核心节点因为故障导致数量不足的时候，从Standby模式转为正常节点模式。而当那个故障的节点恢复时，发现etcd的核心节点数量已经达到的预先设置的值，就会转为Standby模式。</p>
<p>但是新版etcd中，只会在最初启动etcd集群时，发现核心节点的数量已经满足要求时，自动启用Proxy模式，反之则并未实现。主要原因如下。</p>
<ul>
<li>etcd是用来保证高可用的组件，因此它所需要的系统资源（包括内存、硬盘和CPU等）都应该得到充分保障以保证高可用。任由集群的自动变换随意地改变核心节点，无法让机器保证性能。所以etcd官方鼓励大家在大型集群中为运行etcd准备专有机器集群。</li>
<li>因为etcd集群是支持高可用的，部分机器故障并不会导致功能失效。所以机器发生故障时，管理员有充分的时间对机器进行检查和修复。</li>
<li>自动转换使得etcd集群变得复杂，尤其是如今etcd支持多种网络环境的监听和交互。在不同网络间进行转换，更容易发生错误，导致集群不稳定。</li>
</ul>
<p>基于上述原因，目前Proxy模式有转发代理功能，而不会进行角色转换。</p>
<h4 id="5-2-关键部分源码解析"><a href="#5-2-关键部分源码解析" class="headerlink" title="5.2 关键部分源码解析"></a>5.2 关键部分源码解析</h4><p>从代码中可以看到，Proxy模式的本质就是起一个HTTP代理服务器，把客户发到这个服务器的请求转发给别的etcd节点。</p>
<p>etcd目前支持读写皆可和只读两种模式。默认情况下是读写皆可，就是把读、写两种请求都进行转发。而只读模式只转发读的请求，对所有其他请求返回501错误。</p>
<p>值得注意的是，除了启动过程中因为设置了<code>proxy</code>参数会作为Proxy模式启动。在etcd集群化启动时，节点注册自身的时候监测到集群的实际节点数量已经符合要求，那么就会退化为Proxy模式。</p>
<h3 id="6-数据存储"><a href="#6-数据存储" class="headerlink" title="6 数据存储"></a>6 数据存储</h3><p>etcd的存储分为内存存储和持久化（硬盘）存储两部分，内存中的存储除了顺序化的记录下所有用户对节点数据变更的记录外，还会对用户数据进行索引、建堆等方便查询的操作。而持久化则使用预写式日志（WAL：Write Ahead Log）进行记录存储。</p>
<p>在WAL的体系中，所有的数据在提交之前都会进行日志记录。在etcd的持久化存储目录中，有两个子目录。一个是WAL，存储着所有事务的变化记录；另一个则是snapshot，用于存储某一个时刻etcd所有目录的数据。通过WAL和snapshot相结合的方式，etcd可以有效的进行数据存储和节点故障恢复等操作。</p>
<p>既然有了WAL实时存储了所有的变更，为什么还需要snapshot呢？随着使用量的增加，WAL存储的数据会暴增，为了防止磁盘很快就爆满，etcd默认每10000条记录做一次snapshot，经过snapshot以后的WAL文件就可以删除。而通过API可以查询的历史etcd操作默认为1000条。</p>
<p>首次启动时，etcd会把启动的配置信息存储到<code>data-dir</code>参数指定的数据目录中。配置信息包括本地节点的ID、集群ID和初始时集群信息。用户需要避免etcd从一个过期的数据目录中重新启动，因为使用过期的数据目录启动的节点会与集群中的其他节点产生不一致（如：之前已经记录并同意Leader节点存储某个信息，重启后又向Leader节点申请这个信息）。所以，为了最大化集群的安全性，一旦有任何数据损坏或丢失的可能性，你就应该把这个节点从集群中移除，然后加入一个不带数据目录的新节点。</p>
<h4 id="6-1-预写式日志（WAL）"><a href="#6-1-预写式日志（WAL）" class="headerlink" title="6.1 预写式日志（WAL）"></a>6.1 预写式日志（WAL）</h4><p>WAL（Write Ahead Log）最大的作用是记录了整个数据变化的全部历程。在etcd中，所有数据的修改在提交前，都要先写入到WAL中。使用WAL进行数据的存储使得etcd拥有两个重要功能。</p>
<ul>
<li><strong>故障快速恢复</strong>： 当你的数据遭到破坏时，就可以通过执行所有WAL中记录的修改操作，快速从最原始的数据恢复到数据损坏前的状态。</li>
<li><strong>数据回滚（undo）/重做（redo）</strong>：因为所有的修改操作都被记录在WAL中，需要回滚或重做，只需要方向或正向执行日志中的操作即可。</li>
</ul>
<p>WAL与snapshot在etcd中的命名规则</p>
<p>在etcd的数据目录中，WAL文件以<code>$seq-$index.wal</code>的格式存储。最初始的WAL文件是<code>0000000000000000-0000000000000000.wal</code>，表示是所有WAL文件中的第0个，初始的Raft状态编号为0。运行一段时间后可能需要进行日志切分，把新的条目放到一个新的WAL文件中。</p>
<p>假设，当集群运行到Raft状态为20时，需要进行WAL文件的切分时，下一份WAL文件就会变为<code>0000000000000001-0000000000000021.wal</code>。如果在10次操作后又进行了一次日志切分，那么后一次的WAL文件名会变为<code>0000000000000002-0000000000000031.wal</code>。可以看到<code>-</code>符号前面的数字是每次切分后自增1，而<code>-</code>符号后面的数字则是根据实际存储的Raft起始状态来定。</p>
<p>snapshot的存储命名则比较容易理解，以<code>$term-$index.wal</code>格式进行命名存储。term和index就表示存储snapshot时数据所在的raft节点状态，当前的任期编号以及数据项位置信息。</p>
<h4 id="6-2-关键部分源码解析"><a href="#6-2-关键部分源码解析" class="headerlink" title="6.2 关键部分源码解析"></a>6.2 关键部分源码解析</h4><p>从代码逻辑中可以看到，WAL有两种模式，读模式（read）和数据添加（append）模式，两种模式不能同时成立。一个新创建的WAL文件处于append模式，并且不会进入到read模式。一个本来存在的WAL文件被打开的时候必然是read模式，并且只有在所有记录都被读完的时候，才能进入append模式，进入append模式后也不会再进入read模式。这样做有助于保证数据的完整与准确。</p>
<p>集群在进入到<code>etcdserver/server.go</code>的<code>NewServer</code>函数准备启动一个etcd节点时，会检测是否存在以前的遗留WAL数据。</p>
<p>检测的第一步是查看snapshot文件夹下是否有符合规范的文件，若检测到snapshot格式是v0.4的，则调用函数升级到v0.5。从snapshot中获得集群的配置信息，包括token、其他节点的信息等等，然后载入WAL目录的内容，从小到大进行排序。根据snapshot中得到的term和index，找到WAL紧接着snapshot下一条的记录，然后向后更新，直到所有WAL包的entry都已经遍历完毕，Entry记录到ents变量中存储在内存里。此时WAL就进入append模式，为数据项添加进行准备。</p>
<p>当WAL文件中数据项内容过大达到设定值（默认为10000）时，会进行WAL的切分，同时进行snapshot操作。这个过程可以在<code>etcdserver/server.go</code>的<code>snapshot</code>函数中看到。所以，实际上数据目录中有用的snapshot和WAL文件各只有一个，默认情况下etcd会各保留5个历史文件。</p>
<h3 id="7-Raft"><a href="#7-Raft" class="headerlink" title="7 Raft"></a>7 Raft</h3><p>新版etcd中，raft包就是对Raft一致性算法的具体实现。关于Raft算法的讲解，网上已经有很多文章，有兴趣的读者可以去阅读一下<a href="https://ramcloud.stanford.edu/raft.pdf" target="_blank" rel="noopener">Raft算法论文</a>非常精彩。本文则不再对Raft算法进行详细描述，而是结合etcd，针对算法中一些关键内容以问答的形式进行讲解。有关Raft算法的术语如果不理解，可以参见概念词汇表一节。</p>
<h4 id="7-1-Raft常见问答一览"><a href="#7-1-Raft常见问答一览" class="headerlink" title="7.1 Raft常见问答一览"></a>7.1 Raft常见问答一览</h4><ul>
<li><p>Raft中一个Term（任期）是什么意思？</p>
<p>  Raft算法中，从时间上，一个任期讲即从一次竞选开始到下一次竞选开始。从功能上讲，如果Follower接收不到Leader节点的心跳信息，就会结束当前任期，变为Candidate发起竞选，有助于Leader节点故障时集群的恢复。发起竞选投票时，任期值小的节点不会竞选成功。如果集群不出现故障，那么一个任期将无限延续下去。而投票出现冲突也有可能直接进入下一任再次竞选。     </p>
<p><img src="/" alt="图12 Term示意图" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd12.jpg"></p>
</li>
</ul>
<ul>
<li><p>Raft状态机是怎样切换的？</p>
<p>  Raft刚开始运行时，节点默认进入Follower状态，等待Leader发来心跳信息。若等待超时，则状态由Follower切换到Candidate进入下一轮term发起竞选，等到收到集群多数节点的投票时，该节点转变为Leader。Leader节点有可能出现网络等故障，导致别的节点发起投票成为新term的Leader，此时原先的老Leader节点会切换为Follower。Candidate在等待其它节点投票的过程中如果发现别的节点已经竞选成功成为Leader了，也会切换为Follower节点。 </p>
<p><img src="/" alt="图13 Raft状态机" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd13.jpg"></p>
</li>
</ul>
<ul>
<li><p><strong>如何保证最短时间内竞选出Leader，防止竞选冲突？</strong>  在Raft状态机一图中可以看到，在Candidate状态下， 有一个times out，这里的times  out时间是个随机值，也就是说，每个机器成为Candidate以后，超时发起新一轮竞选的时间是各不相同的，这就会出现一个时间差。在时间差内，如果Candidate1收到的竞选信息比自己发起的竞选信息term值大（即对方为新一轮term），并且新一轮想要成为Leader的Candidate2包含了所有提交的数据，那么Candidate1就会投票给Candidate2。这样就保证了只有很小的概率会出现竞选冲突。</p>
</li>
<li><p><strong>如何防止别的Candidate在遗漏部分数据的情况下发起投票成为Leader？</strong>  Raft竞选的机制中，使用随机值决定超时时间，第一个超时的节点就会提升term编号发起新一轮投票，一般情况下别的节点收到竞选通知就会投票。但是，如果发起竞选的节点在上一个term中保存的已提交数据不完整，节点就会拒绝投票给它。通过这种机制就可以防止遗漏数据的节点成为Leader。</p>
</li>
<li><p>Raft某个节点宕机后会如何？</p>
<p> 通常情况下，如果是Follower节点宕机，如果剩余可用节点数量超过半数，集群可以几乎没有影响的正常工作。如果是Leader节点宕机，那么Follower就收不到心跳而超时，发起竞选获得投票，成为新一轮term的Leader，继续为集群提供服务。</p>
<p>需要注意的是；etcd目前没有任何机制会自动去变化整个集群总共的节点数量</p>
<p>，即如果没有人为的调用API，etcd宕机后的节点仍然被计算为总节点数中，任何请求被确认需要获得的投票数都是这个总数的半数以上。 </p>
<p><img src="/" alt="图14 节点宕机" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/etcd/etcd14.jpg"></p>
</li>
</ul>
<ul>
<li><p><strong>为什么Raft算法在确定可用节点数量时不需要考虑拜占庭将军问题？</strong>  拜占庭问题中提出，允许n个节点宕机还能提供正常服务的分布式架构，需要的总节点数量为3n+1，而Raft只需要2n+1就可以了。其主要原因在于，拜占庭将军问题中存在数据欺骗的现象，而etcd中假设所有的节点都是诚实的。etcd在竞选前需要告诉别的节点自身的term编号以及前一轮term最终结束时的index值，这些数据都是准确的，其他节点可以根据这些值决定是否投票。另外，etcd严格限制Leader到Follower这样的数据流向保证数据一致不会出错。</p>
</li>
<li><p><strong>用户从集群中哪个节点读写数据？</strong>  Raft为了保证数据的强一致性，所有的数据流向都是一个方向，从Leader流向Follower，也就是所有Follower的数据必须与Leader保持一致，如果不一致会被覆盖。即所有用户更新数据的请求都最先由Leader获得，然后存下来通知其他节点也存下来，等到大多数节点反馈时再把数据提交。一个已提交的数据项才是Raft真正稳定存储下来的数据项，不再被修改，最后再把提交的数据同步给其他Follower。因为每个节点都有Raft已提交数据准确的备份（最坏的情况也只是已提交数据还未完全同步），所以读的请求任意一个节点都可以处理。</p>
</li>
<li><p><strong>etcd实现的Raft算法性能如何？</strong> 单实例节点支持每秒1000次数据写入。节点越多，由于数据同步涉及到网络延迟，会根据实际情况越来越慢，而读性能会随之变强，因为每个节点都能处理用户请求。</p>
</li>
</ul>
<h4 id="7-2-关键部分源码解析"><a href="#7-2-关键部分源码解析" class="headerlink" title="7.2 关键部分源码解析"></a>7.2 关键部分源码解析</h4><p>在etcd代码中，Node作为Raft状态机的具体实现，是整个算法的关键，也是了解算法的入口。</p>
<p>在etcd中，对Raft算法的调用如下，你可以在<code>etcdserver/raft.go</code>中的<code>startNode</code>找到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">storage := raft.NewMemoryStorage()</span><br><span class="line">n := raft.StartNode(<span class="number">0x01</span>, []<span class="keyword">int64</span>&#123;<span class="number">0x02</span>, <span class="number">0x03</span>&#125;, <span class="number">3</span>, <span class="number">1</span>, storage)</span><br></pre></td></tr></table></figure>

<p>通过这段代码可以了解到，Raft在运行过程记录数据和状态都是保存在内存中，而代码中<code>raft.StartNode</code>启动的Node就是Raft状态机Node。启动了一个Node节点后，Raft会做如下事项。</p>
<p>首先，你需要把从集群的其他机器上收到的信息推送到Node节点，你可以在<code>etcdserver/server.go</code>中的<code>Process</code>函数看到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span> <span class="title">Process</span><span class="params">(ctx context.Context, m raftpb.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.Type == raftpb.MsgApp &#123;</span><br><span class="line">        s.stats.RecvAppendReq(types.ID(m.From).String(), m.Size())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.node.Step(ctx, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在检测发来请求的机器是否是集群中的节点，自身节点是否是Follower，把发来请求的机器作为Leader，具体对Node节点信息的推送和处理则通过<code>node.Step()</code>函数实现。</p>
<p>其次，你需要把日志项存储起来，在你的应用中执行提交的日志项，然后把完成信号发送给集群中的其它节点，再通过<code>node.Ready()</code>监听等待下一次任务执行。有一点非常重要，你必须确保在你发送完成消息给其他节点之前，你的日志项内容已经确切稳定的存储下来了。</p>
<p>最后，你需要保持一个心跳信号<code>Tick()</code>。Raft有两个很重要的地方用到超时机制：心跳保持和Leader竞选。需要用户在其raft的Node节点上周期性的调用Tick()函数，以便为超时机制服务。</p>
<p>综上所述，整个raft节点的状态机循环类似如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &amp;lt;-s.Ticker:</span><br><span class="line">        n.Tick()</span><br><span class="line">    <span class="keyword">case</span> rd := &amp;lt;-s.Node.Ready():</span><br><span class="line">        saveToStorage(rd.State, rd.Entries)</span><br><span class="line">        send(rd.Messages)</span><br><span class="line">        process(rd.CommittedEntries)</span><br><span class="line">        s.Node.Advance()</span><br><span class="line">    <span class="keyword">case</span> &amp;lt;-s.done:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个状态机真实存在的代码位置为<code>etcdserver/server.go</code>中的<code>run</code>函数。</p>
<p>对状态机进行状态变更（如用户数据更新等）则是调用<code>n.Propose(ctx, data)</code>函数，在存储数据时，会先进行序列化操作。获得大多数其他节点的确认后，数据会被提交，存为已提交状态。</p>
<p>之前提到etcd集群的启动需要借助别的etcd集群或者DNS，而启动完毕后这些<code>外力</code>就不需要了，etcd会把自身集群的信息作为状态存储起来。所以要变更自身集群节点数量实际上也需要像用户数据变更那样添加数据条目到Raft状态机中。这一切由<code>n.ProposeConfChange(ctx, cc)</code>实现。当集群配置信息变更的请求同样得到大多数节点的确认反馈后，再进行配置变更的正式操作，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cc raftpb.ConfChange</span><br><span class="line">cc.Unmarshal(data)</span><br><span class="line">n.ApplyConfChange(cc)</span><br></pre></td></tr></table></figure>

<p>注意：一个ID唯一性的表示了一个集群，所以为了避免不同etcd集群消息混乱，ID需要确保唯一性，不能重复使用旧的token数据作为ID。</p>
<h3 id="8-Store"><a href="#8-Store" class="headerlink" title="8 Store"></a>8 Store</h3><p>Store这个模块顾名思义，就像一个商店把etcd已经准备好的各项底层支持加工起来，为用户提供五花八门的API支持，处理用户的各项请求。要理解Store，只需要从etcd的API入手即可。打开<a href="https://github.com/coreos/etcd/blob/master/Documentation/api.md" target="_blank" rel="noopener">etcd的API列表</a>，我们可以看到有如下API是对etcd存储的键值进行的操作，亦即Store提供的内容。API中提到的目录（Directory）和键（Key），上文中也可能称为etcd节点（Node）。</p>
<ul>
<li><p>为etcd存储的键赋值 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/message -XPUT -d value="Hello world"</span><br><span class="line">&#123;</span><br><span class="line">    "action": "set",</span><br><span class="line">    "node": &#123;</span><br><span class="line">        "createdIndex": 2,</span><br><span class="line">        "key": "/message",</span><br><span class="line">        "modifiedIndex": 2,</span><br><span class="line">        "value": "Hello world"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>反馈的内容含义如下：</p>
<ul>
<li><p>action: 刚刚进行的动作名称。</p>
</li>
<li><p>node.key: 请求的HTTP路径。etcd使用一个类似文件系统的方式来反映键值存储的内容。</p>
</li>
<li><p>node.value: 刚刚请求的键所存储的内容。</p>
</li>
<li><p>node.createdIndex: etcd节点每次有变化时都会自增的一个值，除了用户请求外，etcd内部运行（如启动、集群信息变化等）也会对节点有变动而引起这个值的变化。</p>
</li>
<li><p>node.modifiedIndex: 类似node.createdIndex，能引起modifiedIndex变化的操作包括set, delete, update, create, compareAndSwap and compareAndDelete。</p>
</li>
<li><p>查询etcd某个键存储的值 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/message</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改键值：与创建新值几乎相同，但是反馈时会有一个</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prevNode</span><br></pre></td></tr></table></figure>

<p>值反应了修改前存储的内容。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/message -XPUT -d value="Hello etcd"</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除一个值 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/message -XDELETE</span><br></pre></td></tr></table></figure>
</li>
<li><p>对一个键进行定时删除：etcd中对键进行定时删除，设定一个TTL值，当这个值到期时键就会被删除。反馈的内容会给出expiration项告知超时时间，ttl项告知设定的时长。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -d ttl=5</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消定时删除任务 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -d ttl= -d prevExist=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>对键值修改进行监控：etcd提供的这个API让用户可以监控一个值或者递归式的监控一个目录及其子目录的值，当目录或值发生变化时，etcd会主动通知。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/foo?wait=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>对过去的键值操作进行查询：类似上面提到的监控，只不过监控时加上了过去某次修改的索引编号，就可以查询历史操作。默认可查询的历史记录为1000条。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'http://127.0.0.1:2379/v2/keys/foo?wait=true&amp;waitIndex=7'</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动在目录下创建有序键。在对创建的目录使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST</span><br></pre></td></tr></table></figure>

<p>参数，会自动在该目录下创建一个以createdIndex值为键的值，这样就相当于以创建时间先后严格排序了。这个API对分布式队列这类场景非常有用。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/queue -XPOST -d value=Job1</span><br><span class="line">&#123;</span><br><span class="line">    "action": "create",</span><br><span class="line">    "node": &#123;</span><br><span class="line">        "createdIndex": 6,</span><br><span class="line">        "key": "/queue/6",</span><br><span class="line">        "modifiedIndex": 6,</span><br><span class="line">        "value": "Job1"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按顺序列出所有创建的有序键。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s 'http://127.0.0.1:2379/v2/keys/queue?recursive=true&amp;sorted=true'</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建定时删除的目录：就跟定时删除某个键类似。如果目录因为超时被删除了，其下的所有内容也自动超时删除。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/dir -XPUT -d ttl=30 -d dir=true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>刷新超时时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/dir -XPUT -d ttl=30 -d dir=true -d prevExist=true</span><br></pre></td></tr></table></figure>

<ul>
<li>自动化CAS（Compare-and-Swap）操作：etcd强一致性最直观的表现就是这个API，通过设定条件，阻止节点二次创建或修改。即用户的指令被执行当且仅当CAS的条件成立。条件有以下几个。 <ul>
<li>prevValue 先前节点的值，如果值与提供的值相同才允许操作。</li>
<li>prevIndex 先前节点的编号，编号与提供的校验编号相同才允许操作。</li>
<li>prevExist 先前节点是否存在。如果存在则不允许操作。这个常常被用于分布式锁的唯一获取。</li>
</ul>
</li>
</ul>
<p>假设先进行了如下操作：设定了foo的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/foo -XPUT -d value=one</span><br></pre></td></tr></table></figure>

<p>然后再进行操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/foo?prevExist=false -XPUT -d value=three</span><br></pre></td></tr></table></figure>

<p>就会返回创建失败的错误。</p>
<ul>
<li><p>条件删除（Compare-and-Delete）：与CAS类似，条件成立后才能删除。</p>
</li>
<li><p>创建目录 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/dir -XPUT -d dir=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出目录下所有的节点信息，最后以</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/</span><br></pre></td></tr></table></figure>

<p>结尾。还可以通过recursive参数递归列出所有子目录信息。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录：默认情况下只允许删除空目录，如果要删除有内容的目录需要加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recursive&#x3D;true</span><br></pre></td></tr></table></figure>

<p>参数。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 'http://127.0.0.1:2379/v2/keys/foo_dir?dir=true' -XDELETE</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个隐藏节点：命名时名字以下划线</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_</span><br></pre></td></tr></table></figure>

<p>开头默认就是隐藏键。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v2/keys/_message -XPUT -d value="Hello hidden world"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>相信看完这么多API，读者已经对Store的工作内容基本了解了。它对etcd下存储的数据进行加工，创建出如文件系统般的树状结构供用户快速查询。它有一个<code>Watcher</code>用于节点变更的实时反馈，还需要维护一个<code>WatcherHub</code>对所有<code>Watcher</code>订阅者进行通知的推送。同时，它还维护了一个由定时键构成的小顶堆，快速返回下一个要超时的键。最后，所有这些API的请求都以事件的形式存储在事件队列中等待处理。</p>
<h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h3><p>通过从应用场景到源码分析的一系列回顾，我们了解到etcd并不是一个简单的分布式键值存储系统。它解决了分布式场景中最为常见的一致性问题，为服务发现提供了一个稳定高可用的消息注册仓库，为以微服务协同工作的架构提供了无限的可能。相信在不久的将来，通过etcd构建起来的大型系统会越来越多。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">https://github.com/coreos/etcd</a></li>
<li><a href="https://groups.google.com/forum/#!topic/etcd-dev/wmndjzBNdZo" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/etcd-dev/wmndjzBNdZo</a></li>
<li><a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="noopener">http://jm-blog.aliapp.com/?p=1232</a></li>
<li><a href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/" target="_blank" rel="noopener">http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/</a></li>
<li><a href="http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd/" target="_blank" rel="noopener">http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd/</a></li>
<li><a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="noopener">http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/</a></li>
<li><a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="noopener">http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/WAL" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/WAL</a></li>
<li><a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/coreos-analyse-etcd</a></li>
<li><a href="http://www.activestate.com/blog/2014/05/service-discovery-solutions" target="_blank" rel="noopener">http://www.activestate.com/blog/2014/05/service-discovery-solutions</a></li>
<li><a href="https://ramcloud.stanford.edu/raft.pdf" target="_blank" rel="noopener">https://ramcloud.stanford.edu/raft.pdf</a></li>
</ol>
<p>​            </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">Wang YangYang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wangyangyangisme.github.io/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/">http://wangyangyangisme.github.io/2019/10/31/etcd-Etcd%E5%BA%94%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wangyangyangisme.github.io" target="_blank">WangYangYang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/76bc52296bcf2e0b7a1d628106ffcd52.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/fab2285fdcd13ead0a8b4a853c659d03.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/10/31/etcd-etcd%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/etcd/85724a45f3babbdb451f3ef24d36a303.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Etcd的简单使用</div></div></a></div><div class="next-post pull_right"><a href="/2019/10/31/git-gitbook%E7%94%9F%E6%88%90pdf/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/git/39cd9af8f0ed36313cc1a0f92c4bcbae.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GitBook工具生成PDF格式的文档</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: false,
  appId: '49gEIIGN7uRbL6vHhieSpBzM-MdYXbMMI',
  appKey: 'uqts0urLKwikYQ0fKmIkMHBE',
  placeholder: '请留下你的脚印',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang YangYang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://wangyangyangisme.github.io/">blog</a>!</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/algolia.js"></script></body></html>