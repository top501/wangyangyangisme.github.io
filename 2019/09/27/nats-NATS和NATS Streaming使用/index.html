<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NATS和NATS Streaming | WangYangYang</title><meta name="description" content="NATS和NATS Streaming"><meta name="author" content="Wang YangYang"><meta name="copyright" content="Wang YangYang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NATS和NATS Streaming"><meta name="twitter:description" content="NATS和NATS Streaming"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg"><meta property="og:type" content="article"><meta property="og:title" content="NATS和NATS Streaming"><meta property="og:url" content="http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="WangYangYang"><meta property="og:description" content="NATS和NATS Streaming"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/"><link rel="prev" title="NATS与NSQ的介绍和比较" href="http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E4%B8%8ENSQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83/"><link rel="next" title="NATS Streaming" href="http://wangyangyangisme.github.io/2019/09/27/nats-NATS-Streaming/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C4QN4OTLJM","apiKey":"c2c026ba64eeb77abd2164975fa41f34","indexName":"wyy","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://wangyangyangisme.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">193</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">38</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NATS和NATS-Streaming"><span class="toc-text">NATS和NATS Streaming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NATS"><span class="toc-text">NATS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码连接"><span class="toc-text">编码连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新身份验证-Nkeys-和用户凭据"><span class="toc-text">新身份验证 (Nkeys 和用户凭据)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS"><span class="toc-text">TLS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Go-通道"><span class="toc-text">使用 Go 通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通配符订阅"><span class="toc-text">通配符订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列组"><span class="toc-text">队列组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级用法"><span class="toc-text">高级用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群"><span class="toc-text">集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文支持-Go1-7"><span class="toc-text">上下文支持 (+ Go1.7)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NATS-Streaming"><span class="toc-text">NATS Streaming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法-1"><span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#订阅启动-i-e-重播-选项"><span class="toc-text">订阅启动 (i.e.重播)选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#持久订阅"><span class="toc-text">持久订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列组-1"><span class="toc-text">队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建队列组"><span class="toc-text">创建队列组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#起始位置"><span class="toc-text">起始位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#离开队列组"><span class="toc-text">离开队列组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关闭队列组"><span class="toc-text">关闭队列组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#持久队列组"><span class="toc-text">持久队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建持久队列组"><span class="toc-text">创建持久队列组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#起始位置-1"><span class="toc-text">起始位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#离开队列组-1"><span class="toc-text">离开队列组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#关闭队列组-1"><span class="toc-text">关闭队列组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通配符订阅-1"><span class="toc-text">通配符订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级用法-1"><span class="toc-text">高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连接配置，如-TLS-等"><span class="toc-text">连接配置，如 TLS 等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接状态"><span class="toc-text">连接状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步发布"><span class="toc-text">异步发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息确认和回复"><span class="toc-text">消息确认和回复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#速率限制-匹配"><span class="toc-text">速率限制&#x2F;匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发布者速率限制"><span class="toc-text">发布者速率限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户速率限制"><span class="toc-text">用户速率限制</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/939916bec37ea8f169680b4d133f4a86.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangYangYang</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">NATS和NATS Streaming</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-09-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-06</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/nats/">nats</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 23 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="NATS和NATS-Streaming"><a href="#NATS和NATS-Streaming" class="headerlink" title="NATS和NATS Streaming"></a>NATS和NATS Streaming</h1><h2 id="NATS"><a href="#NATS" class="headerlink" title="NATS"></a>NATS</h2><p>源码安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Go client</span></span><br><span class="line">go get github.com/nats-io/nats.go/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server</span></span><br><span class="line">go get github.com/nats-io/nats-server</span><br></pre></td></tr></table></figure>

<p>二进制：<a href="https://nats.io/download/nats-io/gnatsd/" target="_blank" rel="noopener">https://nats.io/download/nats-io/gnatsd/</a></p>
<p>When using or transitioning to Go modules support:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Go client latest or explicit version</span></span><br><span class="line">go get github.com/nats-io/nats.go/@latest</span><br><span class="line">go get github.com/nats-io/nats.go/@v1.9.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For latest NATS Server, add /v2 at the end</span></span><br><span class="line">go get github.com/nats-io/nats-server/v2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> NATS Server v1 is installed otherwise</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go get github.com/nats-io/nats-server</span></span><br></pre></td></tr></table></figure>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nats <span class="string">"github.com/nats-io/nats.go"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect to a server</span></span><br><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Publisher</span></span><br><span class="line">nc.Publish(<span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">nc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Responding to a request message</span></span><br><span class="line">nc.Subscribe(<span class="string">"request"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    m.Respond([]<span class="keyword">byte</span>(<span class="string">"answer is 42"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Sync Subscriber</span></span><br><span class="line">sub, err := nc.SubscribeSync(<span class="string">"foo"</span>)</span><br><span class="line">m, err := sub.NextMsg(timeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel Subscriber</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *nats.Msg, <span class="number">64</span>)</span><br><span class="line">sub, err := nc.ChanSubscribe(<span class="string">"foo"</span>, ch)</span><br><span class="line">msg := &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain</span></span><br><span class="line">sub.Drain()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requests</span></span><br><span class="line">msg, err := nc.Request(<span class="string">"help"</span>, []<span class="keyword">byte</span>(<span class="string">"help me"</span>), <span class="number">10</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replies</span></span><br><span class="line">nc.Subscribe(<span class="string">"help"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *nats.Msg)</span></span> &#123;</span><br><span class="line">    nc.Publish(m.Reply, []<span class="keyword">byte</span>(<span class="string">"I can help!"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain connection (Preferred for responders)</span></span><br><span class="line"><span class="comment">// Close() not needed if this is called.</span></span><br><span class="line">nc.Drain()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">nc.Close()</span><br></pre></td></tr></table></figure>

<h3 id="编码连接"><a href="#编码连接" class="headerlink" title="编码连接"></a>编码连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line">c, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Publisher</span></span><br><span class="line">c.Publish(<span class="string">"foo"</span>, <span class="string">"Hello World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">c.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, s)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// EncodedConn can Publish any raw Go type using the registered Encoder</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">     Name     <span class="keyword">string</span></span><br><span class="line">     Address  <span class="keyword">string</span></span><br><span class="line">     Age      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go type Subscriber</span></span><br><span class="line">c.Subscribe(<span class="string">"hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(p *person)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a person: %+v\n"</span>, p)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">me := &amp;person&#123;Name: <span class="string">"derek"</span>, Age: <span class="number">22</span>, Address: <span class="string">"140 New Montgomery Street, San Francisco, CA"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go type Publisher</span></span><br><span class="line">c.Publish(<span class="string">"hello"</span>, me)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub, err := c.Subscribe(<span class="string">"foo"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requests</span></span><br><span class="line"><span class="keyword">var</span> response <span class="keyword">string</span></span><br><span class="line">err = c.Request(<span class="string">"help"</span>, <span class="string">"help me"</span>, &amp;response, <span class="number">10</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Request failed: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replying</span></span><br><span class="line">c.Subscribe(<span class="string">"help"</span>, <span class="function"><span class="keyword">func</span><span class="params">(subj, reply <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.Publish(reply, <span class="string">"I can help!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">c.Close();</span><br></pre></td></tr></table></figure>

<h3 id="新身份验证-Nkeys-和用户凭据"><a href="#新身份验证-Nkeys-和用户凭据" class="headerlink" title="新身份验证 (Nkeys 和用户凭据)"></a>新身份验证 (Nkeys 和用户凭据)</h3><p>这需要服务器的版本&gt; =2.0.0</p>
<p>NATS 服务器有一个新的安全和身份验证机制来使用用户凭据和 Nkeys 认证。 最简单的形式是使用方法 userciles（credsFilepath）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserCredentials(<span class="string">"user.creds"</span>))</span><br></pre></td></tr></table></figure>

<p>The helper methods creates two callback handlers to present the user  JWT and sign the nonce challenge from the server. The core client library never has direct access to your private key and  simply performs the callback for signing the server challenge. The helper will load and wipe and erase memory it uses for each connect  or reconnect.</p>
<p>The helper also can take two entries, one for the JWT and one for the NKey seed file.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserCredentials(<span class="string">"user.jwt"</span>, <span class="string">"user.nk"</span>))</span><br></pre></td></tr></table></figure>

<p>You can also set the callback handlers directly and manage challenge signing directly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(url, nats.UserJWT(jwtCB, sigCB))</span><br></pre></td></tr></table></figure>

<p>Bare Nkeys are also supported. The nkey seed should be in a read only file, e.g. seed.txt</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat seed.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is my seed nkey!</span></span><br><span class="line">SUAGMJH5XLGZKQQWAWKRZJIGMOU4HPFUYLXJMXOO5NLFEO2OOQJ5LPRDPM</span><br></pre></td></tr></table></figure>

<p>This is a helper function which will load and decode and do the proper signing for the server nonce. It will clear memory in between invocations. You can choose to use the low level option and provide the public key and a signature callback on your own.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opt, err := nats.NkeyOptionFromSeed(<span class="string">"seed.txt"</span>)</span><br><span class="line">nc, err := nats.Connect(serverUrl, opt)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct</span></span><br><span class="line">nc, err := nats.Connect(serverUrl, nats.Nkey(pubNkey, sigCB))</span><br></pre></td></tr></table></figure>

<h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tls as a scheme will enable secure connections by default. This will also verify the server name.</span></span><br><span class="line">nc, err := nats.Connect(<span class="string">"tls://nats.demo.io:4443"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you are using a self-signed certificate, you need to have a tls.Config with RootCAs setup.</span></span><br><span class="line"><span class="comment">// We provide a helper method to make this case easier.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"tls://localhost:4443"</span>, nats.RootCAs(<span class="string">"./configs/certs/ca.pem"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the server requires client certificate, there is an helper function for that too:</span></span><br><span class="line">cert := nats.ClientCert(<span class="string">"./configs/certs/client-cert.pem"</span>, <span class="string">"./configs/certs/client-key.pem"</span>)</span><br><span class="line">nc, err = nats.Connect(<span class="string">"tls://localhost:4443"</span>, cert)</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can also supply a complete tls.Config</span></span><br><span class="line"></span><br><span class="line">certFile := <span class="string">"./configs/certs/client-cert.pem"</span></span><br><span class="line">keyFile := <span class="string">"./configs/certs/client-key.pem"</span></span><br><span class="line">cert, err := tls.LoadX509KeyPair(certFile, keyFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatalf(<span class="string">"error parsing X509 certificate/key pair: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config := &amp;tls.Config&#123;</span><br><span class="line">    ServerName: 	opts.Host,</span><br><span class="line">    Certificates: 	[]tls.Certificate&#123;cert&#125;,</span><br><span class="line">    RootCAs:    	pool,</span><br><span class="line">    MinVersion: 	tls.VersionTLS12,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nc, err = nats.Connect(<span class="string">"nats://localhost:4443"</span>, nats.Secure(config))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	t.Fatalf(<span class="string">"Got an error on Connect with Secure Options: %+v\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用-Go-通道"><a href="#使用-Go-通道" class="headerlink" title="使用 Go 通道"></a>使用 Go 通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nc, _ := nats.Connect(nats.DefaultURL)</span><br><span class="line">ec, _ := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">defer</span> ec.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">     Name     <span class="keyword">string</span></span><br><span class="line">     Address  <span class="keyword">string</span></span><br><span class="line">     Age      <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recvCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *person)</span><br><span class="line">ec.BindRecvChan(<span class="string">"hello"</span>, recvCh)</span><br><span class="line"></span><br><span class="line">sendCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *person)</span><br><span class="line">ec.BindSendChan(<span class="string">"hello"</span>, sendCh)</span><br><span class="line"></span><br><span class="line">me := &amp;person&#123;Name: <span class="string">"derek"</span>, Age: <span class="number">22</span>, Address: <span class="string">"140 New Montgomery Street"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send via Go channels</span></span><br><span class="line">sendCh &lt;- me</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive via Go channels</span></span><br><span class="line">who := &lt;- recvCh</span><br></pre></td></tr></table></figure>



<h3 id="通配符订阅"><a href="#通配符订阅" class="headerlink" title="通配符订阅"></a>通配符订阅</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "*" matches any token, at any level of the subject.</span></span><br><span class="line">nc.Subscribe(<span class="string">"foo.*.baz"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Msg received on [%s] : %s\n"</span>, m.Subject, <span class="keyword">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">nc.Subscribe(<span class="string">"foo.bar.*"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Msg received on [%s] : %s\n"</span>, m.Subject, <span class="keyword">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// "&gt;" matches any length of the tail of a subject, and can only be the last token</span></span><br><span class="line"><span class="comment">// E.g. 'foo.&gt;' will match 'foo.bar', 'foo.bar.baz', 'foo.foo.bar.bax.22'</span></span><br><span class="line">nc.Subscribe(<span class="string">"foo.&gt;"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Msg received on [%s] : %s\n"</span>, m.Subject, <span class="keyword">string</span>(m.Data));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Matches all of the above</span></span><br><span class="line">nc.Publish(<span class="string">"foo.bar.baz"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World"</span>))</span><br></pre></td></tr></table></figure>



<h3 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All subscriptions with the same queue name will form a queue group.</span></span><br><span class="line"><span class="comment">// Each message will be delivered to only one subscriber per queue group,</span></span><br><span class="line"><span class="comment">// using queuing semantics. You can have as many queue groups as you wish.</span></span><br><span class="line"><span class="comment">// Normal subscribers will continue to work as expected.</span></span><br><span class="line"></span><br><span class="line">nc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"job_workers"</span>, <span class="function"><span class="keyword">func</span><span class="params">(_ *Msg)</span></span> &#123;</span><br><span class="line">  received += <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush connection to server, returns when all messages have been processed.</span></span><br><span class="line">nc.Flush()</span><br><span class="line">fmt.Println(<span class="string">"All clear!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlushTimeout specifies a timeout value as well.</span></span><br><span class="line">err := nc.FlushTimeout(<span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"All clear!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Flushed timed out!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Auto-unsubscribe after MAX_WANTED messages received</span></span><br><span class="line"><span class="keyword">const</span> MAX_WANTED = <span class="number">10</span></span><br><span class="line">sub, err := nc.Subscribe(<span class="string">"foo"</span>)</span><br><span class="line">sub.AutoUnsubscribe(MAX_WANTED)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple connections</span></span><br><span class="line">nc1 := nats.Connect(<span class="string">"nats://host1:4222"</span>)</span><br><span class="line">nc2 := nats.Connect(<span class="string">"nats://host2:4222"</span>)</span><br><span class="line"></span><br><span class="line">nc1.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">nc2.Publish(<span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World!"</span>));</span><br></pre></td></tr></table></figure>



<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> servers = <span class="string">"nats://localhost:1222, nats://localhost:1223, nats://localhost:1224"</span></span><br><span class="line"></span><br><span class="line">nc, err := nats.Connect(servers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally set ReconnectWait and MaxReconnect attempts.</span></span><br><span class="line"><span class="comment">// This example means 10 seconds total per backend.</span></span><br><span class="line">nc, err = nats.Connect(servers, nats.MaxReconnects(<span class="number">5</span>), nats.ReconnectWait(<span class="number">2</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally disable randomization of the server pool</span></span><br><span class="line">nc, err = nats.Connect(servers, nats.DontRandomize())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup callbacks to be notified on disconnects, reconnects and connection closed.</span></span><br><span class="line">nc, err = nats.Connect(servers,</span><br><span class="line">	nats.DisconnectErrHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn, err error)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Got disconnected! Reason: %q\n"</span>, err)</span><br><span class="line">	&#125;),</span><br><span class="line">	nats.ReconnectHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Got reconnected to %v!\n"</span>, nc.ConnectedUrl())</span><br><span class="line">	&#125;),</span><br><span class="line">	nats.ClosedHandler(<span class="function"><span class="keyword">func</span><span class="params">(nc *nats.Conn)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Connection closed. Reason: %q\n"</span>, nc.LastError())</span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// When connecting to a mesh of servers with auto-discovery capabilities,</span></span><br><span class="line"><span class="comment">// you may need to provide a username/password or token in order to connect</span></span><br><span class="line"><span class="comment">// to any server in that mesh when authentication is required.</span></span><br><span class="line"><span class="comment">// Instead of providing the credentials in the initial URL, you will use</span></span><br><span class="line"><span class="comment">// new option setters:</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"nats://localhost:4222"</span>, nats.UserInfo(<span class="string">"foo"</span>, <span class="string">"bar"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// For token based authentication:</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"nats://localhost:4222"</span>, nats.Token(<span class="string">"S3cretT0ken"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can even pass the two at the same time in case one of the server</span></span><br><span class="line"><span class="comment">// in the mesh requires token instead of user name and password.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"nats://localhost:4222"</span>,</span><br><span class="line">    nats.UserInfo(<span class="string">"foo"</span>, <span class="string">"bar"</span>),</span><br><span class="line">    nats.Token(<span class="string">"S3cretT0ken"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that if credentials are specified in the initial URLs, they take</span></span><br><span class="line"><span class="comment">// precedence on the credentials specified through the options.</span></span><br><span class="line"><span class="comment">// For instance, in the connect call below, the client library will use</span></span><br><span class="line"><span class="comment">// the user "my" and password "pwd" to connect to localhost:4222, however,</span></span><br><span class="line"><span class="comment">// it will use username "foo" and password "bar" when (re)connecting to</span></span><br><span class="line"><span class="comment">// a different server URL that it got as part of the auto-discovery.</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"nats://my:pwd@localhost:4222"</span>, nats.UserInfo(<span class="string">"foo"</span>, <span class="string">"bar"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="上下文支持-Go1-7"><a href="#上下文支持-Go1-7" class="headerlink" title="上下文支持 (+ Go1.7)"></a>上下文支持 (+ Go1.7)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">nc, err := nats.Connect(nats.DefaultURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request with context</span></span><br><span class="line">msg, err := nc.RequestWithContext(ctx, <span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"bar"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous subscriber with context</span></span><br><span class="line">sub, err := nc.SubscribeSync(<span class="string">"foo"</span>)</span><br><span class="line">msg, err := sub.NextMsgWithContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encoded Request with context</span></span><br><span class="line">c, err := nats.NewEncodedConn(nc, nats.JSON_ENCODER)</span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message <span class="keyword">string</span> <span class="string">`json:"message"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> response <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="keyword">int</span> <span class="string">`json:"code"`</span></span><br><span class="line">&#125;</span><br><span class="line">req := &amp;request&#123;Message: <span class="string">"Hello"</span>&#125;</span><br><span class="line">resp := &amp;response&#123;&#125;</span><br><span class="line">err := c.RequestWithContext(ctx, <span class="string">"foo"</span>, req, resp)</span><br></pre></td></tr></table></figure>

<h2 id="NATS-Streaming"><a href="#NATS-Streaming" class="headerlink" title="NATS Streaming"></a>NATS Streaming</h2><p>源码安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Go client</span></span><br><span class="line">go get github.com/nats-io/stan.go/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server</span></span><br><span class="line">go get github.com/nats-io/nats-streaming-server</span><br></pre></td></tr></table></figure>

<p>二进制：<a href="https://nats.io/download/nats-io/nats-streaming-server/" target="_blank" rel="noopener">https://nats.io/download/nats-io/nats-streaming-server/</a></p>
<p>When using or transitioning to Go modules support:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Go client latest or explicit version</span></span><br><span class="line">go get github.com/nats-io/stan.go/@latest</span><br><span class="line">go get github.com/nats-io/stan.go/@v0.5.0</span><br></pre></td></tr></table></figure>

<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stan <span class="string">"github.com/nats-io/stan.go"</span></span><br><span class="line"></span><br><span class="line">sc, _ := stan.Connect(clusterID, clientID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Synchronous Publisher</span></span><br><span class="line">sc.Publish(<span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World"</span>)) <span class="comment">// does not return until an ack has been received from NATS Streaming</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple Async Subscriber</span></span><br><span class="line">sub, _ := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsubscribe</span></span><br><span class="line">sub.Unsubscribe()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close connection</span></span><br><span class="line">sc.Close()</span><br></pre></td></tr></table></figure>

<h4 id="订阅启动-i-e-重播-选项"><a href="#订阅启动-i-e-重播-选项" class="headerlink" title="订阅启动 (i.e.重播)选项"></a>订阅启动 (i.e.重播)选项</h4><p>NATS Streaming subscriptions are similar to NATS subscriptions, but  clients may start their subscription at an earlier point in the message  stream, allowing them to receive messages that were published before  this client registered interest.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe starting with most recently published value</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartWithLastReceived())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive all stored values in order</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DeliverAllAvailable())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive messages starting at a specific sequence number</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtSequence(<span class="number">22</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe starting at a specific time</span></span><br><span class="line"><span class="keyword">var</span> startTime time.Time</span><br><span class="line">...</span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtTime(startTime))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe starting a specific amount of time in the past (e.g. 30 seconds ago)</span></span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.StartAtTimeDelta(time.ParseDuration(<span class="string">"30s"</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h4><p>Replay of messages offers great flexibility for clients wishing to  begin processing at some earlier point in the data stream. However, some clients just need to pick up where they left off from an  earlier session, without having to manually track their position in the  stream of messages. Durable subscriptions allow clients to assign a durable name to a  subscription when it is created. Doing this causes the NATS Streaming server to track the last  acknowledged message for that clientID + durable name, so that only  messages since the last acknowledged message will be delivered to the  client.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(<span class="string">"test-cluster"</span>, <span class="string">"client-123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe with durable name</span></span><br><span class="line">sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DurableName(<span class="string">"my-durable"</span>))</span><br><span class="line">...</span><br><span class="line"><span class="comment">// client receives message sequence 1-40</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// client disconnects for an hour</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// client reconnects with same clientID "client-123"</span></span><br><span class="line">sc, _ := stan.Connect(<span class="string">"test-cluster"</span>, <span class="string">"client-123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// client re-subscribes to "foo" with same durable name "my-durable"</span></span><br><span class="line">sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.DurableName(<span class="string">"my-durable"</span>))</span><br><span class="line">...</span><br><span class="line"><span class="comment">// client receives messages 41-current</span></span><br></pre></td></tr></table></figure>

<h4 id="队列组-1"><a href="#队列组-1" class="headerlink" title="队列组"></a>队列组</h4><p>所有具有相同队列名称的订阅（不管连接是什么） 它们起源于)将形成一个队列组。 每条消息将被传递给每个队列组只有一个订阅者， 使用队列语义。您可以希望有多少队列组。</p>
<p>正常的订户将继续按预期工作。</p>
<h5 id="创建队列组"><a href="#创建队列组" class="headerlink" title="创建队列组"></a>创建队列组</h5><p>当第一个队列订阅者是自动创建队列组 创建。如果组已经存在，则将成员添加到组。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(<span class="string">"test-cluster"</span>, <span class="string">"clientid"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a queue subscriber on "foo" for group "bar"</span></span><br><span class="line">qsub1, _ := sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a second member</span></span><br><span class="line">qsub2, _ := sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice that you can have a regular subscriber on that subject</span></span><br><span class="line">sub, _ := sc.Subscribe(<span class="string">"foo"</span>, cb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A message on "foo" will be received by sub and qsub1 or qsub2.</span></span><br></pre></td></tr></table></figure>

<h5 id="起始位置"><a href="#起始位置" class="headerlink" title="起始位置"></a>起始位置</h5><p>注意，一旦形成队列组，成员的起始位置就会被忽略 当加入小组时。它将开始接收消息从最后 在小组中的位置。</p>
<p>假设频道<code>foo</code>存在与存在<code>500</code>存储的消息组<code>bar</code>已经创建有两个成员和最后一个 消息序列发送<code>100</code>.增加了一个新成员。注意它的起始位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb, stan.StartAtSequence(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>这不会产生错误，但是开始位置将被忽略。假定的 这个成员将是接收下一个消息的人它将接收消息 序列<code>101</code>. </p>
<h5 id="离开队列组"><a href="#离开队列组" class="headerlink" title="离开队列组"></a>离开队列组</h5><p> 离开组的方法有两种：关闭订阅者的连接或调用<code>Unsubscribe</code>： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Have qsub leave the queue group</span></span><br><span class="line">qsub.Unsubscribe()</span><br></pre></td></tr></table></figure>

<p>如果离开成员有未确认的消息，则重新分配这些消息 致其余的成员。 </p>
<h5 id="关闭队列组"><a href="#关闭队列组" class="headerlink" title="关闭队列组"></a>关闭队列组</h5><p>这方面没有特别的 API。一旦所有成员都离开了<code>Unsubscribe</code>, 或者他们的连接是关闭的），组从服务器中删除。</p>
<p>下一个要求<code>QueueSubscribe</code>使用相同的组名将创建一个全新的组 也就是说，开始位置将生效，交付将从那里开始。</p>
<h4 id="持久队列组"><a href="#持久队列组" class="headerlink" title="持久队列组"></a>持久队列组</h4><p>如上所述，对于非持久队列订阅者，当最后一个成员离开组， 那群人被撤走了。持久队列组允许您让所有成员离开但仍然 保持状态。当一个成员重新加入时，它从该组的最后一个位置开始。 </p>
<h5 id="创建持久队列组"><a href="#创建持久队列组" class="headerlink" title="创建持久队列组"></a>创建持久队列组</h5><p>持久队列组的创建方式与标准队列组的创建方式类似， 除了<code>DurableName</code>必须使用选项来指定持久性。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb, stan.DurableName(<span class="string">"dur"</span>))</span><br></pre></td></tr></table></figure>

<p>A group called <code>dur:bar</code> (the concatenation of durable name and group name) is created in the server. This means two things:</p>
<ul>
<li>The character <code>:</code> is not allowed for a queue subscriber’s durable name.</li>
<li>具有相同名称的持久和非持久队列组可以共存。 </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non durable queue subscriber on group "bar"</span></span><br><span class="line">qsub, _ := sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Durable queue subscriber on group "bar"</span></span><br><span class="line">durQsub, _ := sc.QueueSubscribe(<span class="string">"foo"</span>, <span class="string">"bar"</span>, qcb, stan.DurableName(<span class="string">"mydurablegroup"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// The same message produced on "foo" would be received by both queue subscribers.</span></span><br></pre></td></tr></table></figure>

<h6 id="起始位置-1"><a href="#起始位置-1" class="headerlink" title="起始位置"></a>起始位置</h6><p>非持久队列订阅者的规则适用于持久订阅者。 </p>
<h6 id="离开队列组-1"><a href="#离开队列组-1" class="headerlink" title="离开队列组"></a>离开队列组</h6><p> 至于非持久队列订阅者，如果成员的连接已关闭，或如果<code>Unsubscribe</code>它的名称，成员离开组。任何未确认的消息 被转移到剩下的成员。查看关闭小组与非持久队列订户重要的区别 。 </p>
<h6 id="关闭队列组-1"><a href="#关闭队列组-1" class="headerlink" title="关闭队列组"></a>关闭队列组</h6><p>那<em>最后的</em>成员调用<code>Unsubscribe</code>将关闭 (那就是摧毁) 组所以如果你想保持持久的集团你不应该 呼叫<code>Unsubscribe</code>.</p>
<p>因此，与非持久队列订阅者不同，维护队列组是可能的 服务器中没有成员。当一个新成员重新加入持久队列组， 它将从团队离开的地方恢复实际上首先接收所有未被承认的信息 可能在最后一个成员离开时留下的消息。</p>
<h4 id="通配符订阅-1"><a href="#通配符订阅-1" class="headerlink" title="通配符订阅"></a>通配符订阅</h4><p>NATS 流媒体订阅<strong>不</strong>支持通配符。 </p>
<h3 id="高级用法-1"><a href="#高级用法-1" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="连接配置，如-TLS-等"><a href="#连接配置，如-TLS-等" class="headerlink" title="连接配置，如 TLS 等"></a>连接配置，如 TLS 等</h4><p>如果您想要更高级的配置底层 NATS 连接您将需要 创建一个 NATS 连接调用<code>stan.NatsConn()</code>选项并将该连接传递到<code>stan.Connect()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a NATS connection that you can configure the way you want</span></span><br><span class="line">nc, err = nats.Connect(<span class="string">"tls://localhost:4443"</span>, nats.ClientCert(<span class="string">"mycerts/client-cert.pem"</span>, <span class="string">"mycerts/client-key.pem"</span>))</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>)</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then pass it to the stan.Connect() call.</span></span><br><span class="line">sc, err = stan.Connect(<span class="string">"test-cluster"</span>, <span class="string">"me"</span>, stan.NatsConn(nc))</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>)</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that you will be responsible for closing the NATS Connection after the streaming</span></span><br><span class="line"><span class="comment">// connection has been closed.</span></span><br></pre></td></tr></table></figure>

<h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><p>NATS 流服务器和客户机之间没有直接连接，这对了解客户机是否仍然有效提出了挑战。 当客户端断开时流服务器不被通知因此调用的重要性<code>Close()</code>.服务器发送心跳 到客户端的私人收件箱如果它错过了一定数量的响应它将考虑客户端的连接丢失并删除它 从它的状态。</p>
<p>前版本<code>0.4.0</code>，客户端库没有将 PINS 发送到流服务器，以检测连接失败。这是有问题的 特别是如果应用程序从未发送数据（例如只有订阅）。图片的情况下一个客户连接到一个 NATS 服务器有一条通往 NATS 流服务器的路径（连接到独立的 NATS 服务器或它嵌入的服务器）。如果 流服务器和客户端的 NATS 服务器之间的连接中断，客户端的 NATS 连接仍然可以，但是没有 与流服务器通信是可能的。这就是为什么依赖<code>Conn.NatsConn()</code>检查状态是没有帮助的。</p>
<p>开始版本<code>0.4.0</code>这个库和服务器的<code>0.10.0</code>，客户端库现在将定期发送 PING（默认为5秒） 并将关闭流连接后，一定数量的 PINS 已发送没有任何响应（默认是3）。当那时候 碰巧，回调（如果注册了）将被调用，以通知用户连接永久丢失，以及原因 因为失败了。</p>
<p>以下是您将如何指定自己的 PING 值和回调：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send PINGs every 10 seconds, and fail after 5 PINGs without any response.</span></span><br><span class="line">sc, err := stan.Connect(clusterName, clientName,</span><br><span class="line">  	stan.Pings(<span class="number">10</span>, <span class="number">5</span>),    </span><br><span class="line">  	stan.SetConnectionLostHandler(<span class="function"><span class="keyword">func</span><span class="params">(_ stan.Conn, reason error)</span></span> &#123;</span><br><span class="line">    	log.Fatalf(<span class="string">"Connection lost, reason: %v"</span>, reason)</span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意，要通知的唯一方法是设置回调。如果没有设置回调，则仍然发送 PING 和连接 如果需要，将关闭，但应用程序将不知道它是否只有订阅。</p>
<p>当连接丢失时，应用程序将不得不重新创建它和所有订阅（如果有的话）。</p>
<p>当没有 NATS 连接提供给<code>Connect()</code>调用，库创建它自己的 NATS 连接，现在将 将重新连接尝试设置为 “无限”，以前不是这样的。因此图书馆应该有可能 总是重新连接但这并不意味着流连接不会被关闭即使您设置的非常高 PINS 的阈值最大输出值。请记住，当客户端断开时，服务器正在向其发送心跳信号 客户机也是如此，当没有得到任何响应时，它将把客户机从它的状态中删除。当通信恢复时， 发送到服务器的 PINS 将允许检测此条件并向客户机报告连接现在已关闭。</p>
<p>此外，当客户机与服务器 “断开连接” 时，另一个连接到流服务器的应用程序可能会 连接并使用相同的客户端 ID。当检测重复的客户端 ID 时服务器将尝试与第一个客户端联系 要知道它是否应该拒绝第二个客户端的连接请求。由于通信之间的服务器和 第一个客户机被破坏，服务器将得不到响应，因此将用第二个客户机替换第一个客户机。</p>
<p>在客户之前<code>0.4.0</code>与服务器<code>0.10.0</code>，如果要恢复第一个客户机和服务器之间的通信， 而应用程序将发送消息服务器将接受这些消息因为发布的消息客户端 ID 是 有效，尽管客户端是无效的。与客户在<code>0.4.0+</code>与服务器<code>0.10.0+</code>，每个人都会发送更多的信息 消息，允许服务器拒绝来自已被另一个客户机替换的客户机的消息。</p>
<h4 id="异步发布"><a href="#异步发布" class="headerlink" title="异步发布"></a>异步发布</h4><p>基本发布 API (<code>Publish(subject, payload)</code>)是同步的;在 NATS 流服务器确认收到消息之前，它不会将控制返回给调用者。为了做到这一点<a href="https://github.com/nats-io/nuid" target="_blank" rel="noopener">nuid</a>是为创建时的消息生成的，客户端库在服务器返回控制权给调用者之前等待来自服务器的发布确认，这可能是由于服务器问题或授权错误导致操作不成功的错误。</p>
<p>高级用户可能希望手动处理这些发布确认，通过在发布操作期间不等待单个确认来实现更高的发布吞吐量。为此提供了异步发布 API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ackHandler := <span class="function"><span class="keyword">func</span><span class="params">(ackedNuid <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Warning: error publishing msg id %s: %v\n"</span>, ackedNuid, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Received ack for msg id %s\n"</span>, ackedNuid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nuid, err := sc.PublishAsync(<span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World"</span>), ackHandler) <span class="comment">// returns immediately</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Error publishing msg %s: %v\n"</span>, nuid, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息确认和回复"><a href="#消息确认和回复" class="headerlink" title="消息确认和回复"></a>消息确认和回复</h4><p>NATS 流提供了至少一次交付语义，这意味着一旦消息被传递给了合格的订阅者，如果在配置的超时间隔内没有接收到确认，NATS 流将尝试重新发送消息。 此超时间隔由订阅选项指定<code>AckWait</code>，默认为30秒。</p>
<p>默认情况下，在调用订阅服务器的消息处理程序后，NATS 流客户端库自动确认消息。但是，在某些情况下，订阅客户端希望加速或延迟对消息的确认。 要做到这一点，客户端必须在订阅上设置手动确认模式，并调用<code>Ack()</code>关于<code>Msg</code>. 例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe with manual ack mode, and set AckWait to 60 seconds</span></span><br><span class="line">aw, _ := time.ParseDuration(<span class="string">"60s"</span>)</span><br><span class="line">sub, err := sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">  m.Ack() <span class="comment">// ack message before performing I/O intensive operation</span></span><br><span class="line">  <span class="comment">///...</span></span><br><span class="line">  fmt.Printf(<span class="string">"Received a message: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">&#125;, stan.SetManualAckMode(), stan.AckWait(aw))</span><br></pre></td></tr></table></figure>

<h3 id="速率限制-匹配"><a href="#速率限制-匹配" class="headerlink" title="速率限制/匹配"></a>速率限制/匹配</h3><p> 发布-订阅消息传递的一个经典问题是消息生产者的速率与消息使用者的速率匹配。 消息生成程序通常可以超过使用它们的消息的订阅者的速度。 这种不匹配通常被称为 “快速生产者/慢消费者” 问题，并可能导致底层消息传递系统的资源利用率急剧上升，因为它试图缓冲消息，直到慢消费者能够赶上。 </p>
<h4 id="发布者速率限制"><a href="#发布者速率限制" class="headerlink" title="发布者速率限制"></a>发布者速率限制</h4><p>NATS 流提供了一个名为连接选项<code>MaxPubAcksInflight</code>这有效地限制了发布者在任何给定时间内可能有的未确认消息的数量。当达到这个最大值时进一步<code>PublishAsync()</code>调用将阻塞，直到未确认消息的数量低于指定的限制。 例： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sc, _ := stan.Connect(clusterID, clientID, MaxPubAcksInflight(<span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">ah := <span class="function"><span class="keyword">func</span><span class="params">(nuid <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// process the ack</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// If the server is unable to keep up with the publisher, the number of outstanding acks will eventually</span></span><br><span class="line">    <span class="comment">// reach the max and this call will block</span></span><br><span class="line">    guid, _ := sc.PublishAsync(<span class="string">"foo"</span>, []<span class="keyword">byte</span>(<span class="string">"Hello World"</span>), ah)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用户速率限制"><a href="#用户速率限制" class="headerlink" title="用户速率限制"></a>用户速率限制</h4><p>使用称为订阅选项的订阅选项也可以在订阅方按每次订阅的方式实现速率限制<code>MaxInflight</code>. 此选项指定 NATS 流允许给定订阅的未完成确认（已交付但未确认的消息）的最大数量。 当达到此限制时，NATS 流将暂停向此订阅交付消息，直到未确认消息的数量低于指定的限制。 例： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe with manual ack mode and a max in-flight limit of 25</span></span><br><span class="line">sc.Subscribe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(m *stan.Msg)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Received message #: %s\n"</span>, <span class="keyword">string</span>(m.Data))</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Does not ack, or takes a very long time to ack</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Message delivery will suspend when the number of unacknowledged messages reaches 25</span></span><br><span class="line">&#125;, stan.SetManualAckMode(), stan.MaxInflight(<span class="number">25</span>))</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">Wang YangYang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/">http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E5%92%8CNATS%20Streaming%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wangyangyangisme.github.io" target="_blank">WangYangYang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/76bc52296bcf2e0b7a1d628106ffcd52.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/fab2285fdcd13ead0a8b4a853c659d03.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/09/27/nats-NATS%E4%B8%8ENSQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/117253db2af95b52a584feae021fb1f8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NATS与NSQ的介绍和比较</div></div></a></div><div class="next-post pull_right"><a href="/2019/09/27/nats-NATS-Streaming/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/95994a9aea31be452e66c89e68ba4a27.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NATS Streaming</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: false,
  appId: '49gEIIGN7uRbL6vHhieSpBzM-MdYXbMMI',
  appKey: 'uqts0urLKwikYQ0fKmIkMHBE',
  placeholder: '请留下你的脚印',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang YangYang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://wangyangyangisme.github.io/">blog</a>!</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/algolia.js"></script></body></html>