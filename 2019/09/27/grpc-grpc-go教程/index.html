<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>grpc-go教程 | WangYangYang</title><meta name="description" content="grpc-go教程"><meta name="author" content="Wang YangYang"><meta name="copyright" content="Wang YangYang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="grpc-go教程"><meta name="twitter:description" content="grpc-go教程"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/grpc/0c8fe6893c3ea5bad827c248fb35a85a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="grpc-go教程"><meta property="og:url" content="http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/"><meta property="og:site_name" content="WangYangYang"><meta property="og:description" content="grpc-go教程"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/grpc/0c8fe6893c3ea5bad827c248fb35a85a.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/"><link rel="prev" title="grpc-Hello例子" href="http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-Hello%E4%BE%8B%E5%AD%90/"><link rel="next" title="grpc-通讯协议" href="http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%95/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C4QN4OTLJM","apiKey":"c2c026ba64eeb77abd2164975fa41f34","indexName":"wyy","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://wangyangyangisme.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">187</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">36</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#grpc-基础-go"><span class="toc-text"> gRPC 基础: Go</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么使用-grpc"><span class="toc-text"> 为什么使用 gRPC?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子的代码和设置"><span class="toc-text"> 例子的代码和设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义服务"><span class="toc-text"> 定义服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成客户端和服务器端代码"><span class="toc-text"> 生成客户端和服务器端代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建服务器"><span class="toc-text"> 创建服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现routeguide"><span class="toc-text"> 实现RouteGuide</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单-rpc"><span class="toc-text"> 简单 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器端流式-rpc"><span class="toc-text"> 服务器端流式 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端流式-rpc"><span class="toc-text"> 客户端流式 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向流式-rpc"><span class="toc-text"> 双向流式 RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动服务器"><span class="toc-text"> 启动服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建客户端"><span class="toc-text"> 创建客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建存根"><span class="toc-text"> 创建存根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用服务方法"><span class="toc-text"> 调用服务方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单-rpc-2"><span class="toc-text"> 简单 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器端流式-rpc-2"><span class="toc-text"> 服务器端流式 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端流式-rpc-2"><span class="toc-text"> 客户端流式 RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向流式-rpc-2"><span class="toc-text"> 双向流式 RPC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#来试试吧"><span class="toc-text"> 来试试吧！</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/grpc/0c8fe6893c3ea5bad827c248fb35a85a.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangYangYang</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">grpc-go教程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-09-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-06</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/grpc/">grpc</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 16 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="grpc-基础-go"><a class="markdownIt-Anchor" href="#grpc-基础-go"></a> gRPC 基础: Go</h1>
<p>本教程提供了 Go 程序员如何使用 gRPC 的指南。</p>
<p>通过学习教程中例子，你可以学会如何：</p>
<ul>
<li>在一个 .proto 文件内定义服务。</li>
<li>用 protocol buffer 编译器生成服务器和客户端代码。</li>
<li>使用 gRPC 的 Go API 为你的服务实现一个简单的客户端和服务器。</li>
</ul>
<p>假设你已经阅读了<a href="http://grpc.mydoc.io?v=10467&amp;t=58008" target="_blank" rel="noopener">概览</a> 并且熟悉<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers</a>。 注意，教程中的例子使用的是 protocol buffers 语言的 proto3 版本，它目前只是 alpha 版：可以在<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener"> proto3 语言指南</a>和 protocol buffers 的 Github 仓库的<a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">版本注释</a>发现更多关于新版本的内容。</p>
<p>这算不上是一个在 Go 中使用 gRPC 的综合指南：以后会有更多的参考文档.</p>
<h2 id="为什么使用-grpc"><a class="markdownIt-Anchor" href="#为什么使用-grpc"></a> 为什么使用 gRPC?</h2>
<p>我们的例子是一个简单的路由映射的应用，它允许客户端获取路由特性的信息，生成路由的总结，以及交互路由信息，如服务器和其他客户端的流量更新。</p>
<p>有了 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务器，反过来，它们可以在各种环境中，从Google的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性.使用 protocol buffers 还能获得其他好处，包括高效的序列号，简单的 IDL 以及容易进行接口更新。</p>
<h2 id="例子的代码和设置"><a class="markdownIt-Anchor" href="#例子的代码和设置"></a> 例子的代码和设置</h2>
<p>教程的代码在这里 <a href="https://github.com/grpc/grpc-go/tree/master/examples/route_guide" target="_blank" rel="noopener">grpc/grpc-go/examples/cpp/route_guide</a>。 要下载例子，通过运行下面的命令去克隆<code>grpc-go</code>代码库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get google.golang.org/grpc</span></span><br></pre></td></tr></table></figure>
<p>然后改变当前的目录到 <code>grpc-go/examples/route_guide</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/google.golang.org/grpc/examples/route_guide</span></span><br></pre></td></tr></table></figure>
<p>你还需要安装生成服务器和客户端的接口代码相关工具-如果你还没有安装的话，请查看下面的设置指南<a href="http://doc.oschina.net/docs/installation/go.html" target="_blank" rel="noopener"> Go快速开始指南</a>。</p>
<h2 id="定义服务"><a class="markdownIt-Anchor" href="#定义服务"></a> 定义服务</h2>
<p>我们的第一步(可以从<a href="http://doc.oschina.net/docs/index.html" target="_blank" rel="noopener">概览</a>中得知)是使用 <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers</a>去定义 gRPC <em>service</em> 和方法 <em>request</em> 以及 <em>response</em> 的类型。你可以在<a href="https://github.com/grpc/grpc/blob/%3C!--%EF%BF%BC25--%3E/examples/protos/route_guide.proto" target="_blank" rel="noopener"><code>examples/protos/route_guide.proto</code></a>看到完整的 .proto 文件。</p>
<p>要定义一个服务，你必须在你的 .proto 文件中指定 <code>service</code>：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">RouteGuide</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在你的服务中定义 <code>rpc</code> 方法，指定请求的和响应类型。gRPC 允许你定义4种类型的 service 方法，这些都在 <code>RouteGuide</code> 服务中使用：</p>
<ul>
<li>一个 <em>简单 RPC</em> ， 客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtains the feature at a given position.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> GetFeature(Point) <span class="keyword">returns</span> (Feature) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <em>服务器端流式 RPC</em> ， 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 <em>响应</em> 类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obtains the Features available within the given Rectangle.  Results are</span></span><br><span class="line"><span class="comment">// streamed rather than returned at once (e.g. in a response message with a</span></span><br><span class="line"><span class="comment">// repeated field), as the rectangle may cover a large area and contain a</span></span><br><span class="line"><span class="comment">// huge number of features.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListFeatures(Rectangle) <span class="keyword">returns</span> (stream Feature) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <em>客户端流式 RPC</em> ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 <em>请求</em> 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accepts a stream of Points on a route being traversed, returning a</span></span><br><span class="line"><span class="comment">// RouteSummary when traversal is completed.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> RecordRoute(stream Point) <span class="keyword">returns</span> (RouteSummary) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <em>双向流式 RPC</em>  是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如，  服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。  每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accepts a stream of RouteNotes sent while a route is being traversed,</span></span><br><span class="line"><span class="comment">// while receiving other RouteNotes (e.g. from other users).</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> RouteChat(stream RouteNote) <span class="keyword">returns</span> (stream RouteNote) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们的 .proto 文件也包含了所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响 应类型——比如，下面的<code>Point</code>消息类型：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Points are represented as latitude-longitude pairs in the E7 representation</span></span><br><span class="line"><span class="comment">// (degrees multiplied by 10**7 and rounded to the nearest integer).</span></span><br><span class="line"><span class="comment">// Latitudes should be in the range +/- 90 degrees and longitude should be in</span></span><br><span class="line"><span class="comment">// the range +/- 180 degrees (inclusive).</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> latitude = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> longitude = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成客户端和服务器端代码"><a class="markdownIt-Anchor" href="#生成客户端和服务器端代码"></a> 生成客户端和服务器端代码</h2>
<p>接下来我们需要从 .proto 的服务定义中生成 gRPC 客户端和服务器端的接口。我们通过 protocol buffer 的编译器 <code>protoc</code> 以及一个特殊的 gRPC Go 插件来完成。</p>
<p>简单起见，我们提供一个 <a href="https://github.com/grpc/grpc-go/blob/master/codegen.sh" target="_blank" rel="noopener">bash 脚本</a> 帮你用合适的插件，输入，输出去运行 <code>protoc</code>(如果你想自己去运行，确保你已经安装了 protoc，并且请遵循下面的 gRPC-Go <a href="https://github.com/grpc/grpc-go/blob/master/README.md" target="_blank" rel="noopener">安装指南</a>)来操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> codegen.sh route_guide.proto</span></span><br></pre></td></tr></table></figure>
<p>实际上运行的是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> protoc --go_out=plugins=grpc:. route_guide.proto</span></span><br></pre></td></tr></table></figure>
<p>运行这个命令可以在当前目录中生成下面的文件：</p>
<ul>
<li><code>route_guide.pb.go</code></li>
</ul>
<p>这些包括：</p>
<ul>
<li>所有用于填充，序列化和获取我们请求和响应消息类型的 protocol buffer 代码</li>
<li>一个为客户端调用定义在<code>RouteGuide</code>服务的方法的接口类型（或者 <em>存根</em> ）</li>
<li>一个为服务器使用定义在<code>RouteGuide</code>服务的方法去实现的接口类型（或者 <em>存根</em> ）</li>
</ul>
<h2 id="创建服务器"><a class="markdownIt-Anchor" href="#创建服务器"></a> 创建服务器</h2>
<p>首先来看看我们如何创建一个 <code>RouteGuide</code> 服务器。如果你只对创建 gRPC 客户端感兴趣，你可以跳 过这个部分，直接到<a href="http://doc.oschina.net/grpc?t=60133#client" target="_blank" rel="noopener">创建客户端</a> (当然你也可能发现它也很有意思)。</p>
<p>让 <code>RouteGuide</code> 服务工作有两个部分：</p>
<ul>
<li>实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”。</li>
<li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应。</li>
</ul>
<p>你可以从<a href="https://github.com/grpc/grpc-go/tree/master/examples/route_guide/server/server.go" target="_blank" rel="noopener">grpc-go/examples/route_guide/server/server.go</a>看到我们的 <code>RouteGuide</code> 服务器的实现代码。现在让我们近距离研究它是如何工作的。</p>
<h3 id="实现routeguide"><a class="markdownIt-Anchor" href="#实现routeguide"></a> 实现RouteGuide</h3>
<p>我们可以看出，服务器有一个实现了生成的 <code>RouteGuideServer</code> 接口的 <code>routeGuideServer</code> 结构类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> routeGuideServer <span class="keyword">struct</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">GetFeature</span><span class="params">(ctx context.Context, point *pb.Point)</span> <span class="params">(*pb.Feature, error)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">ListFeatures</span><span class="params">(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">RecordRoute</span><span class="params">(stream pb.RouteGuide_RecordRouteServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">RouteChat</span><span class="params">(stream pb.RouteGuide_RouteChatServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="简单-rpc"><a class="markdownIt-Anchor" href="#简单-rpc"></a> 简单 RPC</h4>
<p><code>routeGuideServer</code> 实现了我们所有的服务方法。首先让我们看看最简单的类型 <code>GetFeature</code>，它从客户端拿到一个 <code>Point</code> 对象，然后从返回包含从数据库拿到的feature信息的 <code>Feature</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">GetFeature</span><span class="params">(ctx context.Context, point *pb.Point)</span> <span class="params">(*pb.Feature, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, feature := <span class="keyword">range</span> s.savedFeatures &#123;</span><br><span class="line">        <span class="keyword">if</span> proto.Equal(feature.Location, point) &#123;</span><br><span class="line">            <span class="keyword">return</span> feature, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No feature was found, return an unnamed feature</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pb.Feature&#123;<span class="string">""</span>, point&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法传入了 RPC 的上下文对象，以及客户端的 <code>Point</code> protocol buffer请求。它返回了一个包含响应信息和<code>error</code> 的 <code>Feature</code> protocol buffer对象。在方法中我们用适当的信息填充 <code>Feature</code>，然后将其和一个<code>nil</code>错误一起返回，告诉 gRPC 我们完成了对 RPC 的处理，并且 <code>Feature</code> 可以返回给客户端。</p>
<h4 id="服务器端流式-rpc"><a class="markdownIt-Anchor" href="#服务器端流式-rpc"></a> 服务器端流式 RPC</h4>
<p>现在让我们来看看我们的一种流式 RPC。 <code>ListFeatures</code> 是一个服务器端的流式 RPC，所以我们需要将多个 <code>Feature</code> 发回给客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">ListFeatures</span><span class="params">(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, feature := <span class="keyword">range</span> s.savedFeatures &#123;</span><br><span class="line">        <span class="keyword">if</span> inRange(feature.Location, rect) &#123;</span><br><span class="line">            <span class="keyword">if</span> err := stream.Send(feature); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，这里的请求对象是一个 <code>Rectangle</code>，客户端期望从中找到 <code>Feature</code>，这次我们得到了一个请求对象和一个特殊的<code>RouteGuide_ListFeaturesServer</code>来写入我们的响应，而不是得到方法参数中的简单请求和响应对象。</p>
<p>在这个方法中，我们填充了尽可能多的 <code>Feature</code> 对象去返回，用它们的 <code>Send()</code> 方法把它们写入 <code>RouteGuide_ListFeaturesServer</code>。最后，在我们的简单 RPC中，我们返回了一个 <code>nil</code> 错误告诉 gRPC 响应的写入已经完成。如果在调用过程中发生任何错误，我们会返回一个非 <code>nil</code> 的错误；gRPC 层会将其转化为合适的 RPC 状态通过线路发送。</p>
<h4 id="客户端流式-rpc"><a class="markdownIt-Anchor" href="#客户端流式-rpc"></a> 客户端流式 RPC</h4>
<p>现在让我们看看稍微复杂点的东西：客户端流方法 <code>RecordRoute</code>，我们通过它可以从客户端拿到一个 <code>Point</code> 的流，其中包括它们路径的信息。如你所见，这次这个方法没有请求参数。相反的，它拿到了一个 <code>RouteGuide_RecordRouteServer</code> 流，服务器可以用它来同时读 <em>和</em> 写消息——它可以用自己的 <code>Recv()</code> 方法接收客户端消息并且用 <code>SendAndClose()</code> 方法返回它的单个响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">RecordRoute</span><span class="params">(stream pb.RouteGuide_RecordRouteServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pointCount, featureCount, distance <span class="keyword">int32</span></span><br><span class="line">    <span class="keyword">var</span> lastPoint *pb.Point</span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        point, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            endTime := time.Now()</span><br><span class="line">            <span class="keyword">return</span> stream.SendAndClose(&amp;pb.RouteSummary&#123;</span><br><span class="line">                PointCount:   pointCount,</span><br><span class="line">                FeatureCount: featureCount,</span><br><span class="line">                Distance:     distance,</span><br><span class="line">                ElapsedTime:  <span class="keyword">int32</span>(endTime.Sub(startTime).Seconds()),</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        pointCount++</span><br><span class="line">        <span class="keyword">for</span> _, feature := <span class="keyword">range</span> s.savedFeatures &#123;</span><br><span class="line">            <span class="keyword">if</span> proto.Equal(feature.Location, point) &#123;</span><br><span class="line">                featureCount++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lastPoint != <span class="literal">nil</span> &#123;</span><br><span class="line">            distance += calcDistance(lastPoint, point)</span><br><span class="line">        &#125;</span><br><span class="line">        lastPoint = point</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中，我们使用 <code>RouteGuide_RecordRouteServer</code> 的 <code>Recv()</code> 方法去反复读取客户端的请求到一个请求对象（在这个场景下是 <code>Point</code>），直到没有更多的消息：服务器需要在每次调用后检查 <code>Read()</code> 返回的错误。如果返回值为 <code>nil</code>，流依然完好，可以继续读取；如果返回值为 <code>io.EOF</code>，消息流结束，服务器可以返回它的 <code>RouteSummary</code>。如果它还有其它值，我们原样返回错误，gRPC 层会把它转换为 RPC 状态。</p>
<h4 id="双向流式-rpc"><a class="markdownIt-Anchor" href="#双向流式-rpc"></a> 双向流式 RPC</h4>
<p>最后，让我们看看双向流式 RPC <code>RouteChat()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *routeGuideServer)</span> <span class="title">RouteChat</span><span class="params">(stream pb.RouteGuide_RouteChatServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        in, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        key := serialize(in.Location)</span><br><span class="line">                ... <span class="comment">// look for notes to be sent to client</span></span><br><span class="line">        <span class="keyword">for</span> _, note := <span class="keyword">range</span> s.routeNotes[key] &#123;</span><br><span class="line">            <span class="keyword">if</span> err := stream.Send(note); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们得到了一个 <code>RouteGuide_RouteChatServer</code> 流，和我们的客户端流的例子一样，它可以用来读写消息。但是，这次当客户端还在往 <em>它们</em> 的消息流中写入消息时，我们通过方法的流返回值。</p>
<p>这里读写的语法和客户端流方法相似，除了服务器会使用流的 <code>Send()</code> 方法而不是 <code>SendAndClose()</code>，因为它需要写多个响应。虽然客户端和服务器端总是会拿到对方写入时顺序的消息，它们可以以任意顺序读写——流的操作是完全独立的。</p>
<h3 id="启动服务器"><a class="markdownIt-Anchor" href="#启动服务器"></a> 启动服务器</h3>
<p>一旦我们实现了所有的方法，我们还需要启动一个gRPC服务器，这样客户端才可以使用服务。下面这段代码展示了在我们<code>RouteGuide</code>服务中实现的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse()</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line">pb.RegisterRouteGuideServer(grpcServer, &amp;routeGuideServer&#123;&#125;)</span><br><span class="line">... <span class="comment">// determine whether to use TLS</span></span><br><span class="line">grpcServer.Serve(lis)</span><br></pre></td></tr></table></figure>
<p>为了构建和启动服务器，我们需要：</p>
<ol>
<li>使用 <code>lis, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;:%d&quot;, *port))</code> 指定我们期望客户端请求的监听端口。</li>
<li>使用<code>grpc.NewServer()</code>创建 gRPC 服务器的一个实例。</li>
<li>在 gRPC 服务器注册我们的服务实现。</li>
<li>用服务器 <code>Serve()</code> 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 <code>Stop()</code> 被调用。</li>
</ol>
<h2 id="创建客户端"><a class="markdownIt-Anchor" href="#创建客户端"></a> 创建客户端</h2>
<p>在这部分，我们将尝试为 <code>RouteGuide</code> 服务创建一个 Go 的客户端。你可以从<a href="https://github.com/grpc/grpc-go/tree/master/examples/route_guide/client/client.go" target="_blank" rel="noopener">grpc-go/examples/route_guide/client/client.go</a>看到我们完整的客户端例子代码.</p>
<h3 id="创建存根"><a class="markdownIt-Anchor" href="#创建存根"></a> 创建存根</h3>
<p>为了调用服务方法，我们首先创建一个 gRPC <em>channel</em> 和服务器交互。我们通过给 <code>grpc.Dial()</code> 传入服务器地址和端口号做到这点，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.Dial(*serverAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>DialOptions</code> 在 <code>grpc.Dial</code> 中设置授权认证（如， TLS，GCE认证，JWT认证），如果服务有这样的要求的话 —— 但是对于 <code>RouteGuide</code> 服务，我们不用这么做。</p>
<p>一旦 gRPC <em>channel</em> 建立起来，我们需要一个客户端 <em>存根</em> 去执行 RPC。我们通过 .proto 生成的 <code>pb</code> 包提供的 <code>NewRouteGuideClient</code> 方法来完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client := pb.NewRouteGuideClient(conn)</span><br></pre></td></tr></table></figure>
<h3 id="调用服务方法"><a class="markdownIt-Anchor" href="#调用服务方法"></a> 调用服务方法</h3>
<p>现在让我们看看如何调用服务方法。注意，在 gRPC-Go 中，RPC以阻塞/同步模式操作，这意味着 RPC 调用等待服务器响应，同时要么返回响应，要么返回错误。</p>
<h4 id="简单-rpc-2"><a class="markdownIt-Anchor" href="#简单-rpc-2"></a> 简单 RPC</h4>
<p>调用简单 RPC <code>GetFeature</code> 几乎是和调用一个本地方法一样直观。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feature, err := client.GetFeature(context.Background(), &amp;pb.Point&#123;<span class="number">409146138</span>, <span class="number">-746188906</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，我们调用了前面创建的存根上的方法。在我们的方法参数中，我们创建并且填充了一个请求的 protocol buffer 对象（例子中为 <code>Point</code>）。我们同时传入了一个 <code>context.Context</code> ，在有需要时可以让我们改变 RPC 的行为，比如超时/取消一个正在运行的 RPC。 如果调用没有返回错误，那么我们就可以从服务器返回的第一个返回值中读到响应信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Println(feature)</span><br></pre></td></tr></table></figure>
<h4 id="服务器端流式-rpc-2"><a class="markdownIt-Anchor" href="#服务器端流式-rpc-2"></a> 服务器端流式 RPC</h4>
<p><code>ListFeatures</code> 就是我们说的服务器端流方法，它会返回地理的<code>Feature</code> 流。 如果你已经读过<a href="http://doc.oschina.net/grpc?t=60133#server" target="_blank" rel="noopener">创建服务器</a>，本节的一些内容也许看上去会很熟悉——流式 RPC 是在客户端和服务器两端以一种类似的方式实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rect := &amp;pb.Rectangle&#123; ... &#125;  <span class="comment">// initialize a pb.Rectangle</span></span><br><span class="line">stream, err := client.ListFeatures(context.Background(), rect)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    feature, err := stream.Recv()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"%v.ListFeatures(_) = _, %v"</span>, client, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(feature)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在简单 RPC 的例子中，我们给方法传入一个上下文和请求。然而，我们得到返回的是一个 <code>RouteGuide_ListFeaturesClient</code> 实例，而不是一个应答对象。客户端可以使用 <code>RouteGuide_ListFeaturesClient</code> 流去读取服务器的响应。</p>
<p>我们使用 <code>RouteGuide_ListFeaturesClient</code> 的 <code>Recv()</code> 方法去反复读取服务器的响应到一个响应 protocol buffer 对象（在这个场景下是<code>Feature</code>）直到消息读取完毕：每次调用完成时，客户端都要检查从 <code>Recv()</code> 返回的错误 <code>err</code>。如果返回为 <code>nil</code>，流依然完好并且可以继续读取；如果返回为 <code>io.EOF</code>，则说明消息流已经结束；否则就一定是一个通过 <code>err</code> 传过来的 RPC 错误。</p>
<h4 id="客户端流式-rpc-2"><a class="markdownIt-Anchor" href="#客户端流式-rpc-2"></a> 客户端流式 RPC</h4>
<p>除了我们需要给方法传入一个上下文而后返回 <code>RouteGuide_RecordRouteClient</code> 流以外，客户端流方法 <code>RecordRoute</code> 和服务器端方法类似，它可以用来读 <em>和</em> 写消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a random number of random points</span></span><br><span class="line">r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">pointCount := <span class="keyword">int</span>(r.Int31n(<span class="number">100</span>)) + <span class="number">2</span> <span class="comment">// Traverse at least two points</span></span><br><span class="line"><span class="keyword">var</span> points []*pb.Point</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pointCount; i++ &#123;</span><br><span class="line">    points = <span class="built_in">append</span>(points, randomPoint(r))</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Traversing %d points."</span>, <span class="built_in">len</span>(points))</span><br><span class="line">stream, err := client.RecordRoute(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"%v.RecordRoute(_) = _, %v"</span>, client, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, point := <span class="keyword">range</span> points &#123;</span><br><span class="line">    <span class="keyword">if</span> err := stream.Send(point); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"%v.Send(%v) = %v"</span>, stream, point, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reply, err := stream.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"%v.CloseAndRecv() got error %v, want %v"</span>, stream, err, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Route summary: %v"</span>, reply)</span><br></pre></td></tr></table></figure>
<p><code>RouteGuide_RecordRouteClient</code> 有一个 <code>Send()</code> 方法，我们可以用它来给服务器发送请求。一旦我们完成使用 <code>Send()</code> 方法将客户端请求写入流，就需要调用流的 <code>CloseAndRecv()</code>方法，让 gRPC 知道我们已经完成了写入同时期待返回应答。我们从 <code>CloseAndRecv()</code> 返回的 <code>err</code> 中获得 RPC 的状态。如果状态为<code>nil</code>，那么<code>CloseAndRecv()</code>的第一个返回值将会是合法的服务器应答。</p>
<h4 id="双向流式-rpc-2"><a class="markdownIt-Anchor" href="#双向流式-rpc-2"></a> 双向流式 RPC</h4>
<p>最后，让我们看看双向流式 RPC <code>RouteChat()</code>。 和 <code>RecordRoute</code> 的场景类似，我们只给函数传 入一个上下文对象，拿到可以用来读写的流。但是，当服务器依然在往 <em>他们</em> 的消息流写入消息时，我们 通过方法流返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stream, err := client.RouteChat(context.Background())</span><br><span class="line">waitc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        in, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="comment">// read done.</span></span><br><span class="line">            <span class="built_in">close</span>(waitc)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalf(<span class="string">"Failed to receive a note : %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">"Got message %s at point(%d, %d)"</span>, in.Message, in.Location.Latitude, in.Location.Longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> _, note := <span class="keyword">range</span> notes &#123;</span><br><span class="line">    <span class="keyword">if</span> err := stream.Send(note); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Failed to send a note: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">stream.CloseSend()</span><br><span class="line">&lt;-waitc</span><br></pre></td></tr></table></figure>
<p>这里读写的语法和我们的客户端流方法很像，除了在完成调用时，我们会使用流的 <code>CloseSend()</code> 方法。 虽然每一端获取对方信息的顺序和信息被写入的顺序一致，客户端和服务器都可以以任意顺序读写——流的操作是完全独立的。</p>
<h2 id="来试试吧"><a class="markdownIt-Anchor" href="#来试试吧"></a> 来试试吧！</h2>
<p>假设你在 <code>$GOPATH/src/google.golang.org/grpc/examples/route_guide</code> 目录，要编译和运行服务器，只需要运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server/server.go</span><br></pre></td></tr></table></figure>
<p>同样的，运行客户端:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run client/client.go</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">Wang YangYang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/">http://wangyangyangisme.github.io/2019/09/27/grpc-grpc-go%E6%95%99%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wangyangyangisme.github.io" target="_blank">WangYangYang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/76bc52296bcf2e0b7a1d628106ffcd52.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/fab2285fdcd13ead0a8b4a853c659d03.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/09/27/grpc-grpc-Hello%E4%BE%8B%E5%AD%90/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/grpc/0c978cf66ba2f710f28758ed71b03ef8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">grpc-Hello例子</div></div></a></div><div class="next-post pull_right"><a href="/2019/09/27/grpc-grpc-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%95/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/grpc/6714d2c568d0e283f2b5135e8a76d684.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">grpc-通讯协议</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: false,
  appId: '49gEIIGN7uRbL6vHhieSpBzM-MdYXbMMI',
  appKey: 'uqts0urLKwikYQ0fKmIkMHBE',
  placeholder: '请留下你的脚印',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang YangYang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://wangyangyangisme.github.io/">blog</a>!</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/algolia.js"></script></body></html>