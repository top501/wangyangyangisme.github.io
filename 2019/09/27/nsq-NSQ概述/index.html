<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NSQ概述 | WangYangYang</title><meta name="description" content="NSQ概述"><meta name="author" content="Wang YangYang"><meta name="copyright" content="Wang YangYang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NSQ概述"><meta name="twitter:description" content="NSQ概述"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nsq/53383d2f25c7478094becea995f48771.jpg"><meta property="og:type" content="article"><meta property="og:title" content="NSQ概述"><meta property="og:url" content="http://wangyangyangisme.github.io/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/"><meta property="og:site_name" content="WangYangYang"><meta property="og:description" content="NSQ概述"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nsq/53383d2f25c7478094becea995f48771.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wangyangyangisme.github.io/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/"><link rel="prev" title="NSQ组件" href="http://wangyangyangisme.github.io/2019/09/27/nsq-NSQ%E7%BB%84%E4%BB%B6/"><link rel="next" title="NATS与NSQ的介绍和比较" href="http://wangyangyangisme.github.io/2019/09/27/nats-NATS%E4%B8%8ENSQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C4QN4OTLJM","apiKey":"c2c026ba64eeb77abd2164975fa41f34","indexName":"wyy","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://wangyangyangisme.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/theme/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">194</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">39</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NSQ概述"><span class="toc-text">NSQ概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速开始"><span class="toc-text">快速开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特性和担保"><span class="toc-text">特性和担保</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特性"><span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#担保"><span class="toc-text">担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息不可持久化（默认）"><span class="toc-text">消息不可持久化（默认）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息最少会被投递一次"><span class="toc-text">消息最少会被投递一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收到的消息是无序的"><span class="toc-text">接收到的消息是无序的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费者最终找出所有话题的生产者"><span class="toc-text">消费者最终找出所有话题的生产者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#部署"><span class="toc-text">部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发布"><span class="toc-text">发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计和理论"><span class="toc-text">设计和理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特定的-pynsq"><span class="toc-text">特定的 pynsq</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能"><span class="toc-text">性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式性能"><span class="toc-text">分布式性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者吞吐量"><span class="toc-text">生产者吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产和消费吞吐量"><span class="toc-text">生产和消费吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单个节点性能"><span class="toc-text">单个节点性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOMAXPROCS-1-单个生产者，单个消费者"><span class="toc-text">GOMAXPROCS&#x3D;1 (单个生产者，单个消费者)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOMAXPROCS-4-4-个生产者-4-个消费者"><span class="toc-text">GOMAXPROCS&#x3D;4 (4 个生产者, 4 个消费者)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计"><span class="toc-text">设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简化配置和管理"><span class="toc-text">简化配置和管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单的升级路径"><span class="toc-text">简单的升级路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消除单点故障"><span class="toc-text">消除单点故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息传递担保"><span class="toc-text">消息传递担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限定内存占用"><span class="toc-text">限定内存占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#效率"><span class="toc-text">效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go"><span class="toc-text">Go</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内幕"><span class="toc-text">内幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#话题和通道"><span class="toc-text">话题和通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Backend-DiskQueue"><span class="toc-text">Backend &#x2F; DiskQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#降低-GC-的压力"><span class="toc-text">降低 GC 的压力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-协议"><span class="toc-text">TCP 协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖"><span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#健壮性"><span class="toc-text">健壮性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#心跳和超时"><span class="toc-text">心跳和超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管理-Goroutines"><span class="toc-text">管理 Goroutines</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WaitGroups"><span class="toc-text">WaitGroups</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#退出信号"><span class="toc-text">退出信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#退出时的同步"><span class="toc-text">退出时的同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#日志"><span class="toc-text">日志</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nsq/53383d2f25c7478094becea995f48771.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangYangYang</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">NSQ概述</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-09-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-06</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/nsq/">nsq</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">10.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 36 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="NSQ概述"><a href="#NSQ概述" class="headerlink" title="NSQ概述"></a>NSQ概述</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>下面的步骤将通过推送(publishing)、消费(consuming)和归档(archiving)消息到本地磁盘，在本地环境演示一个小型的 <strong>NSQ</strong> 集群</p>
<ol>
<li><p>根据文档安装安装 NSQ。</p>
</li>
<li><p>在另外一个 shell 中，运行 <code>nsqlookupd</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nsqlookupd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再开启一个 shell，运行 <code>nsqd</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nsqd --lookupd-tcp-address=127.0.0.1:4160</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再开启第三个 shell，运行 <code>nsqadmin</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nsqadmin --lookupd-http-address=127.0.0.1:4161</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启第四个 shell，推送一条初始化数据(并且在集群中创建一个 topic):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">'hello world 1'</span> <span class="string">'http://127.0.0.1:4151/put?topic=test'</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，开启第五个 shell， 运行 <code>nsq_to_file</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nsq_to_file --topic=<span class="built_in">test</span> --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推送更多地数据到 <code>nsqd</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">'hello world 2'</span> <span class="string">'http://127.0.0.1:4151/put?topic=test'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">'hello world 3'</span> <span class="string">'http://127.0.0.1:4151/put?topic=test'</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照预先设想的，在浏览器中打开 <code>http://127.0.0.1:4171/</code> 就能查看 <code>nsqadmin</code> 的 UI 界面和队列统计数据。同时，还可以在 <code>/tmp</code> 目录下检查 (<code>test.*.log</code>) 文件.</p>
</li>
</ol>
<p>这个教程中最重要的是：<code>nsq_to_file</code> (客户端)没有明确地指出 <code>test</code> 主题从哪里产生，它从 <code>nsqlookupd</code> 获取信息，即使在消息推送之后才开始连接 nsqd，消息也并没有消失。</p>
<h2 id="特性和担保"><a href="#特性和担保" class="headerlink" title="特性和担保"></a>特性和担保</h2><p><strong>NSQ</strong> 是分布式实时消息系统。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>支持无 SPOF 的分布式拓扑</li>
<li>水平扩展(没有中间件，无缝地添加更多的节点到集群)</li>
<li>低延迟消息传递性能</li>
<li>结合负载均衡和多播消息路由风格</li>
<li>擅长面向流媒体(高通量)和工作(低吞吐量)工作负载</li>
<li>主要是内存中(除了高水位线消息透明地保存在磁盘上)</li>
<li>运行时发现消费者找到生产者服务(<a href="https://github.com/bitly/nsq/tree/master/nsqlookupd/README.md" target="_blank" rel="noopener">nsqlookupd</a>)</li>
<li>传输层安全性 (TLS)</li>
<li>数据格式不可知</li>
<li>一些依赖项(容易部署)和健全的，有界，默认配置</li>
<li>任何语言都有简单 TCP 协议支持客户端库</li>
<li>HTTP 接口统计、管理行为和生产者(<strong>不需要客户端库发布</strong>)</li>
<li>为实时检测集成了<a href="https://github.com/etsy/statsd/" target="_blank" rel="noopener">statsd</a> </li>
<li>健壮的集群管理界面 (<a href="https://github.com/bitly/nsq/tree/master/nsqadmin/README.md" target="_blank" rel="noopener">nsqadmin</a>)</li>
</ul>
<h3 id="担保"><a href="#担保" class="headerlink" title="担保"></a>担保</h3><p>对于任何分布式系统来说，都是通过智能权衡来实现目标。通过这些透明的可靠性指标，我们希望能使得 NSQ 在部署到产品上的行为是可达预期的。</p>
<h3 id="消息不可持久化（默认）"><a href="#消息不可持久化（默认）" class="headerlink" title="消息不可持久化（默认）"></a>消息不可持久化（默认）</h3><p>虽然系统支持消息持久化存储在磁盘中（通过 <code>--mem-queue-size</code> ），不过默认情况下消息都在<strong>内存</strong>中.</p>
<p>如果将 <code>--mem-queue-size</code> 设置为 0，所有的消息将会存储到磁盘。我们不用担心消息会丢失，nsq 内部机制保证在程序关闭时将队列中的数据持久化到硬盘，重启后就会恢复。</p>
<p>NSQ 没有内置的复制机制，却有各种各样的方法管理这种权衡，比如部署拓扑结构和技术，在容错的时候从属并持久化内容到磁盘。</p>
<h3 id="消息最少会被投递一次"><a href="#消息最少会被投递一次" class="headerlink" title="消息最少会被投递一次"></a>消息最少会被投递一次</h3><p>如上所述，这个假设成立于 <code>nsqd</code> 节点没有错误。</p>
<p>因为各种原因，消息可以被投递多次（客户端超时，连接失效，重新排队，等等）。由客户端负责操作。</p>
<h3 id="接收到的消息是无序的"><a href="#接收到的消息是无序的" class="headerlink" title="接收到的消息是无序的"></a>接收到的消息是无序的</h3><p>不要依赖于投递给消费者的消息的顺序。</p>
<p>和投递消息机制类似，它是由重新队列(requeues)，内存和磁盘存储的混合导致的，实际上，节点间不会共享任何信息。</p>
<p>它是相对的简单完成<strong>疏松队列</strong>，（例如，对于某个消费者来说，消息是有次序的，但是不能给你作为一个整体跨集群），通过使用时间窗来接收消息，并在处理前排序（虽然为了维持这个变量，必须抛弃时间窗外的消息）。</p>
<h3 id="消费者最终找出所有话题的生产者"><a href="#消费者最终找出所有话题的生产者" class="headerlink" title="消费者最终找出所有话题的生产者"></a>消费者最终找出所有话题的生产者</h3><p>这个服务(<a href="https://github.com/bitly/nsq/tree/master/nsqlookupd/README.md" target="_blank" rel="noopener">nsqlookupd</a>) 被设计成最终一致性。<code>nsqlookupd</code> 节点不会维持状态，也不会回答查询。</p>
<p>网络分区并不会影响可用性，分区的双方仍然能回答查询。部署性拓扑可以显著的减轻这类问题。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li><p><strong>有什么为 nsqd 推荐的拓扑结构?</strong></p>
<p>强烈推荐 <code>nsqd</code> 和<strong>生产</strong>消息的服务一起运行。</p>
<p><code>nsqd</code> 是一个相对轻量的进程，它能很好和其他进程协同运行。</p>
<p>这个模式有利于结构化消息流为一个消费问题，而不是一个生产问题。</p>
<p>另一个好处是它能将来自服务端的内容形成有效的独立，分享，简仓（silo）的数据。 </p>
<p>注意: 这并不是必须得要求，它只是能让事情简单些（参见下面的问题）。</p>
</li>
<li><p><strong>为什么不能用 nsqlookupd 来查询生产的内容给谁?</strong></p>
<p>NSQ 提升了<strong>消费端</strong>的发现模型，减轻了前期的配置负载（需要告诉所有消费者去那里找他们要的内容）。</p>
<p>然而，它并没有提供任何方法来解决发布端将内容发布给谁。这是鸡和蛋的问题，在发布前并不存在内容。</p>
<p>通过使用 <code>nsqd</code> ，你可以避开这个问题（你的服务只是简单的将内容发布给本地的 <code>nsqd</code>），并且允许 NSQ 实时发现系统正常运行。</p>
</li>
<li><p><strong>我只是想在某个节点上将 nsqd 作为一个工作队列来使用，有没有合适的例子?</strong></p>
<p>是的，<code>nsqd</code> 可以很好的单独运行。</p>
<p><code>nsqlookupd</code> 非常有利于大型分布式环境。</p>
</li>
<li><p><strong>我需要运行多少个 nsqlookupd ?</strong></p>
<p>依赖于集群的大小，<code>nsqd</code> 的节点数量，消费者，和你希望的容错能力。</p>
<p>3 个或 5 个就可以非常好的服务于百级别的主机和千级的消费者。</p>
<p><code>nsqlookupd</code> 节点不需要回答查询。集群里的元数据是最终一致的。</p>
</li>
</ul>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ul>
<li><p><strong>是否需要客户端库来发布消息?</strong></p>
<p>不需要！使用 HTTP 节点来发布消息就好（<code>/pub</code> 和 <code>/mpub</code>）。它简单，容易，在任意一个开发环境都可用。</p>
<p>绝大多数人使用 HTTP 来发布 NSQ 部署。</p>
</li>
<li><p><strong>为什么强制客户端响应 TCP 协议 PUB 和 MPUB 命令?</strong></p>
<p>我们相信 NSQ 操作的默认模式必须安全优先，并且我们希望协议简单并完整。</p>
</li>
<li><p><strong>什么时候 PUB 或 MPUB 会失败?</strong></p>
<ol>
<li><p>话题（topic）的名字没有正确格式化（长度限制）。参见<a href="http://wiki.jikexueyuan.com/project/nsq-guide/tcp_protocol_spec.html" target="_blank" rel="noopener">topic and channel name spec</a>。</p>
</li>
<li><p>消息过大(具体限制参见 <code>nsqd</code> 的参数)。</p>
</li>
<li><p>中间的话题（topic）被删除。</p>
</li>
<li><p><code>nsqd</code> 被清除。</p>
</li>
<li><p>发布的时候客户端产生连接失败</p>
<p>(1) 和 (2) 是开发错误。(3) 和 (4) 很少见， (5) 是基于 TCP 协议都会遇到的问题。</p>
</li>
</ol>
</li>
<li><p><strong>如何避免之前 (3) 出现的问题?</strong></p>
<p>删除话题（topic）是少见的操作。如果你想删除一个话题（topic），需要精确计算时间，确保删除后有充足的时间，发布的话题（topic）不会被执行。</p>
</li>
</ul>
<h3 id="设计和理论"><a href="#设计和理论" class="headerlink" title="设计和理论"></a>设计和理论</h3><ul>
<li><p><strong>如何命名话题（topic）和通道（channel）？</strong></p>
<p>话题（topic）名需要描述在流中的数据。</p>
<p>通道（channel）名需要描述消费者的工作类型。</p>
<p>例如, 好的话题（topic）名 <code>编码（encode）</code>, <code>解码（decode）</code>, <code>api_请求（api_request）</code>,<code>页面_视图</code> 。好的通道（channel）名<code>归档（archive）</code>, <code>分析_增长（analytics_increment）</code>,<code>垃圾_分析（spam_analysis）</code>。</p>
</li>
<li><p><strong>一个 nsqd 最多能支持多少个话题（topic）和通道（channel）?</strong></p>
<p>没有内置的限制。它仅和 <code>nsqd</code> 所在的服务端的内存，CPU 限制有关（每个客户端 CPU 使用率已经大为改进了<a href="https://github.com/bitly/nsq/pull/236" target="_blank" rel="noopener">issue #236</a>）。</p>
</li>
<li><p><strong>如何为集群声明一个新的话题（topic）?</strong></p>
<p>话题（topic）的第一个 <code>PUB</code> 或 <code>SUB</code> ，将会在 <code>nsqd</code> 上创建一个话题（topic）。话题（topic）的元数据将会传播给 <code>nsqlookupd</code> 的配置。其他的读者将会通过周期性的查询 <code>nsqlookupd</code> 发现这个话题（topic）。</p>
</li>
<li><p><strong>NSQ 能操作 RPC 吗?</strong></p>
<p>是的，有这个可能性, 但是 NSQ 并不是为它设计的。</p>
<p>我们想发布一些文档说明它是如何结构化的，如果你感兴趣，可以来帮我们。</p>
</li>
</ul>
<h3 id="特定的-pynsq"><a href="#特定的-pynsq" class="headerlink" title="特定的 pynsq"></a>特定的 pynsq</h3><ul>
<li><p><strong>为什么强制我使用 Tornado?</strong></p>
<p><code>pynsq</code> 初始设计的时候，就聚焦于消费端的库，并且 NSQ 协议和 Python 的异步架构非常类似（尤其和 NSQ 的面向推送协议）。</p>
<p>Tornado 的 API 非常简单并且执行合理。</p>
</li>
<li><p><strong>Tornado IOLoop 是否必须发布?</strong></p>
<p>不，<code>nsqd</code> 为了发布简单，暴露了 HTPP 端(<code>/pub</code> 和 <code>/mpub</code>) 。</p>
<p>不必担心 HTTP 的过载。同时，<code>/mpub</code> 通过批量发布，减少了 HTTP 的过载。</p>
</li>
<li><p><strong>那么什么时候使用 Writer?</strong></p>
<p>当高性能，低负载优先级比较高的时候。</p>
<p><code>Writer</code> 使用 TCP 协议里的 <code>PUB</code> 和 <code>MPUB</code> 命令， 它们比 HTTP  负载更低。</p>
</li>
<li><p><strong>如果我就想”启动并忘记“将会发生什么(我能容忍消息丢失!)?</strong></p>
<p>使用 <code>Writer</code> 并且不给发布的方法指定回调。</p>
<p>注意: 仅在简单的客户端代码有效， <code>pynsq</code> 场景必须处理 <code>nsqd</code> 的消息（比如，做这些事情不会导致性能提高）。</p>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="分布式性能"><a href="#分布式性能" class="headerlink" title="分布式性能"></a>分布式性能</h3><p>主仓库包含一段代码（<code>bench/bench.py</code>），它能在 EC2 上自动完成分布式基准。</p>
<p>它引导 <code>N</code> 个节点，一些运行 <code>nsqd</code>，一些运行加载生成工具（<code>PUB</code> 和 <code>SUB</code>），并分析它们的输出来提供聚合。        </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>下面的代码反应了默认参数6 <code>c3.2xlarge</code>，这个实例支持 1g 比特的连接。3 个节点运行 <code>nsqd</code>  实例，剩下的运行 <code>bench_reader</code> (<code>SUB</code>) 和 <code>bench_writer</code> (<code>PUB</code>) 实例，来生成依赖于基准模式的负载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench/bench.py --access-key=... --secret-key=... --ssh-key-name=...</span></span><br><span class="line">[I 140917 10:58:10 bench:102] launching 6 instances</span><br><span class="line">[I 140917 10:58:12 bench:111] waiting for instances to launch...</span><br><span class="line">...</span><br><span class="line">[I 140917 10:58:37 bench:130] (1) bootstrapping ec2-54-160-145-64.compute-1.amazonaws.com (i-0a018ce1)</span><br><span class="line">[I 140917 10:59:37 bench:130] (2) bootstrapping ec2-54-90-195-149.compute-1.amazonaws.com (i-0f018ce4)</span><br><span class="line">[I 140917 11:00:00 bench:130] (3) bootstrapping ec2-23-22-236-55.compute-1.amazonaws.com (i-0e018ce5)</span><br><span class="line">[I 140917 11:00:41 bench:130] (4) bootstrapping ec2-23-23-40-113.compute-1.amazonaws.com (i-0d018ce6)</span><br><span class="line">[I 140917 11:01:10 bench:130] (5) bootstrapping ec2-54-226-180-44.compute-1.amazonaws.com (i-0c018ce7)</span><br><span class="line">[I 140917 11:01:43 bench:130] (6) bootstrapping ec2-54-90-83-223.compute-1.amazonaws.com (i-10018cfb)</span><br></pre></td></tr></table></figure>

<h3 id="生产者吞吐量"><a href="#生产者吞吐量" class="headerlink" title="生产者吞吐量"></a>生产者吞吐量</h3><p>这个基准仅反应了生产者吞吐量。消息体有 100 个字节，并且消息通过 3 个话题（topic）分布。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench/bench.py --access-key=... --secret-key=... --ssh-key-name=... --mode=pub --msg-size=100 run</span></span><br><span class="line">[I 140917 12:39:37 bench:140] launching nsqd on 3 host(s)</span><br><span class="line">[I 140917 12:39:41 bench:163] launching 9 producer(s) on 3 host(s)</span><br><span class="line">...</span><br><span class="line">[I 140917 12:40:20 bench:248] [bench_writer] 10.002s - 197.463mb/s - 2070549.631ops/s - 4.830us/op</span><br></pre></td></tr></table></figure>

<p>入口处 <strong>~2.07mm</strong> msgs/sec,使用了 <strong>197mb/s</strong> 的带宽。</p>
<h3 id="生产和消费吞吐量"><a href="#生产和消费吞吐量" class="headerlink" title="生产和消费吞吐量"></a>生产和消费吞吐量</h3><p>通过服务生产者和消费者，这个基准更加准确的反应了实际情况。这个消息也是 100 个字节，并且通过 3 个话题（topic）分布，每个都包含一个 通道（channel）（每个 通道（channel） 24 个客户端）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench/bench.py --access-key=... --secret-key=... --ssh-key-name=... --msg-size=100 run</span></span><br><span class="line">[I 140917 12:41:11 bench:140] launching nsqd on 3 host(s)</span><br><span class="line">[I 140917 12:41:15 bench:163] launching 9 producer(s) on 3 host(s)</span><br><span class="line">[I 140917 12:41:22 bench:186] launching 9 consumer(s) on 3 host(s)</span><br><span class="line">...</span><br><span class="line">[I 140917 12:41:55 bench:248] [bench_reader] 10.252s - 76.946mb/s - 806838.610ops/s - 12.706us/op</span><br><span class="line">[I 140917 12:41:55 bench:248] [bench_writer] 10.030s - 80.315mb/s - 842149.615ops/s - 11.910us/op</span><br></pre></td></tr></table></figure>

<p>入口处的 <strong>~842k</strong>  <strong>~806k</strong> msgs/s, 合计消费带宽 <strong>156mb/s</strong>，我们已经尽力提升了 <code>nsqd</code> 节点的 CPU 处理能力。通过引入消费者，<code>nsqd</code> 需要维持每个 通道（channel），因此负载自然会高一点。</p>
<p>消费者的数量略微少于生产者，因为消费者发送2次命令（每个消息都要发送 <code>FIN</code> 命令）。</p>
<p>增加两个节点（一个是 <code>nsqd</code> 另一个是产生负载），达到了 <strong>1mm</strong> msgs/s：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench/bench.py --access-key=... --secret-key=... --ssh-key-name=... --msg-size=100 run</span></span><br><span class="line">[I 140917 13:38:28 bench:140] launching nsqd on 4 host(s)</span><br><span class="line">[I 140917 13:38:32 bench:163] launching 16 producer(s) on 4 host(s)</span><br><span class="line">[I 140917 13:38:43 bench:186] launching 16 consumer(s) on 4 host(s)</span><br><span class="line">...</span><br><span class="line">[I 140917 13:39:12 bench:248] [bench_reader] 10.561s - 100.956mb/s - 1058624.012ops/s - 9.976us/op</span><br><span class="line">[I 140917 13:39:12 bench:248] [bench_writer] 10.023s - 105.898mb/s - 1110408.953ops/s - 9.026us/op</span><br></pre></td></tr></table></figure>

<h3 id="单个节点性能"><a href="#单个节点性能" class="headerlink" title="单个节点性能"></a>单个节点性能</h3><p>声明：请牢记 <strong>NSQ</strong> 设计的初衷是分布式。单个节点的性能非常重要，但这并不是我们所追求的。</p>
<ul>
<li>2012 MacBook Air i7 2ghz</li>
<li>go1.2</li>
<li>NSQ v0.2.24</li>
<li>200 byte messages</li>
</ul>
<h3 id="GOMAXPROCS-1-单个生产者，单个消费者"><a href="#GOMAXPROCS-1-单个生产者，单个消费者" class="headerlink" title="GOMAXPROCS=1 (单个生产者，单个消费者)"></a>GOMAXPROCS=1 (单个生产者，单个消费者)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench.sh </span></span><br><span class="line">results...</span><br><span class="line">PUB: 2014/01/12 22:09:08 duration: 2.311925588s - 82.500mb/s - 432539.873ops/s - 2.312us/op</span><br><span class="line">SUB: 2014/01/12 22:09:19 duration: 6.009749983s - 31.738mb/s - 166396.273ops/s - 6.010us/op</span><br></pre></td></tr></table></figure>

<h3 id="GOMAXPROCS-4-4-个生产者-4-个消费者"><a href="#GOMAXPROCS-4-4-个生产者-4-个消费者" class="headerlink" title="GOMAXPROCS=4 (4 个生产者, 4 个消费者)"></a>GOMAXPROCS=4 (4 个生产者, 4 个消费者)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bench.sh </span></span><br><span class="line">results...</span><br><span class="line">PUB: 2014/01/13 16:58:05 duration: 1.411492441s - 135.130mb/s - 708469.965ops/s - 1.411us/op</span><br><span class="line">SUB: 2014/01/13 16:58:16 duration: 5.251380583s - 36.321mb/s - 190426.114ops/s - 5.251us/op</span><br></pre></td></tr></table></figure>

<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>注意：可视化的演示参见 <a href="https://speakerdeck.com/snakes/nsq-nyc-golang-meetup" target="_blank" rel="noopener">slide deck</a>。</p>
<p><strong>NSQ</strong> 是继承于 <a href="https://github.com/bitly/simplehttp/tree/master/simplequeue" target="_blank" rel="noopener">simplequeue</a>(部分的 <a href="https://github.com/bitly/simplehttp/tree/master/simplequeue" target="_blank" rel="noopener">simplequeue</a>)，因此被设计为（排名不分先后）</p>
<ul>
<li>提供更简单的拓扑方案，达到高可用性和消除单点故障</li>
<li>满足更强的消息可靠传递的保证</li>
<li>限制单个进程的内存占用（通过持久化一些消息到硬盘上）</li>
<li>极大简化了生产者和消费者的配置要求</li>
<li>提供了一个简单的升级路径</li>
<li>提升效率</li>
</ul>
<h3 id="简化配置和管理"><a href="#简化配置和管理" class="headerlink" title="简化配置和管理"></a>简化配置和管理</h3><p>单个 <code>nsqd</code> 实例被设计成可以同时处理多个数据流。流被称为“话题”和话题有 1 个或多个“通道”。每个通道都接收到一个话题中所有消息的拷贝。在实践中，一个通道映射到下行服务消费一个话题.</p>
<p>话题和通道都没有预先配置。话题由第一次发布消息到命名的话题或第一次通过订阅一个命名话题来创建。通道被第一次订阅到指定的通道创建。</p>
<p>话题 和通道的所有缓冲的数据相互独立，防止缓慢消费者造成对其他通道的积压（同样适用于话题级别）。</p>
<p>一个通道一般会有多个客户端连接。假设所有已连接的客户端处于准备接收消息的状态，每个消息将被传递到一个随机的客户端。例如：</p>
<p><img src="/" alt="nsqd clients" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/design1.gif"></p>
<p>总之，消息从话题-&gt;通道是多路传送的（每个通道接收的所有该话题消息的副本），即使均匀分布在通道-&gt;消费者之间（每个消费者收到该通道的消息的一部分）。</p>
<p><strong>NSQ</strong> 还包括一个辅助应用程序，<code>nsqlookupd</code>，它提供了一个目录服务，消费者可以查找到提供他们感兴趣订阅话题的 <code>nsqd</code> 地址 。在配置方面，把消费者与生产者解耦开（它们都分别只需要知道哪里去连接 <code>nsqlookupd</code> 的共同实例，而不是对方），降低复杂性和维护。</p>
<p>在更底的层面，每个 <code>nsqd</code> 有一个与 <code>nsqlookupd</code> 的长期 TCP 连接，定期推动其状态。这个数据被 <code>nsqlookupd</code> 用于给消费者通知 <code>nsqd</code> 地址。对于消费者来说，一个暴露的 HTTP <code>/lookup</code> 接口用于轮询。</p>
<p>为话题引入一个新的消费者，只需启动一个配置了 nsqlookup 实例地址的 <strong>NSQ</strong> 客户端。无需为添加任何新的消费者或生产者更改配置，大大降低了开销和复杂性。</p>
<p>注：在将来的版本中，启发式 <code>nsqlookupd</code> 可以基于深度，已连接的客户端数量，或其他“智能”策略来返回地址。当前的实现是简单的返回所有地址。最终的目标是要确保所有深度接近零的生产者被读取。</p>
<p>值得注意的是，重要的是 <code>nsqd</code> 和 <code>nsqlookupd</code> 守护进程被设计成独立运行，没有相互之间的沟通或协调。</p>
<p>我们还认为重要的是有一个方式来聚合查看，监测，并管理集群。我们建立 <code>nsqadmin</code> 做到这一点。它提供了一个  Web UI 来浏览 topics/channels/consumers  和深度检查每一层的关键统计数据。此外，它还支持几个管理命令例如，移除通道和清空通道（这是一个有用的工具，当在一个通道中的信息可以被安全地扔掉，以使深度返回到  0）。</p>
<p><img src="/" alt="nsqadmin" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/design2.png"></p>
<h3 id="简单的升级路径"><a href="#简单的升级路径" class="headerlink" title="简单的升级路径"></a>简单的升级路径</h3><p>这是我们的高优先级之一。我们的生产系统处理大量的流量，都建立在我们现有的消息工具上，所以我们需要一种方法来慢慢地，有条不紊地升级我们特定部分的基础设施，而不产生任何影响。</p>
<p>首先，在消息<em>生产者</em>方面，我们建立 <code>nsqd</code> 匹配 <a href="https://github.com/bitly/simplehttp/tree/master/simplequeue" target="_blank" rel="noopener">simplequeue</a>。具体来说，<code>nsqd</code> 暴露了一个 HTTP /PUT 端点，就像 simplequeue，上传二进制数据（需要注意的一点是 endpoint 需要一个额外的查询参数来指定”话题”）。想切换到发布消息到 <code>nsqd</code> 的服务只需要很少的代码变更。</p>
<p>第二，我们建立了兼容已有库功能和语义的 Python 和 Go 库。这使得消息的消费者通过很少的代码改变就可使用。所有的业务逻辑保持不变。</p>
<p>最后，我们建立工具连接起新旧组件。这些都在仓库的示例（<code>examples</code>）目录中：</p>
<ul>
<li><code>nsq_pubsub</code> - 在 <strong>NSQ</strong> 集群中以 HTTP 接口的形式暴露的一个 <code>pubsub</code>  </li>
<li><code>nsq_to_file</code> - 将一个给定话题的所有消息持久化到文件</li>
<li><code>nsq_to_http</code> - 对一个话题的所有消息的执行 HTTP 请求到（多个）endpoints。</li>
</ul>
<h3 id="消除单点故障"><a href="#消除单点故障" class="headerlink" title="消除单点故障"></a>消除单点故障</h3><p>NSQ被设计以分布的方式被使用。<code>nsqd</code> 客户端（通过 TCP ）连接到指定话题的所有生产者实例。没有中间人，没有消息代理，也没有单点故障：</p>
<p><img src="/" alt="nsq clients" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/design3.png"></p>
<p>这种拓扑结构消除单链，聚合，反馈。相反，你的消费者直接访问所有生产者。<em>从技术上讲</em>，哪个客户端连接到哪个 <strong>NSQ</strong> 不重要，只要有足够的消费者连接到所有生产者，以满足大量的消息，保证所有东西最终将被处理。</p>
<p>对于 <code>nsqlookupd</code>，高可用性是通过运行多个实例来实现。他们不直接相互通信和数据被认为是最终一致。消费者轮询所有的配置的 <code>nsqlookupd</code> 实例和合并 response。失败的，无法访问的，或以其他方式故障的节点不会让系统陷于停顿。</p>
<h3 id="消息传递担保"><a href="#消息传递担保" class="headerlink" title="消息传递担保"></a>消息传递担保</h3><p><strong>NSQ</strong> 保证消息将交付至少一次，虽然消息可能是重复的。消费者应该关注到这一点，删除重复数据或执行<a href="http://en.wikipedia.org/wiki/Idempotence" target="_blank" rel="noopener">idempotent</a>等操作</p>
<p>这个担保是作为协议和工作流的一部分，工作原理如下（假设客户端成功连接并订阅一个话题）：</p>
<ol>
<li>客户表示他们已经准备好接收消息</li>
<li><strong>NSQ</strong> 发送一条消息，并暂时将数据存储在本地（在 re-queue 或 timeout）</li>
<li>客户端回复 FIN（结束）或 REQ（重新排队）分别指示成功或失败。如果客户端没有回复, <strong>NSQ</strong> 会在设定的时间超时，自动重新排队消息</li>
</ol>
<p>这确保了消息丢失唯一可能的情况是不正常结束 <code>nsqd</code> 进程。在这种情况下，这是在内存中的任何信息（或任何缓冲未刷新到磁盘）都将丢失。</p>
<p>如何防止消息丢失是最重要的，即使是这个意外情况可以得到缓解。一种解决方案是构成冗余 <code>nsqd</code>对（在不同的主机上）接收消息的相同部分的副本。因为你实现的消费者是幂等的，以两倍时间处理这些消息不会对下游造成影响，并使得系统能够承受任何单一节点故障而不会丢失信息。</p>
<p>附加的是 <strong>NSQ</strong> 提供构建基础以支持多种生产用例和持久化的可配置性。</p>
<h3 id="限定内存占用"><a href="#限定内存占用" class="headerlink" title="限定内存占用"></a>限定内存占用</h3><p><code>nsqd</code> 提供一个 <code>--mem-queue-size</code> 配置选项，这将决定一个队列保存在内存中的消息数量。如果队列深度超过此阈值，消息将透明地写入磁盘。<code>nsqd</code> 进程的内存占用被限定于 <code>--mem-queue-size * #of_channels_and_topics</code>：</p>
<p><img src="/" alt="message overflow" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/design4.png"></p>
<p>此外，一个精明的观察者可能会发现，这是一个方便的方式来获得更高的传递保证：把这个值设置的比较低（如 1 或甚至是 0）。磁盘支持的队列被设计为在不重启的情况下存在（虽然消息可能被传递两次）。</p>
<p>此外，涉及到信息传递保证，干净关机（通过给 <code>nsqd</code> 进程发送 TERM 信号）坚持安全地把消息保存在内存中，传输中，延迟，以及内部的各种缓冲区。</p>
<p>请注意，一个以 <code>#ephemeral</code> 结束的通道名称不会在超过 <code>mem-queue-size</code> 之后刷新到硬盘。这使得消费者并不需要订阅频道的消息担保。这些临时通道将在最后一个客户端断开连接后消失。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p><strong>NSQ</strong> 被设计成一个使用简单 size-prefixed  为前缀的，与“memcached-like”类似的命令协议。所有的消息数据被保持在核心中，包括像尝试次数、时间截等元数据类。这消除了数据从服务器到客户端来回拷贝，当重新排队消息时先前工具链的固有属性。这也简化了客户端，因为他们不再需要负责维护消息的状态。</p>
<p>此外，通过降低配置的复杂性，安装和开发的时间大大缩短（尤其是在有超过 &gt; 1 消费者的话题）。</p>
<p>对于数据的协议，我们做了一个重要的设计决策，通过推送数据到客户端最大限度地提高性能和吞吐量的，而不是等待客户端拉数据。这个概念，我们称之为 <code>RDY</code> 状态，基本上是客户端流量控制的一种形式。</p>
<p>当客户端连接到 <code>nsqd</code> 和并订阅到一个通道时，它被放置在一个 <code>RDY</code> 为 0 状态。这意味着，还没有信息被发送到客户端。当客户端已准备好接收消息发送，更新它的命令 RDY 状态到它准备处理的数量，比如 100。无需任何额外的指令，当 100 条消息可用时，将被传递到客户端（服务器端为那个客户端每次递减 RDY 计数）。</p>
<p>客户端库的被设计成在 <code>RDY</code> 数达到配置 <code>max-in-flight</code> 的 25% 发送一个命令来更新 RDY 计数（并适当考虑连接到多个 <code>nsqd</code> 情况下，适当地分配）。</p>
<p><img src="/" alt="nsq protocol" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/design5.png"></p>
<p>这是一个重要的性能控制，使一些下游系统能够更轻松地批量处理信息，并从更高的 <code>max-in-flight</code> 中受益。</p>
<p>值得注意的是，因为它既是基于缓冲和推送来满足需要(通道)流的独立副本的能力，我们已经提供了行为像 <code>simplequeue</code> 和 pubsub 相结合的守护进程。这是简化我们的系统拓扑结构的强大工具，如上述讨论那样我们会维护传统的 toolchain。</p>
<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>我们很早做了一个战略决策，利用 <a href="http://golang.org" target="_blank" rel="noopener">Go</a> 来建立 <strong>NSQ</strong> 的核心。我们最近的博客上讲述我们在 bitly 如何使用 Go，并提到这个适合的项目-通过浏览那篇文章可能对理解我们如何重视这么语言有所帮助。</p>
<p>关于 <strong>NSQ</strong> ，Go channels（不要与 <strong>NSQ</strong> 通道混淆），并且内置并发性功能的语言的非常适合于的 <code>nsqd</code>的内部工作。我们充分利用缓冲的通道来管理我们在内存中的消息队列和无缝把溢出消息放到硬盘。</p>
<p>标准库让我们很容易地编写网络层和客户端代码。只需要付出很少的努力，来整合内置的内存和 CPU 剖析进行优化。我们还发现它易于单独测试组件，模拟类型接口，以迭代方式构建功能。</p>
<h2 id="内幕"><a href="#内幕" class="headerlink" title="内幕"></a>内幕</h2><p>NSQ 由 3 个守护进程组成：</p>
<ul>
<li><strong>nsqd</strong> 是接收、队列和传送消息到客户端的守护进程。</li>
<li><strong>nsqlookupd</strong> 是管理的拓扑信息，并提供了最终一致发现服务的守护进程。</li>
<li><strong>nsqadmin</strong> 是一个 Web UI 来实时监控集群（和执行各种管理任务）。</li>
</ul>
<p>在 NSQ 数据流建模为一个消息流和消费者的树。一个<strong>话题（topic）</strong>是一个独特的数据流。一个 <strong>通道（channel）</strong> 是消费者订阅了某个 <strong>话题</strong> 的逻辑分组。</p>
<p><img src="/" alt="topics/channels" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/internal1.gif"></p>
<p>单个 nsqd 可以有很多的话题，每个话题可以有多通道。一个通道接收到一个话题中所有消息的副本，启用组播方式的传输，使消息同时在每个通道的所有订阅用户间分发，从而实现负载平衡。</p>
<p>这些原语组成一个强大的框架，用于表示各种<a href="http://nsq.io/deployment/topology_patterns.html" target="_blank" rel="noopener">简单和复杂的拓扑结构</a>。</p>
<p>有关 NSQ 的设计的更多信息请参见<a href="http://nsq.io/overview/design.html" target="_blank" rel="noopener">设计文档</a>。</p>
<h3 id="话题和通道"><a href="#话题和通道" class="headerlink" title="话题和通道"></a>话题和通道</h3><p>话题（topic）和通道（channel），NSQ 的核心基础，最能说明如何把 Go 语言的特点无缝地转化为系统设计。</p>
<p>Go 语言中的通道（channel）（为消除歧义以下简称为“go-chan”）是实现队列一种自然的方式，因此一个 NSQ 话题（topic）/通道（channel），其核心，只是一个缓冲的 go-chan <code>Message</code>指针。缓冲区的大小等于 <code>--mem-queue-size</code> 的配置参数。</p>
<p>在懂了读数据后，发布消息到一个话题（topic）的行为涉及到：</p>
<ol>
<li>消息结构的初始化（和消息体的内存分配）</li>
<li>获取 <code>话题（topic）</code> 时的读-锁；</li>
<li>是否能发布的读-锁；</li>
<li>发布缓存的 go-chan</li>
</ol>
<p>从一个话题中的通道获取消息不能依赖于经典的 go-chan 语义，因为多个 goroutines 在一个 go-chan 上接收消息将会分发消息，而最终要的结果是复制每个消息到每一个通道（goroutine）。</p>
<p>替代的是，每个话题维护着 3 个主要的 goroutines。第一个被称为 <code>router</code>，它负责用来从 incoming go-chan 读取最近发布的消息，并把消息保存到队列中（内存或硬盘）。</p>
<p>第二个，称为 <code>messagePump</code>，是负责复制和推送消息到如上所述的通道。</p>
<p>第三个是负责 DiskQueue IO 和将在后面讨论。</p>
<p>通道是一个有点复杂，但共享着 go-chan 单一输入和输出（抽象出来的事实是，在内部，消息可能会在内存或磁盘上）：</p>
<p><img src="/" alt="queue goroutine" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/internal2.png"></p>
<p>此外，每个通道的维护负责 2 个时间排序优先级队列，用来实现传输中（in-flight）消息超时（第 2 个随行 goroutines 用于监视它们）。</p>
<p>并行化的提高是通过每个数据结构管理一个通道，而不是依靠 Go 运行时的全局定时器调度。</p>
<p><strong>注意</strong>：在内部，Go 运行时使用一个单一优先级队列和的 goroutine 来管理定时器。这支持（但不局限于）的整个 <code>time</code> package。它通常避免了需要一个用户空间的时间顺序的优先级队列，但要意识到这是一个很重要的一个有着单一锁的数据结构，有可能影响<code>GOMAXPROCS &gt; 1</code> 的表现。</p>
<h3 id="Backend-DiskQueue"><a href="#Backend-DiskQueue" class="headerlink" title="Backend / DiskQueue"></a>Backend / DiskQueue</h3><p>NSQ 的设计目标之一就是要限定保持在内存中的消息数。它通过 <code>DiskQueue</code> 透明地将溢出的消息写入到磁盘上（对于一个话题或通道而言，<code>DiskQueue</code> 拥有的第三个主要的 goroutine）。</p>
<p>由于内存队列只是一个 go-chan，把消息放到内存中显得不重要，如果可能的话，则退回到磁盘：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for msg := range c.incomingMsgChan &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case c.memoryMsgChan &lt;- msg:</span><br><span class="line">    default:</span><br><span class="line">        err := WriteMessageToBackend(&amp;msgBuf, msg, c.backend)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            // ... handle errors ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到 Go <code>select</code> 语句的优势在于用在短短的几行代码实现这个功能：<code>default</code> 语句只在 <code>memoryMsgChan</code> 已满的情况下执行。</p>
<p>NSQ 还具有的临时通道的概念。临时的通道将丢弃溢出的消息（而不是写入到磁盘），在没有客户端订阅时消失。这是一个完美的 Go’s Interface 案例。话题和通道有一个结构成员声明为一个 <code>Backend</code> interface，而不是一个具体的类型。正常的话题和通道使用 <code>DiskQueue</code>，而临时通道连接在 <code>DummyBackendQueue</code>中，它实现了一个 no-op 的<code>Backend</code>。</p>
<h3 id="降低-GC-的压力"><a href="#降低-GC-的压力" class="headerlink" title="降低 GC 的压力"></a>降低 GC 的压力</h3><p>在任何垃圾回收环境中，你可能会关注到吞吐量量（做无用功），延迟（响应），并驻留集大小（footprint）。</p>
<p>Go 的1.2版本，GC 采用，mark-and-sweep (parallel), non-generational,  non-compacting, stop-the-world 和 mostly precise。这主要是因为剩余的工作未完成（它预定于Go  1.3 实现）。</p>
<p>Go 的 GC 一定会不断改进，但普遍的真理是：<strong>你创建的垃圾越少，收集的时间越少</strong>。</p>
<p>首先，重要的是要了解 GC 在真实的工作负载下是如何表现。为此，<strong>nsqd</strong> 以 <a href="https://github.com/etsy/statsd/" target="_blank" rel="noopener">statsd</a> 格式发布的 GC 统计（伴随着其他的内部指标）。<strong>nsqadmin</strong> 显示这些度量的图表，让您洞察 GC 的影响，频率和持续时间：</p>
<p><img src="/" alt="single node view" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/blog/nsq/internal3.png"></p>
<p>为了切实减少垃圾，你需要知道它是如何生成的。再次 Go toolchain 提供了答案：</p>
<ol>
<li>使用 <a href="http://golang.org/pkg/testing/" target="_blank" rel="noopener"><code>testing</code></a> package 和 <code>go test -benchmem</code> 来 benchmark 热点代码路径。它分析每个迭代分配的内存数量（和 benchmark 运行可以用 <a href="http://golang.org/misc/benchcmp" target="_blank" rel="noopener"><code>benchcmp</code></a> 进行比较）。</li>
<li>编译时使用 go build -gcflags -m，会输出<a href="http://en.wikipedia.org/wiki/Escape_analysis" target="_blank" rel="noopener">逃逸分析</a>的结果。</li>
</ol>
<p>考虑到这一点，下面的优化证明对 <strong>nsqd</strong> 是有用的:</p>
<ol>
<li>避免 <code>[]byte</code> 到 <code>string</code> 的转换</li>
<li>buffers 或 object 的重新利用（并且某一天可能面临 <a href="https://groups.google.com/forum/#!topic/golang-dev/kJ_R6vYVYHU" target="_blank" rel="noopener"><code>sync.Pool</code></a> 又名 <a href="https://code.google.com/p/go/issues/detail?id=4720" target="_blank" rel="noopener">issue 4720</a>）</li>
<li>预先分配 slices(在 <code>make</code> 时指定容量)并且总是知道其中承载元素的数量和大小</li>
<li>对各种配置项目使用一些明智的限制（例如消息大小）</li>
<li>避免装箱（使用 <code>interface{}</code>）或一些不必要的包装类型（例如一个多值的”go-chan” 结构体）</li>
<li>避免在热点代码路径使用 <code>defer</code> (它也消耗内存)</li>
</ol>
<h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>NSQ 的 TCP 协议 <a href="http://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">protocol_spec</a> 是一个这些 GC 优化概念发挥了很大作用的的例子。</p>
<p>该协议用含有长度前缀的帧构造，使其可以直接高效的编码和解码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[x][x][x][x][x][x][x][x][x][x][x][x]...</span><br><span class="line">|  (int32) ||  (int32) || (binary)</span><br><span class="line">|  4-byte  ||  4-byte  || N-byte</span><br><span class="line">------------------------------------...</span><br><span class="line">    size      frame ID     data</span><br></pre></td></tr></table></figure>

<p>由于提前知道了帧部件的确切类型与大小，我们避免了 <a href="http://golang.org/pkg/encoding/binary/" target="_blank" rel="noopener"><code>encoding/binary</code></a> 便利 <a href="http://golang.org/pkg/encoding/binary/#Read" target="_blank" rel="noopener"><code>Read()</code></a> 和 <a href="http://golang.org/pkg/encoding/binary/#Write" target="_blank" rel="noopener"><code>Write()</code></a> 包装（以及它们外部 interface 的查询与转换），而是直接调用相应的 <a href="http://golang.org/pkg/encoding/binary/#ByteOrder" target="_blank" rel="noopener"><code>binary.BigEndian</code></a> 方法。</p>
<p>为了减少 socket 的 IO 系统调用，客户端 <code>net.Conn</code> 都用 <a href="http://golang.org/pkg/bufio/#Reader" target="_blank" rel="noopener"><code>bufio.Reader</code></a> 和<a href="http://golang.org/pkg/bufio/#Writer" target="_blank" rel="noopener"><code>bufio.Writer</code></a> 包装。<code>Reader</code> 暴露了 <a href="http://golang.org/pkg/bufio/#Reader.ReadSlice" target="_blank" rel="noopener"><code>ReadSlice()</code></a> ，它会重复使用其内部缓冲区。这几乎消除了从 socket 读出数据的内存分配，大大降低 GC 的压力。这可能是因为与大多数命令关联的数据不会被忽视（在边缘情况下，这是不正确的，数据是显示复制的）。</p>
<p>在一个更低的水平，提供一个 <code>MessageID</code> 被声明为 <code>[16]byte</code>，以便能够把它作为一个 <code>map</code> key（slice 不能被用作 map key）。然而，由于从 socket 读取数据存储为 <code>[]byte</code>，而不是通过分配字符串键产生垃圾，并避免从 slice 的副本拷贝的数组形式的<code>MessageID</code>， <code>unsafe</code> package 是用来直接把 slice 转换成一个 <code>MessageID</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id := *(*nsq.MessageID)(unsafe.Pointer(&amp;msgID))</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>： 这是一个 <em>hack</em>。它将不是必要的，如果编译器优 和 <a href="https://code.google.com/p/go/issues/detail?id=3512" target="_blank" rel="noopener">Issue 3512</a> 解决这个问题。另外值得一读通过<a href="https://code.google.com/p/go/issues/detail?id=5376" target="_blank" rel="noopener">issue 5376</a>，其中谈到的“const like” <code>byte</code> 类型 与 <code>string</code> 类型可以互换使用，而不需要分配和复制。</p>
<p>同样，Go 标准库只提供了一个数字转换成 <code>string</code> 的方法。为了避免 <code>string</code> 分配，nsqd 使用一个自定义的10进制转换方法在 []byte 直接操作。</p>
<p>这些看似微观优化，但却包含了 TCP 协议中一些最热门的代码路径。总体而言，每秒上万消息的速度，对分配和开销的数目显著影响：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">benchmark                    old ns/op    new ns/op    delta</span><br><span class="line">BenchmarkProtocolV2Data           3575         1963  -45.09%</span><br><span class="line"></span><br><span class="line">benchmark                    old ns/op    new ns/op    delta</span><br><span class="line">BenchmarkProtocolV2Sub256        57964        14568  -74.87%</span><br><span class="line">BenchmarkProtocolV2Sub512        58212        16193  -72.18%</span><br><span class="line">BenchmarkProtocolV2Sub1k         58549        19490  -66.71%</span><br><span class="line">BenchmarkProtocolV2Sub2k         63430        27840  -56.11%</span><br><span class="line"></span><br><span class="line">benchmark                   old allocs   new allocs    delta</span><br><span class="line">BenchmarkProtocolV2Sub256           56           39  -30.36%</span><br><span class="line">BenchmarkProtocolV2Sub512           56           39  -30.36%</span><br><span class="line">BenchmarkProtocolV2Sub1k            56           39  -30.36%</span><br><span class="line">BenchmarkProtocolV2Sub2k            58           42  -27.59%</span><br></pre></td></tr></table></figure>

<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>NSQ 的 HTTP API 是建立在 Go 的 net/http 包之上。因为它只是 <a href="http://golang.org/pkg/net/http/" target="_blank" rel="noopener"><code>net/http</code></a>，它可以利用没有特殊的客户端库的几乎所有现代编程环境。</p>
<p>它的简单性掩盖了它的能力，作为 Go 的 HTTP tool-chest 最有趣的方面之一是广泛的调试功能支持。该 <a href="http://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener"><code>net/http/pprof</code></a> 包直接集成了原生的 HTTP 服务器，暴露获取 CPU，堆，goroutine 和操作系统线程性能的 endpoints。这些可以直接从 <code>go</code> tool 找到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof http://127.0.0.1:4151/debug/pprof/profile</span></span><br></pre></td></tr></table></figure>

<p>这对调试和分析一个运行的进程非常有价值！</p>
<p>此外，<code>/stats</code> endpoint 返回的指标以任何 JSON 或良好格式的文本来呈现，很容易使管理员能够实时从命令行监控：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch -n 0.5 <span class="string">'curl -s http://127.0.0.1:4151/stats | grep -v connected'</span></span></span><br></pre></td></tr></table></figure>

<p>这产生的连续输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[page_views     ] depth: 0     be-depth: 0     msgs: 105525994 e2e%: 6.6s, 6.2s, 6.2s</span><br><span class="line">    [page_view_counter        ] depth: 0     be-depth: 0     inflt: 432  def: 0    re-q: 34684 timeout: 34038 msgs: 105525994 e2e%: 5.1s, 5.1s, 4.6s</span><br><span class="line">    [realtime_score           ] depth: 1828  be-depth: 0     inflt: 1368 def: 0    re-q: 25188 timeout: 11336 msgs: 105525994 e2e%: 9.0s, 9.0s, 7.8s</span><br><span class="line">    [variants_writer          ] depth: 0     be-depth: 0     inflt: 592  def: 0    re-q: 37068 timeout: 37068 msgs: 105525994 e2e%: 8.2s, 8.2s, 8.2s</span><br><span class="line"></span><br><span class="line">[poll_requests  ] depth: 0     be-depth: 0     msgs: 11485060 e2e%: 167.5ms, 167.5ms, 138.1ms</span><br><span class="line">    [social_data_collector    ] depth: 0     be-depth: 0     inflt: 2    def: 3    re-q: 7568  timeout: 402   msgs: 11485060 e2e%: 186.6ms, 186.6ms, 138.1ms</span><br><span class="line"></span><br><span class="line">[social_data    ] depth: 0     be-depth: 0     msgs: 60145188 e2e%: 199.0s, 199.0s, 199.0s</span><br><span class="line">    [events_writer            ] depth: 0     be-depth: 0     inflt: 226  def: 0    re-q: 32584 timeout: 30542 msgs: 60145188 e2e%: 6.7s, 6.7s, 6.7s</span><br><span class="line">    [social_delta_counter     ] depth: 17328 be-depth: 7327  inflt: 179  def: 1    re-q: 155843 timeout: 11514 msgs: 60145188 e2e%: 234.1s, 234.1s, 231.8s</span><br><span class="line"></span><br><span class="line">[time_on_site_ticks] depth: 0     be-depth: 0     msgs: 35717814 e2e%: 0.0ns, 0.0ns, 0.0ns</span><br><span class="line">    [tail821042#ephemeral     ] depth: 0     be-depth: 0     inflt: 0    def: 0    re-q: 0     timeout: 0     msgs: 33909699 e2e%: 0.0ns, 0.0ns, 0.0ns</span><br></pre></td></tr></table></figure>

<p>最后，每个 Go release 版本带来可观的 HTTP 性能提升<a href="https://github.com/davecheney/autobench" target="_blank" rel="noopener">autobench</a>。与 Go 的最新版本重新编译时，它总是很高兴为您提供免费的性能提升！</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>对于其它生态系统，Go 依赖关系管理（或缺乏）的哲学需要一点时间去适应。</p>
<p>NSQ 从一个单一的巨大仓库衍化而来的，包含相关的 imports 和小到未分离的内部 packages，完全遵守构建和依赖管理的最佳实践。</p>
<p>有两大流派的思想：</p>
<ol>
<li><strong>Vendoring</strong>: 拷贝正确版本的依赖到你的应用程序的仓库，并修改您的 import 路径来引用本地副本。</li>
<li><strong>Virtual Env</strong>: 列出你在构建时所需要的依赖版本，产生一种原生的 <code>GOPATH</code> 环境变量包含这些固定依赖。</li>
</ol>
<p><strong>注:</strong> 这确实只适用于二进制包，因为它没有任何意义的一个导入的包，使中间的决定，如一种依赖使用的版本。</p>
<p>NSQ 使用 <strong>gpm</strong> 提供如上述2种的支持。</p>
<p>它的工作原理是在 <a href="https://github.com/bitly/nsq/blob/master/Godeps" target="_blank" rel="noopener"><code>Godeps</code></a> 文件记录你的依赖，方便日后构建 GOPATH 环境。为了编译，它在环境里包装并执行的标准 Go toolchain。该 Godeps 文件仅仅是 JSON 格式，可以进行手工编辑。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>Go 提供了编写测试和基准测试的内建支持，这使用 Go 很容易并发操作进行建模，这是微不足道的建立起来的一个完整的实例 nsqd 到您的测试环境中。</p>
<p>然而，最初实现有可能变成测试问题的一个方面：全局状态。最明显的 offender 是运行时使用该持有 nsqd 的引用实例的全局变量，例如包含配置元数据和到 parent nsqd 的引用。</p>
<p>某些测试会使用短形式的变量赋值，无意中在局部范围掩盖这个全局变量，即 <code>nsqd := NewNSQd(...)</code> 。这意味着，全局引用没有指向了当前正在运行的实例，破坏了测试实例。</p>
<p>要解决这个问题，一个包含配置元数据和到 parent nsqd 的引用上下文结构被传来传去。到全局状态的所有引用都替换为本地的语境，允许 children（话题（topic），通道（channel），协议处理程序等）来安全地访问这些数据，使之更可靠的测试。</p>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>一个面对不断变化的网络条件或突发事件不健壮的系统，不会是一个在分布式生产环境中表现良好的系统。</p>
<p>NSQ 设计和的方式是使系统能够容忍故障而表现出一致的，可预测的和令人吃惊的方式来实现。</p>
<p>总体理念是快速失败，把错误当作是致命的，并提供了一种方式来调试发生的任何问题。</p>
<p>但是，为了应对，你需要能够检测异常情况。</p>
<h4 id="心跳和超时"><a href="#心跳和超时" class="headerlink" title="心跳和超时"></a>心跳和超时</h4><p>NSQ 的 TCP 协议是面向 push 的。在建立连接，握手，和订阅后，消费者被放置在一个为 0 的 <code>RDY</code> 状态。当消费者准备好接收消息，它更新的 <code>RDY</code> 状态到准备接收消息的数量。NSQ 客户端库不断在幕后管理，消息控制流的结果。</p>
<p>每隔一段时间，<strong>nsqd</strong> 将发送一个心跳线连接。客户端可以配置心跳之间的间隔，但 <strong>nsqd</strong> 会期待一个回应在它发送下一个心掉之前。</p>
<p>组合应用级别的心跳和 RDY 状态，避免头阻塞现象，也可能使心跳无用（即，如果消费者是在后面的处理消息流的接收缓冲区中，操作系统将被填满，堵心跳）</p>
<p>为了保证进度，所有的网络 IO 时间上限势必与配置的心跳间隔相关联。这意味着，你可以从字面上拔掉之间的网络连接 nsqd 和消费者，它会检测并正确处理错误。</p>
<p>当检测到一个致命错误，客户端连接被强制关闭。在传输中的消息会超时而重新排队等待传递到另一个消费者。最后，错误会被记录并累计到各种内部指标。</p>
<h4 id="管理-Goroutines"><a href="#管理-Goroutines" class="headerlink" title="管理 Goroutines"></a>管理 Goroutines</h4><p>非常容易启动  goroutine。不幸的是，不是很容易以协调他们的清理工作。避免死锁也极具挑战性。大多数情况下这可以归结为一个顺序的问题，在上游  goroutine 发送消息到 go-chan 之前，另一个 goroutine 从 go-chan 上接收消息。</p>
<p>为什么要关心这些？这很显然，孤立的 goroutine 是内存泄漏。内存泄露在长期运行的守护进程中是相当糟糕的，尤其当期望的是你的进程能够稳定运行，但其它都失败了。</p>
<p>更复杂的是，一个典型的 nsqd 进程中有许多参与消息传递 goroutines。在内部，消息的“所有权”频繁变化。为了能够完全关闭，统计全部进程内的消息是非常重要的。</p>
<p>虽然目前还没有任何灵丹妙药，下列技术使它变得更轻松管理。</p>
<h5 id="WaitGroups"><a href="#WaitGroups" class="headerlink" title="WaitGroups"></a>WaitGroups</h5><p><a href="http://golang.org/pkg/sync/" target="_blank" rel="noopener"><code>sync</code></a> 包提供了 sync.WaitGroup, 可以被用来累计多少个 goroutine 是活跃的（并且意味着一直等待直到它们退出）。</p>
<p>为了减少典型样板，nsqd 使用以下装饰器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroupWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WaitGroupWrapper)</span> <span class="title">Wrap</span><span class="params">(cb <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    w.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cb()</span><br><span class="line">        w.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can be used as follows:</span></span><br><span class="line">wg := WaitGroupWrapper&#123;&#125;</span><br><span class="line">wg.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; n.idPump() &#125;)</span><br><span class="line">...</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<h5 id="退出信号"><a href="#退出信号" class="headerlink" title="退出信号"></a>退出信号</h5><p>有一个简单的方式在多个 child goroutine 中触发一个事件是提供一个 go-chane，当你准备好时关闭它。所有在那个 go-chan 上挂起的 go-chan 都将会被激活，而不是向每个 goroutine 中发送一个单独的信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> task1(exitChan)</span><br><span class="line">    <span class="keyword">go</span> task2(exitChan)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task1</span><span class="params">(exitChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;-exitChan</span><br><span class="line">    log.Printf(<span class="string">"task1 exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task2</span><span class="params">(exitChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &lt;-exitChan</span><br><span class="line">    log.Printf(<span class="string">"task2 exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="退出时的同步"><a href="#退出时的同步" class="headerlink" title="退出时的同步"></a>退出时的同步</h5><p>实现一个可靠的，无死锁的，所有传递中的消息的退出路径是相当困难的。一些提示：</p>
<ol>
<li>理想的情况是负责发送到 go-chan 的 goroutine 中也应负责关闭它。</li>
<li>如果 message 不能丢失，确保相关的 go-chan 被清空（尤其是无缓冲的！），以保证发送者可以取得进展。</li>
<li>另外，如果消息是不重要的，发送给一个单一的 go-chan 应转换为一个 <code>select</code> 附加一个退出信号（如上所述），以保证取得进展。</li>
<li>一般的顺序应该是<ol>
<li>停止接受新的连接（close listeners）</li>
<li>发送退出信号给 c hild goroutines (如上文)</li>
<li>在 <code>WaitGroup</code> 等待 goroutine 退出（如上文）</li>
<li>恢复缓冲数据</li>
<li>刷新所有东西到硬盘</li>
</ol>
</li>
</ol>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>最后，日志是您所获得的记录 goroutine 进入和退出的重要工具！。这使得它相当容易识别造成死锁或泄漏的情况的罪魁祸首。</p>
<p><strong>nsqd</strong> 日志行包括 goroutine 与他们的 siblings(and parent）的信息，如客户端的远程地址或话题（topic）/通道（channel）名。</p>
<p>该日志是详细的，但不是详细的日志是压倒性的。有一条细线，但 nsqd 倾向于发生故障时在日志中提供更多的信息，而不是试图减少繁琐的有效性为代价。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">Wang YangYang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wangyangyangisme.github.io/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/">http://wangyangyangisme.github.io/2019/09/27/nsq-NSQ%E6%A6%82%E8%BF%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wangyangyangisme.github.io" target="_blank">WangYangYang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/76bc52296bcf2e0b7a1d628106ffcd52.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/donat/fab2285fdcd13ead0a8b4a853c659d03.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/09/27/nsq-NSQ%E7%BB%84%E4%BB%B6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nsq/aecd3bf79ad484e4bb0008b33b8d99fd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NSQ组件</div></div></a></div><div class="next-post pull_right"><a href="/2019/09/27/nats-NATS%E4%B8%8ENSQ%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/wangyangyangisme/CDN@latest/cover/nats/117253db2af95b52a584feae021fb1f8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NATS与NSQ的介绍和比较</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: false,
  appId: '49gEIIGN7uRbL6vHhieSpBzM-MdYXbMMI',
  appKey: 'uqts0urLKwikYQ0fKmIkMHBE',
  placeholder: '请留下你的脚印',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wang YangYang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://wangyangyangisme.github.io/">blog</a>!</div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/algolia.js"></script></body></html>